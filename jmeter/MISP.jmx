<?xml version="1.0" encoding="UTF-8"?>
<jmeterTestPlan version="1.2" properties="2.9" jmeter="3.0 r1743807">
  <hashTree>
    <TestPlan guiclass="TestPlanGui" testclass="TestPlan" testname="テスト計画" enabled="true">
      <stringProp name="TestPlan.comments"></stringProp>
      <boolProp name="TestPlan.functional_mode">false</boolProp>
      <boolProp name="TestPlan.serialize_threadgroups">true</boolProp>
      <elementProp name="TestPlan.user_defined_variables" elementType="Arguments" guiclass="ArgumentsPanel" testclass="Arguments" testname="ユーザー定義変数" enabled="true">
        <collectionProp name="Arguments.arguments">
          <elementProp name="consumer_key" elementType="Argument">
            <stringProp name="Argument.name">consumer_key</stringProp>
            <stringProp name="Argument.value">00000</stringProp>
            <stringProp name="Argument.metadata">=</stringProp>
          </elementProp>
          <elementProp name="consumer_secret" elementType="Argument">
            <stringProp name="Argument.name">consumer_secret</stringProp>
            <stringProp name="Argument.value">JJBH8Y120NYi0iXbDyJSWsnRTbdcjkNtMCsytlpaD0DEosMMcg02YdooLC02qAji</stringProp>
            <stringProp name="Argument.metadata">=</stringProp>
          </elementProp>
        </collectionProp>
      </elementProp>
      <stringProp name="TestPlan.user_define_classpath"></stringProp>
    </TestPlan>
    <hashTree>
      <ConfigTestElement guiclass="HttpDefaultsGui" testclass="ConfigTestElement" testname="HTTP リクエスト初期値設定 dev" enabled="true">
        <elementProp name="HTTPsampler.Arguments" elementType="Arguments" guiclass="HTTPArgumentsPanel" testclass="Arguments" testname="ユーザー定義変数" enabled="true">
          <collectionProp name="Arguments.arguments"/>
        </elementProp>
        <stringProp name="HTTPSampler.domain">misp-dev-gdsf.marv-games.jp</stringProp>
        <stringProp name="HTTPSampler.port"></stringProp>
        <stringProp name="HTTPSampler.connect_timeout"></stringProp>
        <stringProp name="HTTPSampler.response_timeout"></stringProp>
        <stringProp name="HTTPSampler.protocol">http</stringProp>
        <stringProp name="HTTPSampler.contentEncoding">UTF-8</stringProp>
        <stringProp name="HTTPSampler.path"></stringProp>
        <stringProp name="HTTPSampler.concurrentPool">4</stringProp>
      </ConfigTestElement>
      <hashTree/>
      <CookieManager guiclass="CookiePanel" testclass="CookieManager" testname="HTTP クッキーマネージャ" enabled="true">
        <collectionProp name="CookieManager.cookies"/>
        <boolProp name="CookieManager.clearEachIteration">true</boolProp>
      </CookieManager>
      <hashTree/>
      <Arguments guiclass="ArgumentsPanel" testclass="Arguments" testname="変数設定 dev" enabled="true">
        <collectionProp name="Arguments.arguments">
          <elementProp name="jmeter_path" elementType="Argument">
            <stringProp name="Argument.name">jmeter_path</stringProp>
            <stringProp name="Argument.value">misp-dev-gdsf.marv-games.jp</stringProp>
            <stringProp name="Argument.metadata">=</stringProp>
          </elementProp>
          <elementProp name="misp_url" elementType="Argument">
            <stringProp name="Argument.name">misp_url</stringProp>
            <stringProp name="Argument.value">misp-dev-gdsf.marv-games.jp</stringProp>
            <stringProp name="Argument.metadata">=</stringProp>
          </elementProp>
          <elementProp name="protocol" elementType="Argument">
            <stringProp name="Argument.name">protocol</stringProp>
            <stringProp name="Argument.value">http</stringProp>
            <stringProp name="Argument.metadata">=</stringProp>
          </elementProp>
          <elementProp name="server_name" elementType="Argument">
            <stringProp name="Argument.name">server_name</stringProp>
            <stringProp name="Argument.value">misp-dev-gdsf.marv-games.jp</stringProp>
            <stringProp name="Argument.metadata">=</stringProp>
          </elementProp>
        </collectionProp>
      </Arguments>
      <hashTree/>
      <ResultCollector guiclass="ViewResultsFullVisualizer" testclass="ResultCollector" testname="結果をツリーで表示" enabled="true">
        <boolProp name="ResultCollector.error_logging">false</boolProp>
        <objProp>
          <name>saveConfig</name>
          <value class="SampleSaveConfiguration">
            <time>true</time>
            <latency>true</latency>
            <timestamp>true</timestamp>
            <success>true</success>
            <label>true</label>
            <code>true</code>
            <message>true</message>
            <threadName>true</threadName>
            <dataType>true</dataType>
            <encoding>false</encoding>
            <assertions>true</assertions>
            <subresults>true</subresults>
            <responseData>false</responseData>
            <samplerData>false</samplerData>
            <xml>false</xml>
            <fieldNames>true</fieldNames>
            <responseHeaders>false</responseHeaders>
            <requestHeaders>false</requestHeaders>
            <responseDataOnError>false</responseDataOnError>
            <saveAssertionResultsFailureMessage>true</saveAssertionResultsFailureMessage>
            <assertionsResultsToSave>0</assertionsResultsToSave>
            <bytes>true</bytes>
            <threadCounts>true</threadCounts>
            <idleTime>true</idleTime>
          </value>
        </objProp>
        <objProp>
          <name></name>
          <value class="SampleSaveConfiguration">
            <time>true</time>
            <latency>true</latency>
            <timestamp>true</timestamp>
            <success>true</success>
            <label>true</label>
            <code>true</code>
            <message>true</message>
            <threadName>true</threadName>
            <dataType>true</dataType>
            <encoding>false</encoding>
            <assertions>true</assertions>
            <subresults>true</subresults>
            <responseData>false</responseData>
            <samplerData>false</samplerData>
            <xml>false</xml>
            <fieldNames>false</fieldNames>
            <responseHeaders>false</responseHeaders>
            <requestHeaders>false</requestHeaders>
            <responseDataOnError>false</responseDataOnError>
            <saveAssertionResultsFailureMessage>false</saveAssertionResultsFailureMessage>
            <assertionsResultsToSave>0</assertionsResultsToSave>
            <bytes>true</bytes>
          </value>
        </objProp>
        <stringProp name="filename"></stringProp>
      </ResultCollector>
      <hashTree/>
      <ResultCollector guiclass="TableVisualizer" testclass="ResultCollector" testname="結果を表で表示" enabled="true">
        <boolProp name="ResultCollector.error_logging">false</boolProp>
        <objProp>
          <name>saveConfig</name>
          <value class="SampleSaveConfiguration">
            <time>true</time>
            <latency>true</latency>
            <timestamp>true</timestamp>
            <success>true</success>
            <label>true</label>
            <code>true</code>
            <message>true</message>
            <threadName>true</threadName>
            <dataType>true</dataType>
            <encoding>false</encoding>
            <assertions>true</assertions>
            <subresults>true</subresults>
            <responseData>false</responseData>
            <samplerData>false</samplerData>
            <xml>false</xml>
            <fieldNames>true</fieldNames>
            <responseHeaders>false</responseHeaders>
            <requestHeaders>false</requestHeaders>
            <responseDataOnError>false</responseDataOnError>
            <saveAssertionResultsFailureMessage>true</saveAssertionResultsFailureMessage>
            <assertionsResultsToSave>0</assertionsResultsToSave>
            <bytes>true</bytes>
            <threadCounts>true</threadCounts>
            <idleTime>true</idleTime>
          </value>
        </objProp>
        <objProp>
          <name></name>
          <value class="SampleSaveConfiguration">
            <time>true</time>
            <latency>true</latency>
            <timestamp>true</timestamp>
            <success>true</success>
            <label>true</label>
            <code>true</code>
            <message>true</message>
            <threadName>true</threadName>
            <dataType>true</dataType>
            <encoding>false</encoding>
            <assertions>true</assertions>
            <subresults>true</subresults>
            <responseData>false</responseData>
            <samplerData>false</samplerData>
            <xml>false</xml>
            <fieldNames>false</fieldNames>
            <responseHeaders>false</responseHeaders>
            <requestHeaders>false</requestHeaders>
            <responseDataOnError>false</responseDataOnError>
            <saveAssertionResultsFailureMessage>false</saveAssertionResultsFailureMessage>
            <assertionsResultsToSave>0</assertionsResultsToSave>
            <bytes>true</bytes>
          </value>
        </objProp>
        <stringProp name="filename"></stringProp>
      </ResultCollector>
      <hashTree/>
      <ThreadGroup guiclass="ThreadGroupGui" testclass="ThreadGroup" testname="Implicit_1.ID連携→解除(ログイン画面から)" enabled="true">
        <stringProp name="ThreadGroup.on_sample_error">continue</stringProp>
        <elementProp name="ThreadGroup.main_controller" elementType="LoopController" guiclass="LoopControlPanel" testclass="LoopController" testname="ループコントローラ" enabled="true">
          <boolProp name="LoopController.continue_forever">false</boolProp>
          <stringProp name="LoopController.loops">1</stringProp>
        </elementProp>
        <stringProp name="ThreadGroup.num_threads">1</stringProp>
        <stringProp name="ThreadGroup.ramp_time">1</stringProp>
        <longProp name="ThreadGroup.start_time">1386654990000</longProp>
        <longProp name="ThreadGroup.end_time">1386654990000</longProp>
        <boolProp name="ThreadGroup.scheduler">false</boolProp>
        <stringProp name="ThreadGroup.duration"></stringProp>
        <stringProp name="ThreadGroup.delay"></stringProp>
      </ThreadGroup>
      <hashTree>
        <HTTPSamplerProxy guiclass="HttpTestSampleGui" testclass="HTTPSamplerProxy" testname="Implicit.MISPログイン画面" enabled="true">
          <elementProp name="HTTPsampler.Arguments" elementType="Arguments" guiclass="HTTPArgumentsPanel" testclass="Arguments" enabled="true">
            <collectionProp name="Arguments.arguments">
              <elementProp name="response_type" elementType="HTTPArgument">
                <boolProp name="HTTPArgument.always_encode">false</boolProp>
                <stringProp name="Argument.name">response_type</stringProp>
                <stringProp name="Argument.value">id_token+token</stringProp>
                <stringProp name="Argument.metadata">=</stringProp>
                <boolProp name="HTTPArgument.use_equals">true</boolProp>
              </elementProp>
              <elementProp name="client_id" elementType="HTTPArgument">
                <boolProp name="HTTPArgument.always_encode">false</boolProp>
                <stringProp name="Argument.name">client_id</stringProp>
                <stringProp name="Argument.value">00000</stringProp>
                <stringProp name="Argument.metadata">=</stringProp>
                <boolProp name="HTTPArgument.use_equals">true</boolProp>
              </elementProp>
              <elementProp name="redirect_uri" elementType="HTTPArgument">
                <boolProp name="HTTPArgument.always_encode">false</boolProp>
                <stringProp name="Argument.name">redirect_uri</stringProp>
                <stringProp name="Argument.value">${protocol}%3A%2F%2F${jmeter_path}%2Ftest%2Fmisp%2Fmisp-callback</stringProp>
                <stringProp name="Argument.metadata">=</stringProp>
                <boolProp name="HTTPArgument.use_equals">true</boolProp>
              </elementProp>
              <elementProp name="scope" elementType="HTTPArgument">
                <boolProp name="HTTPArgument.always_encode">false</boolProp>
                <stringProp name="Argument.name">scope</stringProp>
                <stringProp name="Argument.value">openid</stringProp>
                <stringProp name="Argument.metadata">=</stringProp>
                <boolProp name="HTTPArgument.use_equals">true</boolProp>
              </elementProp>
              <elementProp name="state" elementType="HTTPArgument">
                <boolProp name="HTTPArgument.always_encode">false</boolProp>
                <stringProp name="Argument.name">state</stringProp>
                <stringProp name="Argument.value">ddd</stringProp>
                <stringProp name="Argument.metadata">=</stringProp>
                <boolProp name="HTTPArgument.use_equals">true</boolProp>
              </elementProp>
              <elementProp name="nonce" elementType="HTTPArgument">
                <boolProp name="HTTPArgument.always_encode">false</boolProp>
                <stringProp name="Argument.name">nonce</stringProp>
                <stringProp name="Argument.value">213</stringProp>
                <stringProp name="Argument.metadata">=</stringProp>
                <boolProp name="HTTPArgument.use_equals">true</boolProp>
              </elementProp>
            </collectionProp>
          </elementProp>
          <stringProp name="HTTPSampler.domain"></stringProp>
          <stringProp name="HTTPSampler.port"></stringProp>
          <stringProp name="HTTPSampler.connect_timeout"></stringProp>
          <stringProp name="HTTPSampler.response_timeout"></stringProp>
          <stringProp name="HTTPSampler.protocol"></stringProp>
          <stringProp name="HTTPSampler.contentEncoding"></stringProp>
          <stringProp name="HTTPSampler.path">/marvelous/authorization/login</stringProp>
          <stringProp name="HTTPSampler.method">GET</stringProp>
          <boolProp name="HTTPSampler.follow_redirects">true</boolProp>
          <boolProp name="HTTPSampler.auto_redirects">false</boolProp>
          <boolProp name="HTTPSampler.use_keepalive">true</boolProp>
          <boolProp name="HTTPSampler.DO_MULTIPART_POST">false</boolProp>
          <boolProp name="HTTPSampler.monitor">false</boolProp>
          <stringProp name="HTTPSampler.embedded_url_re"></stringProp>
        </HTTPSamplerProxy>
        <hashTree>
          <RegexExtractor guiclass="RegexExtractorGui" testclass="RegexExtractor" testname="access_token" enabled="true">
            <stringProp name="RegexExtractor.useHeaders">false</stringProp>
            <stringProp name="RegexExtractor.refname">access_token</stringProp>
            <stringProp name="RegexExtractor.regex">access_token=(.*?)&lt;br&gt;</stringProp>
            <stringProp name="RegexExtractor.template">$1$</stringProp>
            <stringProp name="RegexExtractor.default"></stringProp>
            <stringProp name="RegexExtractor.match_number">1</stringProp>
          </RegexExtractor>
          <hashTree/>
          <RegexExtractor guiclass="RegexExtractorGui" testclass="RegexExtractor" testname="id_token" enabled="true">
            <stringProp name="RegexExtractor.useHeaders">false</stringProp>
            <stringProp name="RegexExtractor.refname">id_token</stringProp>
            <stringProp name="RegexExtractor.regex">id_token=(.*?)&lt;br&gt;</stringProp>
            <stringProp name="RegexExtractor.template">$1$</stringProp>
            <stringProp name="RegexExtractor.default"></stringProp>
            <stringProp name="RegexExtractor.match_number">1</stringProp>
          </RegexExtractor>
          <hashTree/>
        </hashTree>
        <HTTPSamplerProxy guiclass="HttpTestSampleGui" testclass="HTTPSamplerProxy" testname="Implicit.ID連携認証" enabled="true">
          <elementProp name="HTTPsampler.Arguments" elementType="Arguments" guiclass="HTTPArgumentsPanel" testclass="Arguments" enabled="true">
            <collectionProp name="Arguments.arguments">
              <elementProp name="response_type" elementType="HTTPArgument">
                <boolProp name="HTTPArgument.always_encode">false</boolProp>
                <stringProp name="Argument.name">response_type</stringProp>
                <stringProp name="Argument.value">id_token+token</stringProp>
                <stringProp name="Argument.metadata">=</stringProp>
                <boolProp name="HTTPArgument.use_equals">true</boolProp>
              </elementProp>
              <elementProp name="client_id" elementType="HTTPArgument">
                <boolProp name="HTTPArgument.always_encode">false</boolProp>
                <stringProp name="Argument.name">client_id</stringProp>
                <stringProp name="Argument.value">00000</stringProp>
                <stringProp name="Argument.metadata">=</stringProp>
                <boolProp name="HTTPArgument.use_equals">true</boolProp>
              </elementProp>
              <elementProp name="redirect_uri" elementType="HTTPArgument">
                <boolProp name="HTTPArgument.always_encode">false</boolProp>
                <stringProp name="Argument.name">redirect_uri</stringProp>
                <stringProp name="Argument.value">${protocol}%3A%2F%2F${jmeter_path}%2Ftest%2Fmisp%2Fmisp-callback</stringProp>
                <stringProp name="Argument.metadata">=</stringProp>
                <boolProp name="HTTPArgument.use_equals">true</boolProp>
              </elementProp>
              <elementProp name="scope" elementType="HTTPArgument">
                <boolProp name="HTTPArgument.always_encode">false</boolProp>
                <stringProp name="Argument.name">scope</stringProp>
                <stringProp name="Argument.value">openid</stringProp>
                <stringProp name="Argument.metadata">=</stringProp>
                <boolProp name="HTTPArgument.use_equals">true</boolProp>
              </elementProp>
              <elementProp name="state" elementType="HTTPArgument">
                <boolProp name="HTTPArgument.always_encode">false</boolProp>
                <stringProp name="Argument.name">state</stringProp>
                <stringProp name="Argument.value">ddd</stringProp>
                <stringProp name="Argument.metadata">=</stringProp>
                <boolProp name="HTTPArgument.use_equals">true</boolProp>
              </elementProp>
              <elementProp name="nonce" elementType="HTTPArgument">
                <boolProp name="HTTPArgument.always_encode">false</boolProp>
                <stringProp name="Argument.name">nonce</stringProp>
                <stringProp name="Argument.value">213</stringProp>
                <stringProp name="Argument.metadata">=</stringProp>
                <boolProp name="HTTPArgument.use_equals">true</boolProp>
              </elementProp>
              <elementProp name="platform_id" elementType="HTTPArgument">
                <boolProp name="HTTPArgument.always_encode">false</boolProp>
                <stringProp name="Argument.name">platform_id</stringProp>
                <stringProp name="Argument.value">Dummy1</stringProp>
                <stringProp name="Argument.metadata">=</stringProp>
                <boolProp name="HTTPArgument.use_equals">true</boolProp>
              </elementProp>
            </collectionProp>
          </elementProp>
          <stringProp name="HTTPSampler.domain"></stringProp>
          <stringProp name="HTTPSampler.port"></stringProp>
          <stringProp name="HTTPSampler.connect_timeout"></stringProp>
          <stringProp name="HTTPSampler.response_timeout"></stringProp>
          <stringProp name="HTTPSampler.protocol"></stringProp>
          <stringProp name="HTTPSampler.contentEncoding"></stringProp>
          <stringProp name="HTTPSampler.path">/marvelous/federation</stringProp>
          <stringProp name="HTTPSampler.method">GET</stringProp>
          <boolProp name="HTTPSampler.follow_redirects">true</boolProp>
          <boolProp name="HTTPSampler.auto_redirects">false</boolProp>
          <boolProp name="HTTPSampler.use_keepalive">true</boolProp>
          <boolProp name="HTTPSampler.DO_MULTIPART_POST">false</boolProp>
          <boolProp name="HTTPSampler.monitor">false</boolProp>
          <stringProp name="HTTPSampler.embedded_url_re"></stringProp>
          <stringProp name="TestPlan.comments">Detected the start of a redirect chain</stringProp>
        </HTTPSamplerProxy>
        <hashTree>
          <RegexExtractor guiclass="RegexExtractorGui" testclass="RegexExtractor" testname="access_token" enabled="true">
            <stringProp name="RegexExtractor.useHeaders">false</stringProp>
            <stringProp name="RegexExtractor.refname">access_token</stringProp>
            <stringProp name="RegexExtractor.regex">access_token=(.*?)&lt;br&gt;</stringProp>
            <stringProp name="RegexExtractor.template">$1$</stringProp>
            <stringProp name="RegexExtractor.default"></stringProp>
            <stringProp name="RegexExtractor.match_number">1</stringProp>
          </RegexExtractor>
          <hashTree/>
          <RegexExtractor guiclass="RegexExtractorGui" testclass="RegexExtractor" testname="id_token" enabled="true">
            <stringProp name="RegexExtractor.useHeaders">false</stringProp>
            <stringProp name="RegexExtractor.refname">id_token</stringProp>
            <stringProp name="RegexExtractor.regex">id_token=(.*?)&lt;br&gt;</stringProp>
            <stringProp name="RegexExtractor.template">$1$</stringProp>
            <stringProp name="RegexExtractor.default"></stringProp>
            <stringProp name="RegexExtractor.match_number">1</stringProp>
          </RegexExtractor>
          <hashTree/>
        </hashTree>
        <HTTPSamplerProxy guiclass="HttpTestSampleGui" testclass="HTTPSamplerProxy" testname="Implicit.ユーザ更新" enabled="true">
          <boolProp name="HTTPSampler.postBodyRaw">true</boolProp>
          <elementProp name="HTTPsampler.Arguments" elementType="Arguments">
            <collectionProp name="Arguments.arguments">
              <elementProp name="" elementType="HTTPArgument">
                <boolProp name="HTTPArgument.always_encode">false</boolProp>
                <stringProp name="Argument.value">{&#xd;
  &quot;entry&quot;: [&#xd;
    {&#xd;
      &quot;apps&quot;: [&#xd;
        {&#xd;
          &quot;value&quot;: {&#xd;
            &quot;appId&quot;: &quot;00000&quot;,&#xd;
            &quot;userId&quot;: &quot;trustedproxy_test_1_${__RandomString(10,abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ)}&quot;,&#xd;
            &quot;username&quot;: &quot;trustedproxyユーザ1&quot;,&#xd;
            &quot;password&quot;: &quot;trustedproxy_password1&quot;&#xd;
          }&#xd;
        }&#xd;
      ]&#xd;
    }&#xd;
  ]&#xd;
}</stringProp>
                <stringProp name="Argument.metadata">=</stringProp>
              </elementProp>
            </collectionProp>
          </elementProp>
          <stringProp name="HTTPSampler.domain"></stringProp>
          <stringProp name="HTTPSampler.port"></stringProp>
          <stringProp name="HTTPSampler.connect_timeout"></stringProp>
          <stringProp name="HTTPSampler.response_timeout"></stringProp>
          <stringProp name="HTTPSampler.protocol"></stringProp>
          <stringProp name="HTTPSampler.contentEncoding"></stringProp>
          <stringProp name="HTTPSampler.path">/marvelous/people/@me/@self?access_token=${access_token}&amp;id_token=${id_token}</stringProp>
          <stringProp name="HTTPSampler.method">PUT</stringProp>
          <boolProp name="HTTPSampler.follow_redirects">true</boolProp>
          <boolProp name="HTTPSampler.auto_redirects">false</boolProp>
          <boolProp name="HTTPSampler.use_keepalive">true</boolProp>
          <boolProp name="HTTPSampler.DO_MULTIPART_POST">false</boolProp>
          <boolProp name="HTTPSampler.monitor">false</boolProp>
          <stringProp name="HTTPSampler.embedded_url_re"></stringProp>
        </HTTPSamplerProxy>
        <hashTree>
          <BSFPreProcessor guiclass="TestBeanGUI" testclass="BSFPreProcessor" testname="BSF PreProcessor" enabled="true">
            <stringProp name="filename"></stringProp>
            <stringProp name="parameters"></stringProp>
            <stringProp name="script">/*
 * A JavaScript implementation of the Secure Hash Algorithm, SHA-1, as defined
 * in FIPS PUB 180-1
 * Version 2.1a Copyright Paul Johnston 2000 - 2002.
 * Other contributors: Greg Holt, Andrew Kepert, Ydnar, Lostinet
 * Distributed under the BSD License
 * See http://pajhome.org.uk/crypt/md5 for details.
 */

/*
 * Configurable variables. You may need to tweak these to be compatible with
 * the server-side, but the defaults work in most cases.
 */
var hexcase = 0;  /* hex output format. 0 - lowercase; 1 - uppercase        */
var b64pad  = &quot;&quot;; /* base-64 pad character. &quot;=&quot; for strict RFC compliance   */
var chrsz   = 8;  /* bits per input character. 8 - ASCII; 16 - Unicode      */

/*
 * These are the functions you&apos;ll usually want to call
 * They take string arguments and return either hex or base-64 encoded strings
 */
function hex_sha1(s){return binb2hex(core_sha1(str2binb(s),s.length * chrsz));}
function b64_sha1(s){return binb2b64(core_sha1(str2binb(s),s.length * chrsz));}
function str_sha1(s){return binb2str(core_sha1(str2binb(s),s.length * chrsz));}
function hex_hmac_sha1(key, data){ return binb2hex(core_hmac_sha1(key, data));}
function b64_hmac_sha1(key, data){ return binb2b64(core_hmac_sha1(key, data));}
function str_hmac_sha1(key, data){ return binb2str(core_hmac_sha1(key, data));}

/*
 * Perform a simple self-test to see if the VM is working
 */
function sha1_vm_test()
{
  return hex_sha1(&quot;abc&quot;) == &quot;a9993e364706816aba3e25717850c26c9cd0d89d&quot;;
}

/*
 * Calculate the SHA-1 of an array of big-endian words, and a bit length
 */
function core_sha1(x, len)
{
  /* append padding */
  x[len &gt;&gt; 5] |= 0x80 &lt;&lt; (24 - len % 32);
  x[((len + 64 &gt;&gt; 9) &lt;&lt; 4) + 15] = len;

  var w = Array(80);
  var a =  1732584193;
  var b = -271733879;
  var c = -1732584194;
  var d =  271733878;
  var e = -1009589776;

  for(var i = 0; i &lt; x.length; i += 16)
  {
    var olda = a;
    var oldb = b;
    var oldc = c;
    var oldd = d;
    var olde = e;

    for(var j = 0; j &lt; 80; j++)
    {
      if(j &lt; 16) w[j] = x[i + j];
      else w[j] = rol(w[j-3] ^ w[j-8] ^ w[j-14] ^ w[j-16], 1);
      var t = safe_add(safe_add(rol(a, 5), sha1_ft(j, b, c, d)),
                       safe_add(safe_add(e, w[j]), sha1_kt(j)));
      e = d;
      d = c;
      c = rol(b, 30);
      b = a;
      a = t;
    }

    a = safe_add(a, olda);
    b = safe_add(b, oldb);
    c = safe_add(c, oldc);
    d = safe_add(d, oldd);
    e = safe_add(e, olde);
  }
  return Array(a, b, c, d, e);

}

/*
 * Perform the appropriate triplet combination function for the current
 * iteration
 */
function sha1_ft(t, b, c, d)
{
  if(t &lt; 20) return (b &amp; c) | ((~b) &amp; d);
  if(t &lt; 40) return b ^ c ^ d;
  if(t &lt; 60) return (b &amp; c) | (b &amp; d) | (c &amp; d);
  return b ^ c ^ d;
}

/*
 * Determine the appropriate additive constant for the current iteration
 */
function sha1_kt(t)
{
  return (t &lt; 20) ?  1518500249 : (t &lt; 40) ?  1859775393 :
         (t &lt; 60) ? -1894007588 : -899497514;
}

/*
 * Calculate the HMAC-SHA1 of a key and some data
 */
function core_hmac_sha1(key, data)
{
  var bkey = str2binb(key);
  if(bkey.length &gt; 16) bkey = core_sha1(bkey, key.length * chrsz);

  var ipad = Array(16), opad = Array(16);
  for(var i = 0; i &lt; 16; i++)
  {
    ipad[i] = bkey[i] ^ 0x36363636;
    opad[i] = bkey[i] ^ 0x5C5C5C5C;
  }

  var hash = core_sha1(ipad.concat(str2binb(data)), 512 + data.length * chrsz);
  return core_sha1(opad.concat(hash), 512 + 160);
}

/*
 * Add integers, wrapping at 2^32. This uses 16-bit operations internally
 * to work around bugs in some JS interpreters.
 */
function safe_add(x, y)
{
  var lsw = (x &amp; 0xFFFF) + (y &amp; 0xFFFF);
  var msw = (x &gt;&gt; 16) + (y &gt;&gt; 16) + (lsw &gt;&gt; 16);
  return (msw &lt;&lt; 16) | (lsw &amp; 0xFFFF);
}

/*
 * Bitwise rotate a 32-bit number to the left.
 */
function rol(num, cnt)
{
  return (num &lt;&lt; cnt) | (num &gt;&gt;&gt; (32 - cnt));
}

/*
 * Convert an 8-bit or 16-bit string to an array of big-endian words
 * In 8-bit function, characters &gt;255 have their hi-byte silently ignored.
 */
function str2binb(str)
{
  var bin = Array();
  var mask = (1 &lt;&lt; chrsz) - 1;
  for(var i = 0; i &lt; str.length * chrsz; i += chrsz)
    bin[i&gt;&gt;5] |= (str.charCodeAt(i / chrsz) &amp; mask) &lt;&lt; (32 - chrsz - i%32);
  return bin;
}

/*
 * Convert an array of big-endian words to a string
 */
function binb2str(bin)
{
  var str = &quot;&quot;;
  var mask = (1 &lt;&lt; chrsz) - 1;
  for(var i = 0; i &lt; bin.length * 32; i += chrsz)
    str += String.fromCharCode((bin[i&gt;&gt;5] &gt;&gt;&gt; (32 - chrsz - i%32)) &amp; mask);
  return str;
}

/*
 * Convert an array of big-endian words to a hex string.
 */
function binb2hex(binarray)
{
  var hex_tab = hexcase ? &quot;0123456789ABCDEF&quot; : &quot;0123456789abcdef&quot;;
  var str = &quot;&quot;;
  for(var i = 0; i &lt; binarray.length * 4; i++)
  {
    str += hex_tab.charAt((binarray[i&gt;&gt;2] &gt;&gt; ((3 - i%4)*8+4)) &amp; 0xF) +
           hex_tab.charAt((binarray[i&gt;&gt;2] &gt;&gt; ((3 - i%4)*8  )) &amp; 0xF);
  }
  return str;
}

/*
 * Convert an array of big-endian words to a base-64 string
 */
function binb2b64(binarray)
{
  var tab = &quot;ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/&quot;;
  var str = &quot;&quot;;
  for(var i = 0; i &lt; binarray.length * 4; i += 3)
  {
    var triplet = (((binarray[i   &gt;&gt; 2] &gt;&gt; 8 * (3 -  i   %4)) &amp; 0xFF) &lt;&lt; 16)
                | (((binarray[i+1 &gt;&gt; 2] &gt;&gt; 8 * (3 - (i+1)%4)) &amp; 0xFF) &lt;&lt; 8 )
                |  ((binarray[i+2 &gt;&gt; 2] &gt;&gt; 8 * (3 - (i+2)%4)) &amp; 0xFF);
    for(var j = 0; j &lt; 4; j++)
    {
      if(i * 8 + j * 6 &gt; binarray.length * 32) str += b64pad;
      else str += tab.charAt((triplet &gt;&gt; 6*(3-j)) &amp; 0x3F);
    }
  }
  return str;
}

/*
 * Copyright 2008 Netflix, Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/* Here&apos;s some JavaScript software for implementing OAuth.

   This isn&apos;t as useful as you might hope.  OAuth is based around
   allowing tools and websites to talk to each other.  However,
   JavaScript running in web browsers is hampered by security
   restrictions that prevent code running on one website from
   accessing data stored or served on another.

   Before you start hacking, make sure you understand the limitations
   posed by cross-domain XMLHttpRequest.

   On the bright side, some platforms use JavaScript as their
   language, but enable the programmer to access other web sites.
   Examples include Google Gadgets, and Microsoft Vista Sidebar.
   For those platforms, this library should come in handy.
*/

// The HMAC-SHA1 signature method calls b64_hmac_sha1, defined by
// http://pajhome.org.uk/crypt/md5/sha1.js

/* An OAuth message is represented as an object like this:
   {method: &quot;GET&quot;, action: &quot;http://server.com/path&quot;, parameters: ...}

   The parameters may be either a map {name: value, name2: value2}
   or an Array of name-value pairs [[name, value], [name2, value2]].
   The latter representation is more powerful: it supports parameters
   in a specific sequence, or several parameters with the same name;
   for example [[&quot;a&quot;, 1], [&quot;b&quot;, 2], [&quot;a&quot;, 3]].

   Parameter names and values are NOT percent-encoded in an object.
   They must be encoded before transmission and decoded after reception.
   For example, this message object:
   {method: &quot;GET&quot;, action: &quot;http://server/path&quot;, parameters: {p: &quot;x y&quot;}}
   ... can be transmitted as an HTTP request that begins:
   GET /path?p=x%20y HTTP/1.0
   (This isn&apos;t a valid OAuth request, since it lacks a signature etc.)
   Note that the object &quot;x y&quot; is transmitted as x%20y.  To encode
   parameters, you can call OAuth.addToURL, OAuth.formEncode or
   OAuth.getAuthorization.

   This message object model harmonizes with the browser object model for
   input elements of an form, whose value property isn&apos;t percent encoded.
   The browser encodes each value before transmitting it. For example,
   see consumer.setInputs in example/consumer.js.
 */

/* This script needs to know what time it is. By default, it uses the local
   clock (new Date), which is apt to be inaccurate in browsers. To do
   better, you can load this script from a URL whose query string contains
   an oauth_timestamp parameter, whose value is a current Unix timestamp.
   For example, when generating the enclosing document using PHP:

   &lt;script src=&quot;oauth.js?oauth_timestamp=&lt;?=time()?&gt;&quot; ...

   Another option is to call OAuth.correctTimestamp with a Unix timestamp.
 */

var OAuth; if (OAuth == null) OAuth = {};

OAuth.setProperties = function setProperties(into, from) {
    if (into != null &amp;&amp; from != null) {
        for (var key in from) {
            into[key] = from[key];
        }
    }
    return into;
}

OAuth.setProperties(OAuth, // utility functions
{
    percentEncode: function percentEncode(s) {
        if (s == null) {
            return &quot;&quot;;
        }
        if (s instanceof Array) {
            var e = &quot;&quot;;
            for (var i = 0; i &lt; s.length; ++s) {
                if (e != &quot;&quot;) e += &apos;&amp;&apos;;
                e += OAuth.percentEncode(s[i]);
            }
            return e;
        }
        s = encodeURIComponent(s);
        // Now replace the values which encodeURIComponent doesn&apos;t do
        // encodeURIComponent ignores: - _ . ! ~ * &apos; ( )
        // OAuth dictates the only ones you can ignore are: - _ . ~
        // Source: http://developer.mozilla.org/en/docs/Core_JavaScript_1.5_Reference:Global_Functions:encodeURIComponent
        s = s.replace(/\!/g, &quot;%21&quot;);
        s = s.replace(/\*/g, &quot;%2A&quot;);
        s = s.replace(/\&apos;/g, &quot;%27&quot;);
        s = s.replace(/\(/g, &quot;%28&quot;);
        s = s.replace(/\)/g, &quot;%29&quot;);
        return s;
    }
,
    decodePercent: function decodePercent(s) {
        if (s != null) {
            // Handle application/x-www-form-urlencoded, which is defined by
            // http://www.w3.org/TR/html4/interact/forms.html#h-17.13.4.1
            s = s.replace(/\+/g, &quot; &quot;);
        }
        return decodeURIComponent(s);
    }
,
    /** Convert the given parameters to an Array of name-value pairs. */
    getParameterList: function getParameterList(parameters) {
        if (parameters == null) {
            return [];
        }
        if (typeof parameters != &quot;object&quot;) {
            return OAuth.decodeForm(parameters + &quot;&quot;);
        }
        if (parameters instanceof Array) {
            return parameters;
        }
        var list = [];
        for (var p in parameters) {
            list.push([p, parameters[p]]);
        }
        return list;
    }
,
    /** Convert the given parameters to a map from name to value. */
    getParameterMap: function getParameterMap(parameters) {
        if (parameters == null) {
            return {};
        }
        if (typeof parameters != &quot;object&quot;) {
            return OAuth.getParameterMap(OAuth.decodeForm(parameters + &quot;&quot;));
        }
        if (parameters instanceof Array) {
            var map = {};
            for (var p = 0; p &lt; parameters.length; ++p) {
                var key = parameters[p][0];
                if (map[key] === undefined) { // first value wins
                    map[key] = parameters[p][1];
                }
            }
            return map;
        }
        return parameters;
    }
,
    getParameter: function getParameter(parameters, name) {
        if (parameters instanceof Array) {
            for (var p = 0; p &lt; parameters.length; ++p) {
                if (parameters[p][0] == name) {
                    return parameters[p][1]; // first value wins
                }
            }
        } else {
            return OAuth.getParameterMap(parameters)[name];
        }
        return null;
    }
,
    formEncode: function formEncode(parameters) {
        var form = &quot;&quot;;
        var list = OAuth.getParameterList(parameters);
        for (var p = 0; p &lt; list.length; ++p) {
            var value = list[p][1];
            if (value == null) value = &quot;&quot;;
            if (form != &quot;&quot;) form += &apos;&amp;&apos;;
            form += OAuth.percentEncode(list[p][0])
              +&apos;=&apos;+ OAuth.percentEncode(value);
        }
        return form;
    }
,
    decodeForm: function decodeForm(form) {
        var list = [];
        var nvps = form.split(&apos;&amp;&apos;);
        for (var n = 0; n &lt; nvps.length; ++n) {
            var nvp = nvps[n];
            if (nvp == &quot;&quot;) {
                continue;
            }
            var equals = nvp.indexOf(&apos;=&apos;);
            var name;
            var value;
            if (equals &lt; 0) {
                name = OAuth.decodePercent(nvp);
                value = null;
            } else {
                name = OAuth.decodePercent(nvp.substring(0, equals));
                value = OAuth.decodePercent(nvp.substring(equals + 1));
            }
            list.push([name, value]);
        }
        return list;
    }
,
    setParameter: function setParameter(message, name, value) {
        var parameters = message.parameters;
        if (parameters instanceof Array) {
            for (var p = 0; p &lt; parameters.length; ++p) {
                if (parameters[p][0] == name) {
                    if (value === undefined) {
                        parameters.splice(p, 1);
                    } else {
                        parameters[p][1] = value;
                        value = undefined;
                    }
                }
            }
            if (value !== undefined) {
                parameters.push([name, value]);
            }
        } else {
            parameters = OAuth.getParameterMap(parameters);
            parameters[name] = value;
            message.parameters = parameters;
        }
    }
,
    setParameters: function setParameters(message, parameters) {
        var list = OAuth.getParameterList(parameters);
        for (var i = 0; i &lt; list.length; ++i) {
            OAuth.setParameter(message, list[i][0], list[i][1]);
        }
    }
,
    /** Fill in parameters to help construct a request message.
        This function doesn&apos;t fill in every parameter.
        The accessor object should be like:
        {consumerKey:&apos;foo&apos;, consumerSecret:&apos;bar&apos;, accessorSecret:&apos;nurn&apos;, token:&apos;krelm&apos;, tokenSecret:&apos;blah&apos;}
        The accessorSecret property is optional.
     */
    completeRequest: function completeRequest(message, accessor) {
        if (message.method == null) {
            message.method = &quot;GET&quot;;
        }
        var map = OAuth.getParameterMap(message.parameters);
        if (map.oauth_consumer_key == null) {
            OAuth.setParameter(message, &quot;oauth_consumer_key&quot;, accessor.consumerKey || &quot;&quot;);
        }
        if (map.oauth_token == null &amp;&amp; accessor.token != null) {
            OAuth.setParameter(message, &quot;oauth_token&quot;, accessor.token);
        }
        if (map.oauth_version == null) {
            OAuth.setParameter(message, &quot;oauth_version&quot;, &quot;1.0&quot;);
        }
        if (map.oauth_timestamp == null) {
            OAuth.setParameter(message, &quot;oauth_timestamp&quot;, OAuth.timestamp());
        }
        if (map.oauth_nonce == null) {
            OAuth.setParameter(message, &quot;oauth_nonce&quot;, OAuth.nonce(6));
        }
        OAuth.SignatureMethod.sign(message, accessor);
    }
,
    setTimestampAndNonce: function setTimestampAndNonce(message) {
        OAuth.setParameter(message, &quot;oauth_timestamp&quot;, OAuth.timestamp());
        OAuth.setParameter(message, &quot;oauth_nonce&quot;, OAuth.nonce(6));
    }
,
    addToURL: function addToURL(url, parameters) {
        newURL = url;
        if (parameters != null) {
            var toAdd = OAuth.formEncode(parameters);
            if (toAdd.length &gt; 0) {
                var q = url.indexOf(&apos;?&apos;);
                if (q &lt; 0) newURL += &apos;?&apos;;
                else       newURL += &apos;&amp;&apos;;
                newURL += toAdd;
            }
        }
        return newURL;
    }
,
    /** Construct the value of the Authorization header for an HTTP request. */
    getAuthorizationHeader: function getAuthorizationHeader(realm, parameters) {
        var header = &apos;OAuth realm=&quot;&apos; + OAuth.percentEncode(realm) + &apos;&quot;&apos;;
        var list = OAuth.getParameterList(parameters);
        for (var p = 0; p &lt; list.length; ++p) {
            var parameter = list[p];
            var name = parameter[0];
            if (name.indexOf(&quot;oauth_&quot;) == 0) {
                header += &apos;,&apos; + OAuth.percentEncode(name) + &apos;=&quot;&apos; + OAuth.percentEncode(parameter[1]) + &apos;&quot;&apos;;
            }
        }
        return header;
    }
,
    /** Correct the time using a parameter from the URL from which the last script was loaded. */
    correctTimestampFromSrc: function correctTimestampFromSrc(parameterName) {
        parameterName = parameterName || &quot;oauth_timestamp&quot;;
        var scripts = document.getElementsByTagName(&apos;script&apos;);
        if (scripts == null || !scripts.length) return;
        var src = scripts[scripts.length-1].src;
        if (!src) return;
        var q = src.indexOf(&quot;?&quot;);
        if (q &lt; 0) return;
        parameters = OAuth.getParameterMap(OAuth.decodeForm(src.substring(q+1)));
        var t = parameters[parameterName];
        if (t == null) return;
        OAuth.correctTimestamp(t);
    }
,
    /** Generate timestamps starting with the given value. */
    correctTimestamp: function correctTimestamp(timestamp) {
        OAuth.timeCorrectionMsec = (timestamp * 1000) - (new Date()).getTime();
    }
,
    /** The difference between the correct time and my clock. */
    timeCorrectionMsec: 0
,
    timestamp: function timestamp() {
        var t = (new Date()).getTime() + OAuth.timeCorrectionMsec;
        return Math.floor(t / 1000);
    }
,
    nonce: function nonce(length) {
        var chars = OAuth.nonce.CHARS;
        var result = &quot;&quot;;
        for (var i = 0; i &lt; length; ++i) {
            var rnum = Math.floor(Math.random() * chars.length);
            result += chars.substring(rnum, rnum+1);
        }
        return result;
    }
});

OAuth.nonce.CHARS = &quot;0123456789ABCDEFGHIJKLMNOPQRSTUVWXTZabcdefghiklmnopqrstuvwxyz&quot;;

/** Define a constructor function,
    without causing trouble to anyone who was using it as a namespace.
    That is, if parent[name] already existed and had properties,
    copy those properties into the new constructor.
 */
OAuth.declareClass = function declareClass(parent, name, newConstructor) {
    var previous = parent[name];
    parent[name] = newConstructor;
    if (newConstructor != null &amp;&amp; previous != null) {
        for (var key in previous) {
            if (key != &quot;prototype&quot;) {
                newConstructor[key] = previous[key];
            }
        }
    }
    return newConstructor;
}

/** An abstract algorithm for signing messages. */
OAuth.declareClass(OAuth, &quot;SignatureMethod&quot;, function OAuthSignatureMethod(){});

OAuth.setProperties(OAuth.SignatureMethod.prototype, // instance members
{
    /** Add a signature to the message. */
    sign: function sign(message) {
        var baseString = OAuth.SignatureMethod.getBaseString(message);
        var signature = this.getSignature(baseString);
        OAuth.setParameter(message, &quot;oauth_signature&quot;, signature);
        return signature; // just in case someone&apos;s interested
    }
,
    /** Set the key string for signing. */
    initialize: function initialize(name, accessor) {
        var consumerSecret;
        if (accessor.accessorSecret != null
            &amp;&amp; name.length &gt; 9
            &amp;&amp; name.substring(name.length-9) == &quot;-Accessor&quot;)
        {
            consumerSecret = accessor.accessorSecret;
        } else {
            consumerSecret = accessor.consumerSecret;
        }
        this.key = OAuth.percentEncode(consumerSecret)
             +&quot;&amp;&quot;+ OAuth.percentEncode(accessor.tokenSecret);
    }
});

/* SignatureMethod expects an accessor object to be like this:
   {tokenSecret: &quot;lakjsdflkj...&quot;, consumerSecret: &quot;QOUEWRI..&quot;, accessorSecret: &quot;xcmvzc...&quot;}
   The accessorSecret property is optional.
 */
// Class members:
OAuth.setProperties(OAuth.SignatureMethod, // class members
{
    sign: function sign(message, accessor) {
        var name = OAuth.getParameterMap(message.parameters).oauth_signature_method;
        if (name == null || name == &quot;&quot;) {
            name = &quot;HMAC-SHA1&quot;;
            OAuth.setParameter(message, &quot;oauth_signature_method&quot;, name);
        }
        OAuth.SignatureMethod.newMethod(name, accessor).sign(message);
    }
,
    /** Instantiate a SignatureMethod for the given method name. */
    newMethod: function newMethod(name, accessor) {
        var impl = OAuth.SignatureMethod.REGISTERED[name];
        if (impl != null) {
            var method = new impl();
            method.initialize(name, accessor);
            return method;
        }
        var err = new Error(&quot;signature_method_rejected&quot;);
        var acceptable = &quot;&quot;;
        for (var r in OAuth.SignatureMethod.REGISTERED) {
            if (acceptable != &quot;&quot;) acceptable += &apos;&amp;&apos;;
            acceptable += OAuth.percentEncode(r);
        }
        err.oauth_acceptable_signature_methods = acceptable;
        throw err;
    }
,
    /** A map from signature method name to constructor. */
    REGISTERED : {}
,
    /** Subsequently, the given constructor will be used for the named methods.
        The constructor will be called with no parameters.
        The resulting object should usually implement getSignature(baseString).
        You can easily define such a constructor by calling makeSubclass, below.
     */
    registerMethodClass: function registerMethodClass(names, classConstructor) {
        for (var n = 0; n &lt; names.length; ++n) {
            OAuth.SignatureMethod.REGISTERED[names[n]] = classConstructor;
        }
    }
,
    /** Create a subclass of OAuth.SignatureMethod, with the given getSignature function. */
    makeSubclass: function makeSubclass(getSignatureFunction) {
        var superClass = OAuth.SignatureMethod;
        var subClass = function() {
            superClass.call(this);
        };
        subClass.prototype = new superClass();
        // Delete instance variables from prototype:
        // delete subclass.prototype... There aren&apos;t any.
        subClass.prototype.getSignature = getSignatureFunction;
        subClass.prototype.constructor = subClass;
        return subClass;
    }
,
    getBaseString: function getBaseString(message) {
        var URL = message.action;
        var q = URL.indexOf(&apos;?&apos;);
        var parameters;
        if (q &lt; 0) {
            parameters = message.parameters;
        } else {
            // Combine the URL query string with the other parameters:
            parameters = OAuth.decodeForm(URL.substring(q + 1));
            var toAdd = OAuth.getParameterList(message.parameters);
            for (var a = 0; a &lt; toAdd.length; ++a) {
                parameters.push(toAdd[a]);
            }
        }
        return OAuth.percentEncode(message.method.toUpperCase())
         +&apos;&amp;&apos;+ OAuth.percentEncode(OAuth.SignatureMethod.normalizeUrl(URL))
         +&apos;&amp;&apos;+ OAuth.percentEncode(OAuth.SignatureMethod.normalizeParameters(parameters));
    }
,
    normalizeUrl: function normalizeUrl(url) {
        var uri = OAuth.SignatureMethod.parseUri(url);
        var scheme = uri.protocol.toLowerCase();
        var authority = uri.authority.toLowerCase();
        var dropPort = (scheme == &quot;http&quot; &amp;&amp; uri.port == 80)
                    || (scheme == &quot;https&quot; &amp;&amp; uri.port == 443);
        if (dropPort) {
            // find the last : in the authority
            var index = authority.lastIndexOf(&quot;:&quot;);
            if (index &gt;= 0) {
                authority = authority.substring(0, index);
            }
        }
        var path = uri.path;
        if (!path) {
            path = &quot;/&quot;; // conforms to RFC 2616 section 3.2.2
        }
        // we know that there is no query and no fragment here.
        return scheme + &quot;://&quot; + authority + path;
    }
,
    parseUri: function parseUri (str) {
        /* This function was adapted from parseUri 1.2.1
           http://stevenlevithan.com/demo/parseuri/js/assets/parseuri.js
         */
        var o = {key: [&quot;source&quot;,&quot;protocol&quot;,&quot;authority&quot;,&quot;userInfo&quot;,&quot;user&quot;,&quot;password&quot;,&quot;host&quot;,&quot;port&quot;,&quot;relative&quot;,&quot;path&quot;,&quot;directory&quot;,&quot;file&quot;,&quot;query&quot;,&quot;anchor&quot;],
                 parser: {strict: /^(?:([^:\/?#]+):)?(?:\/\/((?:(([^:@\/]*):?([^:@\/]*))?@)?([^:\/?#]*)(?::(\d*))?))?((((?:[^?#\/]*\/)*)([^?#]*))(?:\?([^#]*))?(?:#(.*))?)/ }};
        var m = o.parser.strict.exec(str);
        var uri = {};
        var i = 14;
        while (i--) uri[o.key[i]] = m[i] || &quot;&quot;;
        return uri;
    }
,
    normalizeParameters: function normalizeParameters(parameters) {
        if (parameters == null) {
            return &quot;&quot;;
        }
        var list = OAuth.getParameterList(parameters);
        var sortable = [];
        for (var p = 0; p &lt; list.length; ++p) {
            var nvp = list[p];
            if (nvp[0] != &quot;oauth_signature&quot;) {
                sortable.push([ OAuth.percentEncode(nvp[0])
                              + &quot; &quot; // because it comes before any character that can appear in a percentEncoded string.
                              + OAuth.percentEncode(nvp[1])
                              , nvp]);
            }
        }
        sortable.sort(function(a,b) {
                          if (a[0] &lt; b[0]) return  -1;
                          if (a[0] &gt; b[0]) return 1;
                          return 0;
                      });
        var sorted = [];
        for (var s = 0; s &lt; sortable.length; ++s) {
            sorted.push(sortable[s][1]);
        }
        return OAuth.formEncode(sorted);
    }
});

OAuth.SignatureMethod.registerMethodClass([&quot;PLAINTEXT&quot;, &quot;PLAINTEXT-Accessor&quot;],
    OAuth.SignatureMethod.makeSubclass(
        function getSignature(baseString) {
            return this.key;
        }
    ));

OAuth.SignatureMethod.registerMethodClass([&quot;HMAC-SHA1&quot;, &quot;HMAC-SHA1-Accessor&quot;],
    OAuth.SignatureMethod.makeSubclass(
        function getSignature(baseString) {
            b64pad = &apos;=&apos;;
            var signature = b64_hmac_sha1(this.key, baseString);
            return signature;
        }
    ));

try {
    OAuth.correctTimestampFromSrc();
} catch(e) {
}


//--------------------------------------------------

var consumerKey = &quot;${consumer_key}&quot;;
var consumerSecret = &quot;${consumer_secret}&quot;;
var params = [];
var query = [];
query.push(&apos;access_token&apos; + &apos;=&apos; + &apos;${access_token}&apos;);
query.push(&apos;id_token&apos; + &apos;=&apos; + &apos;${id_token}&apos;);
var url =  &quot;${protocol}://${misp_url}/marvelous/people/@me/@self&quot;;

if (query.length) {
    url += &apos;?&apos; + query.join(&apos;&amp;&apos;);
}

var message = {
    method: &apos;put&apos;,
    parameters: params, 
    action: url
};

log.info(url);
log.info(consumerSecret);

var accessor = {
    consumerKey: consumerKey,
    consumerSecret: consumerSecret,
    token:  &apos;${access_token}&apos;,
    tokenSecret: &apos;${id_token}&apos;
};

OAuth.completeRequest(message, accessor);
vars.put(&apos;put_auth_header&apos;, OAuth.getAuthorizationHeader(&apos;&apos;, params).replace(&apos;OAuth realm=&quot;&quot;,&apos;, &apos; OAuth &apos;));
</stringProp>
            <stringProp name="scriptLanguage">javascript</stringProp>
          </BSFPreProcessor>
          <hashTree/>
          <HeaderManager guiclass="HeaderPanel" testclass="HeaderManager" testname="HTTP ヘッダマネージャ" enabled="true">
            <collectionProp name="HeaderManager.headers">
              <elementProp name="" elementType="Header">
                <stringProp name="Header.name">Authorization</stringProp>
                <stringProp name="Header.value">${put_auth_header}</stringProp>
              </elementProp>
              <elementProp name="" elementType="Header">
                <stringProp name="Header.name">content-type</stringProp>
                <stringProp name="Header.value">application/json; charset=utf8</stringProp>
              </elementProp>
              <elementProp name="" elementType="Header">
                <stringProp name="Header.name">Connection</stringProp>
                <stringProp name="Header.value">close</stringProp>
              </elementProp>
              <elementProp name="" elementType="Header">
                <stringProp name="Header.name">Accept-encoding</stringProp>
                <stringProp name="Header.value">gzip, deflate</stringProp>
              </elementProp>
            </collectionProp>
          </HeaderManager>
          <hashTree/>
        </hashTree>
        <HTTPSamplerProxy guiclass="HttpTestSampleGui" testclass="HTTPSamplerProxy" testname="Implicit.MISP連携一覧画面" enabled="true">
          <elementProp name="HTTPsampler.Arguments" elementType="Arguments" guiclass="HTTPArgumentsPanel" testclass="Arguments" enabled="true">
            <collectionProp name="Arguments.arguments">
              <elementProp name="response_type" elementType="HTTPArgument">
                <boolProp name="HTTPArgument.always_encode">false</boolProp>
                <stringProp name="Argument.name">response_type</stringProp>
                <stringProp name="Argument.value">id_token+token</stringProp>
                <stringProp name="Argument.metadata">=</stringProp>
                <boolProp name="HTTPArgument.use_equals">true</boolProp>
              </elementProp>
              <elementProp name="client_id" elementType="HTTPArgument">
                <boolProp name="HTTPArgument.always_encode">false</boolProp>
                <stringProp name="Argument.name">client_id</stringProp>
                <stringProp name="Argument.value">00000</stringProp>
                <stringProp name="Argument.metadata">=</stringProp>
                <boolProp name="HTTPArgument.use_equals">true</boolProp>
              </elementProp>
              <elementProp name="redirect_uri" elementType="HTTPArgument">
                <boolProp name="HTTPArgument.always_encode">false</boolProp>
                <stringProp name="Argument.name">redirect_uri</stringProp>
                <stringProp name="Argument.value">${protocol}%3A%2F%2F${jmeter_path}%2Ftest%2Fmisp%2Fmisp-callback</stringProp>
                <stringProp name="Argument.metadata">=</stringProp>
                <boolProp name="HTTPArgument.use_equals">true</boolProp>
              </elementProp>
              <elementProp name="scope" elementType="HTTPArgument">
                <boolProp name="HTTPArgument.always_encode">false</boolProp>
                <stringProp name="Argument.name">scope</stringProp>
                <stringProp name="Argument.value">openid</stringProp>
                <stringProp name="Argument.metadata">=</stringProp>
                <boolProp name="HTTPArgument.use_equals">true</boolProp>
              </elementProp>
              <elementProp name="state" elementType="HTTPArgument">
                <boolProp name="HTTPArgument.always_encode">false</boolProp>
                <stringProp name="Argument.name">state</stringProp>
                <stringProp name="Argument.value">ddd</stringProp>
                <stringProp name="Argument.metadata">=</stringProp>
                <boolProp name="HTTPArgument.use_equals">true</boolProp>
              </elementProp>
              <elementProp name="nonce" elementType="HTTPArgument">
                <boolProp name="HTTPArgument.always_encode">false</boolProp>
                <stringProp name="Argument.name">nonce</stringProp>
                <stringProp name="Argument.value">213</stringProp>
                <stringProp name="Argument.metadata">=</stringProp>
                <boolProp name="HTTPArgument.use_equals">true</boolProp>
              </elementProp>
              <elementProp name="access_token" elementType="HTTPArgument">
                <boolProp name="HTTPArgument.always_encode">false</boolProp>
                <stringProp name="Argument.value">${access_token}</stringProp>
                <stringProp name="Argument.metadata">=</stringProp>
                <boolProp name="HTTPArgument.use_equals">true</boolProp>
                <stringProp name="Argument.name">access_token</stringProp>
              </elementProp>
              <elementProp name="id_token" elementType="HTTPArgument">
                <boolProp name="HTTPArgument.always_encode">false</boolProp>
                <stringProp name="Argument.value">${id_token}</stringProp>
                <stringProp name="Argument.metadata">=</stringProp>
                <boolProp name="HTTPArgument.use_equals">true</boolProp>
                <stringProp name="Argument.name">id_token</stringProp>
              </elementProp>
            </collectionProp>
          </elementProp>
          <stringProp name="HTTPSampler.domain"></stringProp>
          <stringProp name="HTTPSampler.port"></stringProp>
          <stringProp name="HTTPSampler.connect_timeout"></stringProp>
          <stringProp name="HTTPSampler.response_timeout"></stringProp>
          <stringProp name="HTTPSampler.protocol"></stringProp>
          <stringProp name="HTTPSampler.contentEncoding"></stringProp>
          <stringProp name="HTTPSampler.path">/marvelous/authorization/login</stringProp>
          <stringProp name="HTTPSampler.method">GET</stringProp>
          <boolProp name="HTTPSampler.follow_redirects">true</boolProp>
          <boolProp name="HTTPSampler.auto_redirects">false</boolProp>
          <boolProp name="HTTPSampler.use_keepalive">true</boolProp>
          <boolProp name="HTTPSampler.DO_MULTIPART_POST">false</boolProp>
          <boolProp name="HTTPSampler.monitor">false</boolProp>
          <stringProp name="HTTPSampler.embedded_url_re"></stringProp>
        </HTTPSamplerProxy>
        <hashTree>
          <ResponseAssertion guiclass="AssertionGui" testclass="ResponseAssertion" testname="アサーション" enabled="true">
            <collectionProp name="Asserion.test_strings">
              <stringProp name="-443737813">platform_id=Dummy1&quot; data-login=&quot;true&quot; checked&gt;</stringProp>
            </collectionProp>
            <stringProp name="TestPlan.comments">確認項目
1.ユーザID統合された画面が表示されているか
2.最終ログインのプラットフォームに、ログイン状態のフラグが立っているか</stringProp>
            <stringProp name="Assertion.test_field">Assertion.response_data</stringProp>
            <boolProp name="Assertion.assume_success">false</boolProp>
            <intProp name="Assertion.test_type">2</intProp>
          </ResponseAssertion>
          <hashTree/>
          <RegexExtractor guiclass="RegexExtractorGui" testclass="RegexExtractor" testname="response_type_params" enabled="true">
            <stringProp name="RegexExtractor.useHeaders">false</stringProp>
            <stringProp name="RegexExtractor.refname">response_type_params</stringProp>
            <stringProp name="RegexExtractor.regex">response_type=(.*?)&quot; data-cancelidfederation</stringProp>
            <stringProp name="RegexExtractor.template">$1$</stringProp>
            <stringProp name="RegexExtractor.default"></stringProp>
            <stringProp name="RegexExtractor.match_number">1</stringProp>
          </RegexExtractor>
          <hashTree/>
        </hashTree>
        <HTTPSamplerProxy guiclass="HttpTestSampleGui" testclass="HTTPSamplerProxy" testname="Implicit.連携解除" enabled="true">
          <elementProp name="HTTPsampler.Arguments" elementType="Arguments" guiclass="HTTPArgumentsPanel" testclass="Arguments" enabled="true">
            <collectionProp name="Arguments.arguments">
              <elementProp name="response_type" elementType="HTTPArgument">
                <boolProp name="HTTPArgument.always_encode">false</boolProp>
                <stringProp name="Argument.value">${response_type_params}</stringProp>
                <stringProp name="Argument.metadata">=</stringProp>
                <boolProp name="HTTPArgument.use_equals">true</boolProp>
                <stringProp name="Argument.name">response_type</stringProp>
              </elementProp>
            </collectionProp>
          </elementProp>
          <stringProp name="HTTPSampler.domain"></stringProp>
          <stringProp name="HTTPSampler.port"></stringProp>
          <stringProp name="HTTPSampler.connect_timeout"></stringProp>
          <stringProp name="HTTPSampler.response_timeout"></stringProp>
          <stringProp name="HTTPSampler.protocol"></stringProp>
          <stringProp name="HTTPSampler.contentEncoding"></stringProp>
          <stringProp name="HTTPSampler.path">/marvelous/federation/cancel-application-user-federation</stringProp>
          <stringProp name="HTTPSampler.method">GET</stringProp>
          <boolProp name="HTTPSampler.follow_redirects">true</boolProp>
          <boolProp name="HTTPSampler.auto_redirects">false</boolProp>
          <boolProp name="HTTPSampler.use_keepalive">true</boolProp>
          <boolProp name="HTTPSampler.DO_MULTIPART_POST">false</boolProp>
          <boolProp name="HTTPSampler.monitor">false</boolProp>
          <stringProp name="HTTPSampler.embedded_url_re"></stringProp>
        </HTTPSamplerProxy>
        <hashTree>
          <ResponseAssertion guiclass="AssertionGui" testclass="ResponseAssertion" testname="MISPログイン画面が表示されているか" enabled="true">
            <collectionProp name="Asserion.test_strings">
              <stringProp name="159609953">privacyprotection</stringProp>
            </collectionProp>
            <stringProp name="TestPlan.comments">確認項目
初回ログイン画面が表示されているか</stringProp>
            <stringProp name="Assertion.test_field">Assertion.response_data</stringProp>
            <boolProp name="Assertion.assume_success">false</boolProp>
            <intProp name="Assertion.test_type">2</intProp>
          </ResponseAssertion>
          <hashTree/>
        </hashTree>
      </hashTree>
      <ThreadGroup guiclass="ThreadGroupGui" testclass="ThreadGroup" testname="Implicit_2.ID連携→更新成功→空パスワード更新成功→鍵エラー→Proxyエラー→ユーザ取得" enabled="true">
        <stringProp name="ThreadGroup.on_sample_error">continue</stringProp>
        <elementProp name="ThreadGroup.main_controller" elementType="LoopController" guiclass="LoopControlPanel" testclass="LoopController" testname="ループコントローラ" enabled="true">
          <boolProp name="LoopController.continue_forever">false</boolProp>
          <stringProp name="LoopController.loops">1</stringProp>
        </elementProp>
        <stringProp name="ThreadGroup.num_threads">1</stringProp>
        <stringProp name="ThreadGroup.ramp_time">1</stringProp>
        <longProp name="ThreadGroup.start_time">1386554467000</longProp>
        <longProp name="ThreadGroup.end_time">1386554467000</longProp>
        <boolProp name="ThreadGroup.scheduler">false</boolProp>
        <stringProp name="ThreadGroup.duration"></stringProp>
        <stringProp name="ThreadGroup.delay"></stringProp>
      </ThreadGroup>
      <hashTree>
        <HTTPSamplerProxy guiclass="HttpTestSampleGui" testclass="HTTPSamplerProxy" testname="Implicit.ID連携認証" enabled="true">
          <elementProp name="HTTPsampler.Arguments" elementType="Arguments" guiclass="HTTPArgumentsPanel" testclass="Arguments" enabled="true">
            <collectionProp name="Arguments.arguments">
              <elementProp name="response_type" elementType="HTTPArgument">
                <boolProp name="HTTPArgument.always_encode">false</boolProp>
                <stringProp name="Argument.name">response_type</stringProp>
                <stringProp name="Argument.value">id_token+token</stringProp>
                <stringProp name="Argument.metadata">=</stringProp>
                <boolProp name="HTTPArgument.use_equals">true</boolProp>
              </elementProp>
              <elementProp name="client_id" elementType="HTTPArgument">
                <boolProp name="HTTPArgument.always_encode">false</boolProp>
                <stringProp name="Argument.name">client_id</stringProp>
                <stringProp name="Argument.value">00000</stringProp>
                <stringProp name="Argument.metadata">=</stringProp>
                <boolProp name="HTTPArgument.use_equals">true</boolProp>
              </elementProp>
              <elementProp name="redirect_uri" elementType="HTTPArgument">
                <boolProp name="HTTPArgument.always_encode">false</boolProp>
                <stringProp name="Argument.name">redirect_uri</stringProp>
                <stringProp name="Argument.value">${protocol}%3A%2F%2F${jmeter_path}%2Ftest%2Fmisp%2Fmisp-callback</stringProp>
                <stringProp name="Argument.metadata">=</stringProp>
                <boolProp name="HTTPArgument.use_equals">true</boolProp>
              </elementProp>
              <elementProp name="scope" elementType="HTTPArgument">
                <boolProp name="HTTPArgument.always_encode">false</boolProp>
                <stringProp name="Argument.name">scope</stringProp>
                <stringProp name="Argument.value">openid</stringProp>
                <stringProp name="Argument.metadata">=</stringProp>
                <boolProp name="HTTPArgument.use_equals">true</boolProp>
              </elementProp>
              <elementProp name="state" elementType="HTTPArgument">
                <boolProp name="HTTPArgument.always_encode">false</boolProp>
                <stringProp name="Argument.name">state</stringProp>
                <stringProp name="Argument.value">ddd</stringProp>
                <stringProp name="Argument.metadata">=</stringProp>
                <boolProp name="HTTPArgument.use_equals">true</boolProp>
              </elementProp>
              <elementProp name="nonce" elementType="HTTPArgument">
                <boolProp name="HTTPArgument.always_encode">false</boolProp>
                <stringProp name="Argument.name">nonce</stringProp>
                <stringProp name="Argument.value">213</stringProp>
                <stringProp name="Argument.metadata">=</stringProp>
                <boolProp name="HTTPArgument.use_equals">true</boolProp>
              </elementProp>
              <elementProp name="platform_id" elementType="HTTPArgument">
                <boolProp name="HTTPArgument.always_encode">false</boolProp>
                <stringProp name="Argument.name">platform_id</stringProp>
                <stringProp name="Argument.value">Dummy1</stringProp>
                <stringProp name="Argument.metadata">=</stringProp>
                <boolProp name="HTTPArgument.use_equals">true</boolProp>
              </elementProp>
            </collectionProp>
          </elementProp>
          <stringProp name="HTTPSampler.domain"></stringProp>
          <stringProp name="HTTPSampler.port"></stringProp>
          <stringProp name="HTTPSampler.connect_timeout"></stringProp>
          <stringProp name="HTTPSampler.response_timeout"></stringProp>
          <stringProp name="HTTPSampler.protocol"></stringProp>
          <stringProp name="HTTPSampler.contentEncoding"></stringProp>
          <stringProp name="HTTPSampler.path">/marvelous/federation</stringProp>
          <stringProp name="HTTPSampler.method">GET</stringProp>
          <boolProp name="HTTPSampler.follow_redirects">true</boolProp>
          <boolProp name="HTTPSampler.auto_redirects">false</boolProp>
          <boolProp name="HTTPSampler.use_keepalive">true</boolProp>
          <boolProp name="HTTPSampler.DO_MULTIPART_POST">false</boolProp>
          <boolProp name="HTTPSampler.monitor">false</boolProp>
          <stringProp name="HTTPSampler.embedded_url_re"></stringProp>
          <stringProp name="TestPlan.comments">Detected the start of a redirect chain</stringProp>
        </HTTPSamplerProxy>
        <hashTree>
          <RegexExtractor guiclass="RegexExtractorGui" testclass="RegexExtractor" testname="access_token" enabled="true">
            <stringProp name="RegexExtractor.useHeaders">false</stringProp>
            <stringProp name="RegexExtractor.refname">access_token</stringProp>
            <stringProp name="RegexExtractor.regex">access_token=(.*?)&lt;br&gt;</stringProp>
            <stringProp name="RegexExtractor.template">$1$</stringProp>
            <stringProp name="RegexExtractor.default"></stringProp>
            <stringProp name="RegexExtractor.match_number">1</stringProp>
          </RegexExtractor>
          <hashTree/>
          <RegexExtractor guiclass="RegexExtractorGui" testclass="RegexExtractor" testname="id_token" enabled="true">
            <stringProp name="RegexExtractor.useHeaders">false</stringProp>
            <stringProp name="RegexExtractor.refname">id_token</stringProp>
            <stringProp name="RegexExtractor.regex">id_token=(.*?)&lt;br&gt;</stringProp>
            <stringProp name="RegexExtractor.template">$1$</stringProp>
            <stringProp name="RegexExtractor.default"></stringProp>
            <stringProp name="RegexExtractor.match_number">1</stringProp>
          </RegexExtractor>
          <hashTree/>
        </hashTree>
        <HTTPSamplerProxy guiclass="HttpTestSampleGui" testclass="HTTPSamplerProxy" testname="Implicit.ユーザ更新(ID連携)" enabled="true">
          <boolProp name="HTTPSampler.postBodyRaw">true</boolProp>
          <elementProp name="HTTPsampler.Arguments" elementType="Arguments">
            <collectionProp name="Arguments.arguments">
              <elementProp name="" elementType="HTTPArgument">
                <boolProp name="HTTPArgument.always_encode">false</boolProp>
                <stringProp name="Argument.value">{&#xd;
  &quot;entry&quot;: [&#xd;
    {&#xd;
      &quot;apps&quot;: [&#xd;
        {&#xd;
          &quot;value&quot;: {&#xd;
            &quot;appId&quot;: &quot;00000&quot;,&#xd;
            &quot;userId&quot;: &quot;proxy_test_3&quot;,&#xd;
            &quot;username&quot;: &quot;trustedproxy_3&quot;,&#xd;
            &quot;password&quot;: &quot;awawawa&quot;&#xd;
          }&#xd;
        }&#xd;
      ]&#xd;
    }&#xd;
  ]&#xd;
}</stringProp>
                <stringProp name="Argument.metadata">=</stringProp>
              </elementProp>
            </collectionProp>
          </elementProp>
          <stringProp name="HTTPSampler.domain"></stringProp>
          <stringProp name="HTTPSampler.port"></stringProp>
          <stringProp name="HTTPSampler.connect_timeout"></stringProp>
          <stringProp name="HTTPSampler.response_timeout"></stringProp>
          <stringProp name="HTTPSampler.protocol"></stringProp>
          <stringProp name="HTTPSampler.contentEncoding"></stringProp>
          <stringProp name="HTTPSampler.path">/marvelous/people/@me/@self?access_token=${access_token}&amp;id_token=${id_token}</stringProp>
          <stringProp name="HTTPSampler.method">PUT</stringProp>
          <boolProp name="HTTPSampler.follow_redirects">true</boolProp>
          <boolProp name="HTTPSampler.auto_redirects">false</boolProp>
          <boolProp name="HTTPSampler.use_keepalive">true</boolProp>
          <boolProp name="HTTPSampler.DO_MULTIPART_POST">false</boolProp>
          <boolProp name="HTTPSampler.monitor">false</boolProp>
          <stringProp name="HTTPSampler.embedded_url_re"></stringProp>
        </HTTPSamplerProxy>
        <hashTree>
          <BSFPreProcessor guiclass="TestBeanGUI" testclass="BSFPreProcessor" testname="BSF PreProcessor" enabled="true">
            <stringProp name="filename"></stringProp>
            <stringProp name="parameters"></stringProp>
            <stringProp name="script">/*
 * A JavaScript implementation of the Secure Hash Algorithm, SHA-1, as defined
 * in FIPS PUB 180-1
 * Version 2.1a Copyright Paul Johnston 2000 - 2002.
 * Other contributors: Greg Holt, Andrew Kepert, Ydnar, Lostinet
 * Distributed under the BSD License
 * See http://pajhome.org.uk/crypt/md5 for details.
 */

/*
 * Configurable variables. You may need to tweak these to be compatible with
 * the server-side, but the defaults work in most cases.
 */
var hexcase = 0;  /* hex output format. 0 - lowercase; 1 - uppercase        */
var b64pad  = &quot;&quot;; /* base-64 pad character. &quot;=&quot; for strict RFC compliance   */
var chrsz   = 8;  /* bits per input character. 8 - ASCII; 16 - Unicode      */

/*
 * These are the functions you&apos;ll usually want to call
 * They take string arguments and return either hex or base-64 encoded strings
 */
function hex_sha1(s){return binb2hex(core_sha1(str2binb(s),s.length * chrsz));}
function b64_sha1(s){return binb2b64(core_sha1(str2binb(s),s.length * chrsz));}
function str_sha1(s){return binb2str(core_sha1(str2binb(s),s.length * chrsz));}
function hex_hmac_sha1(key, data){ return binb2hex(core_hmac_sha1(key, data));}
function b64_hmac_sha1(key, data){ return binb2b64(core_hmac_sha1(key, data));}
function str_hmac_sha1(key, data){ return binb2str(core_hmac_sha1(key, data));}

/*
 * Perform a simple self-test to see if the VM is working
 */
function sha1_vm_test()
{
  return hex_sha1(&quot;abc&quot;) == &quot;a9993e364706816aba3e25717850c26c9cd0d89d&quot;;
}

/*
 * Calculate the SHA-1 of an array of big-endian words, and a bit length
 */
function core_sha1(x, len)
{
  /* append padding */
  x[len &gt;&gt; 5] |= 0x80 &lt;&lt; (24 - len % 32);
  x[((len + 64 &gt;&gt; 9) &lt;&lt; 4) + 15] = len;

  var w = Array(80);
  var a =  1732584193;
  var b = -271733879;
  var c = -1732584194;
  var d =  271733878;
  var e = -1009589776;

  for(var i = 0; i &lt; x.length; i += 16)
  {
    var olda = a;
    var oldb = b;
    var oldc = c;
    var oldd = d;
    var olde = e;

    for(var j = 0; j &lt; 80; j++)
    {
      if(j &lt; 16) w[j] = x[i + j];
      else w[j] = rol(w[j-3] ^ w[j-8] ^ w[j-14] ^ w[j-16], 1);
      var t = safe_add(safe_add(rol(a, 5), sha1_ft(j, b, c, d)),
                       safe_add(safe_add(e, w[j]), sha1_kt(j)));
      e = d;
      d = c;
      c = rol(b, 30);
      b = a;
      a = t;
    }

    a = safe_add(a, olda);
    b = safe_add(b, oldb);
    c = safe_add(c, oldc);
    d = safe_add(d, oldd);
    e = safe_add(e, olde);
  }
  return Array(a, b, c, d, e);

}

/*
 * Perform the appropriate triplet combination function for the current
 * iteration
 */
function sha1_ft(t, b, c, d)
{
  if(t &lt; 20) return (b &amp; c) | ((~b) &amp; d);
  if(t &lt; 40) return b ^ c ^ d;
  if(t &lt; 60) return (b &amp; c) | (b &amp; d) | (c &amp; d);
  return b ^ c ^ d;
}

/*
 * Determine the appropriate additive constant for the current iteration
 */
function sha1_kt(t)
{
  return (t &lt; 20) ?  1518500249 : (t &lt; 40) ?  1859775393 :
         (t &lt; 60) ? -1894007588 : -899497514;
}

/*
 * Calculate the HMAC-SHA1 of a key and some data
 */
function core_hmac_sha1(key, data)
{
  var bkey = str2binb(key);
  if(bkey.length &gt; 16) bkey = core_sha1(bkey, key.length * chrsz);

  var ipad = Array(16), opad = Array(16);
  for(var i = 0; i &lt; 16; i++)
  {
    ipad[i] = bkey[i] ^ 0x36363636;
    opad[i] = bkey[i] ^ 0x5C5C5C5C;
  }

  var hash = core_sha1(ipad.concat(str2binb(data)), 512 + data.length * chrsz);
  return core_sha1(opad.concat(hash), 512 + 160);
}

/*
 * Add integers, wrapping at 2^32. This uses 16-bit operations internally
 * to work around bugs in some JS interpreters.
 */
function safe_add(x, y)
{
  var lsw = (x &amp; 0xFFFF) + (y &amp; 0xFFFF);
  var msw = (x &gt;&gt; 16) + (y &gt;&gt; 16) + (lsw &gt;&gt; 16);
  return (msw &lt;&lt; 16) | (lsw &amp; 0xFFFF);
}

/*
 * Bitwise rotate a 32-bit number to the left.
 */
function rol(num, cnt)
{
  return (num &lt;&lt; cnt) | (num &gt;&gt;&gt; (32 - cnt));
}

/*
 * Convert an 8-bit or 16-bit string to an array of big-endian words
 * In 8-bit function, characters &gt;255 have their hi-byte silently ignored.
 */
function str2binb(str)
{
  var bin = Array();
  var mask = (1 &lt;&lt; chrsz) - 1;
  for(var i = 0; i &lt; str.length * chrsz; i += chrsz)
    bin[i&gt;&gt;5] |= (str.charCodeAt(i / chrsz) &amp; mask) &lt;&lt; (32 - chrsz - i%32);
  return bin;
}

/*
 * Convert an array of big-endian words to a string
 */
function binb2str(bin)
{
  var str = &quot;&quot;;
  var mask = (1 &lt;&lt; chrsz) - 1;
  for(var i = 0; i &lt; bin.length * 32; i += chrsz)
    str += String.fromCharCode((bin[i&gt;&gt;5] &gt;&gt;&gt; (32 - chrsz - i%32)) &amp; mask);
  return str;
}

/*
 * Convert an array of big-endian words to a hex string.
 */
function binb2hex(binarray)
{
  var hex_tab = hexcase ? &quot;0123456789ABCDEF&quot; : &quot;0123456789abcdef&quot;;
  var str = &quot;&quot;;
  for(var i = 0; i &lt; binarray.length * 4; i++)
  {
    str += hex_tab.charAt((binarray[i&gt;&gt;2] &gt;&gt; ((3 - i%4)*8+4)) &amp; 0xF) +
           hex_tab.charAt((binarray[i&gt;&gt;2] &gt;&gt; ((3 - i%4)*8  )) &amp; 0xF);
  }
  return str;
}

/*
 * Convert an array of big-endian words to a base-64 string
 */
function binb2b64(binarray)
{
  var tab = &quot;ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/&quot;;
  var str = &quot;&quot;;
  for(var i = 0; i &lt; binarray.length * 4; i += 3)
  {
    var triplet = (((binarray[i   &gt;&gt; 2] &gt;&gt; 8 * (3 -  i   %4)) &amp; 0xFF) &lt;&lt; 16)
                | (((binarray[i+1 &gt;&gt; 2] &gt;&gt; 8 * (3 - (i+1)%4)) &amp; 0xFF) &lt;&lt; 8 )
                |  ((binarray[i+2 &gt;&gt; 2] &gt;&gt; 8 * (3 - (i+2)%4)) &amp; 0xFF);
    for(var j = 0; j &lt; 4; j++)
    {
      if(i * 8 + j * 6 &gt; binarray.length * 32) str += b64pad;
      else str += tab.charAt((triplet &gt;&gt; 6*(3-j)) &amp; 0x3F);
    }
  }
  return str;
}

/*
 * Copyright 2008 Netflix, Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/* Here&apos;s some JavaScript software for implementing OAuth.

   This isn&apos;t as useful as you might hope.  OAuth is based around
   allowing tools and websites to talk to each other.  However,
   JavaScript running in web browsers is hampered by security
   restrictions that prevent code running on one website from
   accessing data stored or served on another.

   Before you start hacking, make sure you understand the limitations
   posed by cross-domain XMLHttpRequest.

   On the bright side, some platforms use JavaScript as their
   language, but enable the programmer to access other web sites.
   Examples include Google Gadgets, and Microsoft Vista Sidebar.
   For those platforms, this library should come in handy.
*/

// The HMAC-SHA1 signature method calls b64_hmac_sha1, defined by
// http://pajhome.org.uk/crypt/md5/sha1.js

/* An OAuth message is represented as an object like this:
   {method: &quot;GET&quot;, action: &quot;http://server.com/path&quot;, parameters: ...}

   The parameters may be either a map {name: value, name2: value2}
   or an Array of name-value pairs [[name, value], [name2, value2]].
   The latter representation is more powerful: it supports parameters
   in a specific sequence, or several parameters with the same name;
   for example [[&quot;a&quot;, 1], [&quot;b&quot;, 2], [&quot;a&quot;, 3]].

   Parameter names and values are NOT percent-encoded in an object.
   They must be encoded before transmission and decoded after reception.
   For example, this message object:
   {method: &quot;GET&quot;, action: &quot;http://server/path&quot;, parameters: {p: &quot;x y&quot;}}
   ... can be transmitted as an HTTP request that begins:
   GET /path?p=x%20y HTTP/1.0
   (This isn&apos;t a valid OAuth request, since it lacks a signature etc.)
   Note that the object &quot;x y&quot; is transmitted as x%20y.  To encode
   parameters, you can call OAuth.addToURL, OAuth.formEncode or
   OAuth.getAuthorization.

   This message object model harmonizes with the browser object model for
   input elements of an form, whose value property isn&apos;t percent encoded.
   The browser encodes each value before transmitting it. For example,
   see consumer.setInputs in example/consumer.js.
 */

/* This script needs to know what time it is. By default, it uses the local
   clock (new Date), which is apt to be inaccurate in browsers. To do
   better, you can load this script from a URL whose query string contains
   an oauth_timestamp parameter, whose value is a current Unix timestamp.
   For example, when generating the enclosing document using PHP:

   &lt;script src=&quot;oauth.js?oauth_timestamp=&lt;?=time()?&gt;&quot; ...

   Another option is to call OAuth.correctTimestamp with a Unix timestamp.
 */

var OAuth; if (OAuth == null) OAuth = {};

OAuth.setProperties = function setProperties(into, from) {
    if (into != null &amp;&amp; from != null) {
        for (var key in from) {
            into[key] = from[key];
        }
    }
    return into;
}

OAuth.setProperties(OAuth, // utility functions
{
    percentEncode: function percentEncode(s) {
        if (s == null) {
            return &quot;&quot;;
        }
        if (s instanceof Array) {
            var e = &quot;&quot;;
            for (var i = 0; i &lt; s.length; ++s) {
                if (e != &quot;&quot;) e += &apos;&amp;&apos;;
                e += OAuth.percentEncode(s[i]);
            }
            return e;
        }
        s = encodeURIComponent(s);
        // Now replace the values which encodeURIComponent doesn&apos;t do
        // encodeURIComponent ignores: - _ . ! ~ * &apos; ( )
        // OAuth dictates the only ones you can ignore are: - _ . ~
        // Source: http://developer.mozilla.org/en/docs/Core_JavaScript_1.5_Reference:Global_Functions:encodeURIComponent
        s = s.replace(/\!/g, &quot;%21&quot;);
        s = s.replace(/\*/g, &quot;%2A&quot;);
        s = s.replace(/\&apos;/g, &quot;%27&quot;);
        s = s.replace(/\(/g, &quot;%28&quot;);
        s = s.replace(/\)/g, &quot;%29&quot;);
        return s;
    }
,
    decodePercent: function decodePercent(s) {
        if (s != null) {
            // Handle application/x-www-form-urlencoded, which is defined by
            // http://www.w3.org/TR/html4/interact/forms.html#h-17.13.4.1
            s = s.replace(/\+/g, &quot; &quot;);
        }
        return decodeURIComponent(s);
    }
,
    /** Convert the given parameters to an Array of name-value pairs. */
    getParameterList: function getParameterList(parameters) {
        if (parameters == null) {
            return [];
        }
        if (typeof parameters != &quot;object&quot;) {
            return OAuth.decodeForm(parameters + &quot;&quot;);
        }
        if (parameters instanceof Array) {
            return parameters;
        }
        var list = [];
        for (var p in parameters) {
            list.push([p, parameters[p]]);
        }
        return list;
    }
,
    /** Convert the given parameters to a map from name to value. */
    getParameterMap: function getParameterMap(parameters) {
        if (parameters == null) {
            return {};
        }
        if (typeof parameters != &quot;object&quot;) {
            return OAuth.getParameterMap(OAuth.decodeForm(parameters + &quot;&quot;));
        }
        if (parameters instanceof Array) {
            var map = {};
            for (var p = 0; p &lt; parameters.length; ++p) {
                var key = parameters[p][0];
                if (map[key] === undefined) { // first value wins
                    map[key] = parameters[p][1];
                }
            }
            return map;
        }
        return parameters;
    }
,
    getParameter: function getParameter(parameters, name) {
        if (parameters instanceof Array) {
            for (var p = 0; p &lt; parameters.length; ++p) {
                if (parameters[p][0] == name) {
                    return parameters[p][1]; // first value wins
                }
            }
        } else {
            return OAuth.getParameterMap(parameters)[name];
        }
        return null;
    }
,
    formEncode: function formEncode(parameters) {
        var form = &quot;&quot;;
        var list = OAuth.getParameterList(parameters);
        for (var p = 0; p &lt; list.length; ++p) {
            var value = list[p][1];
            if (value == null) value = &quot;&quot;;
            if (form != &quot;&quot;) form += &apos;&amp;&apos;;
            form += OAuth.percentEncode(list[p][0])
              +&apos;=&apos;+ OAuth.percentEncode(value);
        }
        return form;
    }
,
    decodeForm: function decodeForm(form) {
        var list = [];
        var nvps = form.split(&apos;&amp;&apos;);
        for (var n = 0; n &lt; nvps.length; ++n) {
            var nvp = nvps[n];
            if (nvp == &quot;&quot;) {
                continue;
            }
            var equals = nvp.indexOf(&apos;=&apos;);
            var name;
            var value;
            if (equals &lt; 0) {
                name = OAuth.decodePercent(nvp);
                value = null;
            } else {
                name = OAuth.decodePercent(nvp.substring(0, equals));
                value = OAuth.decodePercent(nvp.substring(equals + 1));
            }
            list.push([name, value]);
        }
        return list;
    }
,
    setParameter: function setParameter(message, name, value) {
        var parameters = message.parameters;
        if (parameters instanceof Array) {
            for (var p = 0; p &lt; parameters.length; ++p) {
                if (parameters[p][0] == name) {
                    if (value === undefined) {
                        parameters.splice(p, 1);
                    } else {
                        parameters[p][1] = value;
                        value = undefined;
                    }
                }
            }
            if (value !== undefined) {
                parameters.push([name, value]);
            }
        } else {
            parameters = OAuth.getParameterMap(parameters);
            parameters[name] = value;
            message.parameters = parameters;
        }
    }
,
    setParameters: function setParameters(message, parameters) {
        var list = OAuth.getParameterList(parameters);
        for (var i = 0; i &lt; list.length; ++i) {
            OAuth.setParameter(message, list[i][0], list[i][1]);
        }
    }
,
    /** Fill in parameters to help construct a request message.
        This function doesn&apos;t fill in every parameter.
        The accessor object should be like:
        {consumerKey:&apos;foo&apos;, consumerSecret:&apos;bar&apos;, accessorSecret:&apos;nurn&apos;, token:&apos;krelm&apos;, tokenSecret:&apos;blah&apos;}
        The accessorSecret property is optional.
     */
    completeRequest: function completeRequest(message, accessor) {
        if (message.method == null) {
            message.method = &quot;GET&quot;;
        }
        var map = OAuth.getParameterMap(message.parameters);
        if (map.oauth_consumer_key == null) {
            OAuth.setParameter(message, &quot;oauth_consumer_key&quot;, accessor.consumerKey || &quot;&quot;);
        }
        if (map.oauth_token == null &amp;&amp; accessor.token != null) {
            OAuth.setParameter(message, &quot;oauth_token&quot;, accessor.token);
        }
        if (map.oauth_version == null) {
            OAuth.setParameter(message, &quot;oauth_version&quot;, &quot;1.0&quot;);
        }
        if (map.oauth_timestamp == null) {
            OAuth.setParameter(message, &quot;oauth_timestamp&quot;, OAuth.timestamp());
        }
        if (map.oauth_nonce == null) {
            OAuth.setParameter(message, &quot;oauth_nonce&quot;, OAuth.nonce(6));
        }
        OAuth.SignatureMethod.sign(message, accessor);
    }
,
    setTimestampAndNonce: function setTimestampAndNonce(message) {
        OAuth.setParameter(message, &quot;oauth_timestamp&quot;, OAuth.timestamp());
        OAuth.setParameter(message, &quot;oauth_nonce&quot;, OAuth.nonce(6));
    }
,
    addToURL: function addToURL(url, parameters) {
        newURL = url;
        if (parameters != null) {
            var toAdd = OAuth.formEncode(parameters);
            if (toAdd.length &gt; 0) {
                var q = url.indexOf(&apos;?&apos;);
                if (q &lt; 0) newURL += &apos;?&apos;;
                else       newURL += &apos;&amp;&apos;;
                newURL += toAdd;
            }
        }
        return newURL;
    }
,
    /** Construct the value of the Authorization header for an HTTP request. */
    getAuthorizationHeader: function getAuthorizationHeader(realm, parameters) {
        var header = &apos;OAuth realm=&quot;&apos; + OAuth.percentEncode(realm) + &apos;&quot;&apos;;
        var list = OAuth.getParameterList(parameters);
        for (var p = 0; p &lt; list.length; ++p) {
            var parameter = list[p];
            var name = parameter[0];
            if (name.indexOf(&quot;oauth_&quot;) == 0) {
                header += &apos;,&apos; + OAuth.percentEncode(name) + &apos;=&quot;&apos; + OAuth.percentEncode(parameter[1]) + &apos;&quot;&apos;;
            }
        }
        return header;
    }
,
    /** Correct the time using a parameter from the URL from which the last script was loaded. */
    correctTimestampFromSrc: function correctTimestampFromSrc(parameterName) {
        parameterName = parameterName || &quot;oauth_timestamp&quot;;
        var scripts = document.getElementsByTagName(&apos;script&apos;);
        if (scripts == null || !scripts.length) return;
        var src = scripts[scripts.length-1].src;
        if (!src) return;
        var q = src.indexOf(&quot;?&quot;);
        if (q &lt; 0) return;
        parameters = OAuth.getParameterMap(OAuth.decodeForm(src.substring(q+1)));
        var t = parameters[parameterName];
        if (t == null) return;
        OAuth.correctTimestamp(t);
    }
,
    /** Generate timestamps starting with the given value. */
    correctTimestamp: function correctTimestamp(timestamp) {
        OAuth.timeCorrectionMsec = (timestamp * 1000) - (new Date()).getTime();
    }
,
    /** The difference between the correct time and my clock. */
    timeCorrectionMsec: 0
,
    timestamp: function timestamp() {
        var t = (new Date()).getTime() + OAuth.timeCorrectionMsec;
        return Math.floor(t / 1000);
    }
,
    nonce: function nonce(length) {
        var chars = OAuth.nonce.CHARS;
        var result = &quot;&quot;;
        for (var i = 0; i &lt; length; ++i) {
            var rnum = Math.floor(Math.random() * chars.length);
            result += chars.substring(rnum, rnum+1);
        }
        return result;
    }
});

OAuth.nonce.CHARS = &quot;0123456789ABCDEFGHIJKLMNOPQRSTUVWXTZabcdefghiklmnopqrstuvwxyz&quot;;

/** Define a constructor function,
    without causing trouble to anyone who was using it as a namespace.
    That is, if parent[name] already existed and had properties,
    copy those properties into the new constructor.
 */
OAuth.declareClass = function declareClass(parent, name, newConstructor) {
    var previous = parent[name];
    parent[name] = newConstructor;
    if (newConstructor != null &amp;&amp; previous != null) {
        for (var key in previous) {
            if (key != &quot;prototype&quot;) {
                newConstructor[key] = previous[key];
            }
        }
    }
    return newConstructor;
}

/** An abstract algorithm for signing messages. */
OAuth.declareClass(OAuth, &quot;SignatureMethod&quot;, function OAuthSignatureMethod(){});

OAuth.setProperties(OAuth.SignatureMethod.prototype, // instance members
{
    /** Add a signature to the message. */
    sign: function sign(message) {
        var baseString = OAuth.SignatureMethod.getBaseString(message);
        var signature = this.getSignature(baseString);
        OAuth.setParameter(message, &quot;oauth_signature&quot;, signature);
        return signature; // just in case someone&apos;s interested
    }
,
    /** Set the key string for signing. */
    initialize: function initialize(name, accessor) {
        var consumerSecret;
        if (accessor.accessorSecret != null
            &amp;&amp; name.length &gt; 9
            &amp;&amp; name.substring(name.length-9) == &quot;-Accessor&quot;)
        {
            consumerSecret = accessor.accessorSecret;
        } else {
            consumerSecret = accessor.consumerSecret;
        }
        this.key = OAuth.percentEncode(consumerSecret)
             +&quot;&amp;&quot;+ OAuth.percentEncode(accessor.tokenSecret);
    }
});

/* SignatureMethod expects an accessor object to be like this:
   {tokenSecret: &quot;lakjsdflkj...&quot;, consumerSecret: &quot;QOUEWRI..&quot;, accessorSecret: &quot;xcmvzc...&quot;}
   The accessorSecret property is optional.
 */
// Class members:
OAuth.setProperties(OAuth.SignatureMethod, // class members
{
    sign: function sign(message, accessor) {
        var name = OAuth.getParameterMap(message.parameters).oauth_signature_method;
        if (name == null || name == &quot;&quot;) {
            name = &quot;HMAC-SHA1&quot;;
            OAuth.setParameter(message, &quot;oauth_signature_method&quot;, name);
        }
        OAuth.SignatureMethod.newMethod(name, accessor).sign(message);
    }
,
    /** Instantiate a SignatureMethod for the given method name. */
    newMethod: function newMethod(name, accessor) {
        var impl = OAuth.SignatureMethod.REGISTERED[name];
        if (impl != null) {
            var method = new impl();
            method.initialize(name, accessor);
            return method;
        }
        var err = new Error(&quot;signature_method_rejected&quot;);
        var acceptable = &quot;&quot;;
        for (var r in OAuth.SignatureMethod.REGISTERED) {
            if (acceptable != &quot;&quot;) acceptable += &apos;&amp;&apos;;
            acceptable += OAuth.percentEncode(r);
        }
        err.oauth_acceptable_signature_methods = acceptable;
        throw err;
    }
,
    /** A map from signature method name to constructor. */
    REGISTERED : {}
,
    /** Subsequently, the given constructor will be used for the named methods.
        The constructor will be called with no parameters.
        The resulting object should usually implement getSignature(baseString).
        You can easily define such a constructor by calling makeSubclass, below.
     */
    registerMethodClass: function registerMethodClass(names, classConstructor) {
        for (var n = 0; n &lt; names.length; ++n) {
            OAuth.SignatureMethod.REGISTERED[names[n]] = classConstructor;
        }
    }
,
    /** Create a subclass of OAuth.SignatureMethod, with the given getSignature function. */
    makeSubclass: function makeSubclass(getSignatureFunction) {
        var superClass = OAuth.SignatureMethod;
        var subClass = function() {
            superClass.call(this);
        };
        subClass.prototype = new superClass();
        // Delete instance variables from prototype:
        // delete subclass.prototype... There aren&apos;t any.
        subClass.prototype.getSignature = getSignatureFunction;
        subClass.prototype.constructor = subClass;
        return subClass;
    }
,
    getBaseString: function getBaseString(message) {
        var URL = message.action;
        var q = URL.indexOf(&apos;?&apos;);
        var parameters;
        if (q &lt; 0) {
            parameters = message.parameters;
        } else {
            // Combine the URL query string with the other parameters:
            parameters = OAuth.decodeForm(URL.substring(q + 1));
            var toAdd = OAuth.getParameterList(message.parameters);
            for (var a = 0; a &lt; toAdd.length; ++a) {
                parameters.push(toAdd[a]);
            }
        }
        return OAuth.percentEncode(message.method.toUpperCase())
         +&apos;&amp;&apos;+ OAuth.percentEncode(OAuth.SignatureMethod.normalizeUrl(URL))
         +&apos;&amp;&apos;+ OAuth.percentEncode(OAuth.SignatureMethod.normalizeParameters(parameters));
    }
,
    normalizeUrl: function normalizeUrl(url) {
        var uri = OAuth.SignatureMethod.parseUri(url);
        var scheme = uri.protocol.toLowerCase();
        var authority = uri.authority.toLowerCase();
        var dropPort = (scheme == &quot;http&quot; &amp;&amp; uri.port == 80)
                    || (scheme == &quot;https&quot; &amp;&amp; uri.port == 443);
        if (dropPort) {
            // find the last : in the authority
            var index = authority.lastIndexOf(&quot;:&quot;);
            if (index &gt;= 0) {
                authority = authority.substring(0, index);
            }
        }
        var path = uri.path;
        if (!path) {
            path = &quot;/&quot;; // conforms to RFC 2616 section 3.2.2
        }
        // we know that there is no query and no fragment here.
        return scheme + &quot;://&quot; + authority + path;
    }
,
    parseUri: function parseUri (str) {
        /* This function was adapted from parseUri 1.2.1
           http://stevenlevithan.com/demo/parseuri/js/assets/parseuri.js
         */
        var o = {key: [&quot;source&quot;,&quot;protocol&quot;,&quot;authority&quot;,&quot;userInfo&quot;,&quot;user&quot;,&quot;password&quot;,&quot;host&quot;,&quot;port&quot;,&quot;relative&quot;,&quot;path&quot;,&quot;directory&quot;,&quot;file&quot;,&quot;query&quot;,&quot;anchor&quot;],
                 parser: {strict: /^(?:([^:\/?#]+):)?(?:\/\/((?:(([^:@\/]*):?([^:@\/]*))?@)?([^:\/?#]*)(?::(\d*))?))?((((?:[^?#\/]*\/)*)([^?#]*))(?:\?([^#]*))?(?:#(.*))?)/ }};
        var m = o.parser.strict.exec(str);
        var uri = {};
        var i = 14;
        while (i--) uri[o.key[i]] = m[i] || &quot;&quot;;
        return uri;
    }
,
    normalizeParameters: function normalizeParameters(parameters) {
        if (parameters == null) {
            return &quot;&quot;;
        }
        var list = OAuth.getParameterList(parameters);
        var sortable = [];
        for (var p = 0; p &lt; list.length; ++p) {
            var nvp = list[p];
            if (nvp[0] != &quot;oauth_signature&quot;) {
                sortable.push([ OAuth.percentEncode(nvp[0])
                              + &quot; &quot; // because it comes before any character that can appear in a percentEncoded string.
                              + OAuth.percentEncode(nvp[1])
                              , nvp]);
            }
        }
        sortable.sort(function(a,b) {
                          if (a[0] &lt; b[0]) return  -1;
                          if (a[0] &gt; b[0]) return 1;
                          return 0;
                      });
        var sorted = [];
        for (var s = 0; s &lt; sortable.length; ++s) {
            sorted.push(sortable[s][1]);
        }
        return OAuth.formEncode(sorted);
    }
});

OAuth.SignatureMethod.registerMethodClass([&quot;PLAINTEXT&quot;, &quot;PLAINTEXT-Accessor&quot;],
    OAuth.SignatureMethod.makeSubclass(
        function getSignature(baseString) {
            return this.key;
        }
    ));

OAuth.SignatureMethod.registerMethodClass([&quot;HMAC-SHA1&quot;, &quot;HMAC-SHA1-Accessor&quot;],
    OAuth.SignatureMethod.makeSubclass(
        function getSignature(baseString) {
            b64pad = &apos;=&apos;;
            var signature = b64_hmac_sha1(this.key, baseString);
            return signature;
        }
    ));

try {
    OAuth.correctTimestampFromSrc();
} catch(e) {
}


//--------------------------------------------------

var consumerKey = &quot;${consumer_key}&quot;;
var consumerSecret = &quot;${consumer_secret}&quot;;
var params = [];
var query = [];
query.push(&apos;access_token&apos; + &apos;=&apos; + &apos;${access_token}&apos;);
query.push(&apos;id_token&apos; + &apos;=&apos; + &apos;${id_token}&apos;);
var url =  &quot;${protocol}://${misp_url}/marvelous/people/@me/@self&quot;;

if (query.length) {
    url += &apos;?&apos; + query.join(&apos;&amp;&apos;);
}

var message = {
    method: &apos;put&apos;,
    parameters: params, 
    action: url
};

log.info(url);
log.info(consumerSecret);

var accessor = {
    consumerKey: consumerKey,
    consumerSecret: consumerSecret,
    token:  &apos;${access_token}&apos;,
    tokenSecret: &apos;${id_token}&apos;
};

OAuth.completeRequest(message, accessor);
vars.put(&apos;put_auth_header&apos;, OAuth.getAuthorizationHeader(&apos;&apos;, params).replace(&apos;OAuth realm=&quot;&quot;,&apos;, &apos; OAuth &apos;));
</stringProp>
            <stringProp name="scriptLanguage">javascript</stringProp>
          </BSFPreProcessor>
          <hashTree/>
          <HeaderManager guiclass="HeaderPanel" testclass="HeaderManager" testname="HTTP ヘッダマネージャ" enabled="true">
            <collectionProp name="HeaderManager.headers">
              <elementProp name="" elementType="Header">
                <stringProp name="Header.name">Authorization</stringProp>
                <stringProp name="Header.value">${put_auth_header}</stringProp>
              </elementProp>
              <elementProp name="" elementType="Header">
                <stringProp name="Header.name">content-type</stringProp>
                <stringProp name="Header.value">application/json; charset=utf8</stringProp>
              </elementProp>
              <elementProp name="" elementType="Header">
                <stringProp name="Header.name">Connection</stringProp>
                <stringProp name="Header.value">close</stringProp>
              </elementProp>
              <elementProp name="" elementType="Header">
                <stringProp name="Header.name">Accept-encoding</stringProp>
                <stringProp name="Header.value">gzip, deflate</stringProp>
              </elementProp>
            </collectionProp>
          </HeaderManager>
          <hashTree/>
          <RegexExtractor guiclass="RegexExtractorGui" testclass="RegexExtractor" testname="access_token" enabled="true">
            <stringProp name="RegexExtractor.useHeaders">false</stringProp>
            <stringProp name="RegexExtractor.refname">access_token</stringProp>
            <stringProp name="RegexExtractor.regex">&quot;accessToken&quot;:&quot;(.*?)&quot;</stringProp>
            <stringProp name="RegexExtractor.template">$1$</stringProp>
            <stringProp name="RegexExtractor.default"></stringProp>
            <stringProp name="RegexExtractor.match_number">1</stringProp>
          </RegexExtractor>
          <hashTree/>
          <RegexExtractor guiclass="RegexExtractorGui" testclass="RegexExtractor" testname="id_token" enabled="true">
            <stringProp name="RegexExtractor.useHeaders">false</stringProp>
            <stringProp name="RegexExtractor.refname">id_token</stringProp>
            <stringProp name="RegexExtractor.regex">&quot;idToken&quot;:&quot;(.*?)&quot;</stringProp>
            <stringProp name="RegexExtractor.template">$1$</stringProp>
            <stringProp name="RegexExtractor.default"></stringProp>
            <stringProp name="RegexExtractor.match_number">1</stringProp>
          </RegexExtractor>
          <hashTree/>
          <ResponseAssertion guiclass="AssertionGui" testclass="ResponseAssertion" testname="アサーション" enabled="true">
            <collectionProp name="Asserion.test_strings">
              <stringProp name="633219952">&quot;password&quot;:&quot;awawawa&quot;</stringProp>
              <stringProp name="1203885221">&quot;username&quot;:&quot;trustedproxy_3&quot;</stringProp>
            </collectionProp>
            <stringProp name="TestPlan.comments">確認項目
パスワードが空になっていないか？</stringProp>
            <stringProp name="Assertion.test_field">Assertion.response_data</stringProp>
            <boolProp name="Assertion.assume_success">false</boolProp>
            <intProp name="Assertion.test_type">2</intProp>
          </ResponseAssertion>
          <hashTree/>
        </hashTree>
        <HTTPSamplerProxy guiclass="HttpTestSampleGui" testclass="HTTPSamplerProxy" testname="Implicit.ユーザ更新(username、password更新)" enabled="true">
          <boolProp name="HTTPSampler.postBodyRaw">true</boolProp>
          <elementProp name="HTTPsampler.Arguments" elementType="Arguments">
            <collectionProp name="Arguments.arguments">
              <elementProp name="" elementType="HTTPArgument">
                <boolProp name="HTTPArgument.always_encode">false</boolProp>
                <stringProp name="Argument.value">{&#xd;
  &quot;entry&quot;: [&#xd;
    {&#xd;
      &quot;apps&quot;: [&#xd;
        {&#xd;
          &quot;value&quot;: {&#xd;
            &quot;appId&quot;: &quot;00000&quot;,&#xd;
            &quot;userId&quot;: &quot;proxy_test_3&quot;,&#xd;
            &quot;username&quot;: &quot;proxy_user_3&quot;,&#xd;
            &quot;password&quot;: &quot;I_have_a_dream&quot;&#xd;
          }&#xd;
        }&#xd;
      ]&#xd;
    }&#xd;
  ]&#xd;
}</stringProp>
                <stringProp name="Argument.metadata">=</stringProp>
              </elementProp>
            </collectionProp>
          </elementProp>
          <stringProp name="HTTPSampler.domain"></stringProp>
          <stringProp name="HTTPSampler.port"></stringProp>
          <stringProp name="HTTPSampler.connect_timeout"></stringProp>
          <stringProp name="HTTPSampler.response_timeout"></stringProp>
          <stringProp name="HTTPSampler.protocol"></stringProp>
          <stringProp name="HTTPSampler.contentEncoding"></stringProp>
          <stringProp name="HTTPSampler.path">/marvelous/people/@me/@self?access_token=${access_token}&amp;id_token=${id_token}</stringProp>
          <stringProp name="HTTPSampler.method">PUT</stringProp>
          <boolProp name="HTTPSampler.follow_redirects">true</boolProp>
          <boolProp name="HTTPSampler.auto_redirects">false</boolProp>
          <boolProp name="HTTPSampler.use_keepalive">true</boolProp>
          <boolProp name="HTTPSampler.DO_MULTIPART_POST">false</boolProp>
          <boolProp name="HTTPSampler.monitor">false</boolProp>
          <stringProp name="HTTPSampler.embedded_url_re"></stringProp>
        </HTTPSamplerProxy>
        <hashTree>
          <BSFPreProcessor guiclass="TestBeanGUI" testclass="BSFPreProcessor" testname="BSF PreProcessor" enabled="true">
            <stringProp name="filename"></stringProp>
            <stringProp name="parameters"></stringProp>
            <stringProp name="script">/*
 * A JavaScript implementation of the Secure Hash Algorithm, SHA-1, as defined
 * in FIPS PUB 180-1
 * Version 2.1a Copyright Paul Johnston 2000 - 2002.
 * Other contributors: Greg Holt, Andrew Kepert, Ydnar, Lostinet
 * Distributed under the BSD License
 * See http://pajhome.org.uk/crypt/md5 for details.
 */

/*
 * Configurable variables. You may need to tweak these to be compatible with
 * the server-side, but the defaults work in most cases.
 */
var hexcase = 0;  /* hex output format. 0 - lowercase; 1 - uppercase        */
var b64pad  = &quot;&quot;; /* base-64 pad character. &quot;=&quot; for strict RFC compliance   */
var chrsz   = 8;  /* bits per input character. 8 - ASCII; 16 - Unicode      */

/*
 * These are the functions you&apos;ll usually want to call
 * They take string arguments and return either hex or base-64 encoded strings
 */
function hex_sha1(s){return binb2hex(core_sha1(str2binb(s),s.length * chrsz));}
function b64_sha1(s){return binb2b64(core_sha1(str2binb(s),s.length * chrsz));}
function str_sha1(s){return binb2str(core_sha1(str2binb(s),s.length * chrsz));}
function hex_hmac_sha1(key, data){ return binb2hex(core_hmac_sha1(key, data));}
function b64_hmac_sha1(key, data){ return binb2b64(core_hmac_sha1(key, data));}
function str_hmac_sha1(key, data){ return binb2str(core_hmac_sha1(key, data));}

/*
 * Perform a simple self-test to see if the VM is working
 */
function sha1_vm_test()
{
  return hex_sha1(&quot;abc&quot;) == &quot;a9993e364706816aba3e25717850c26c9cd0d89d&quot;;
}

/*
 * Calculate the SHA-1 of an array of big-endian words, and a bit length
 */
function core_sha1(x, len)
{
  /* append padding */
  x[len &gt;&gt; 5] |= 0x80 &lt;&lt; (24 - len % 32);
  x[((len + 64 &gt;&gt; 9) &lt;&lt; 4) + 15] = len;

  var w = Array(80);
  var a =  1732584193;
  var b = -271733879;
  var c = -1732584194;
  var d =  271733878;
  var e = -1009589776;

  for(var i = 0; i &lt; x.length; i += 16)
  {
    var olda = a;
    var oldb = b;
    var oldc = c;
    var oldd = d;
    var olde = e;

    for(var j = 0; j &lt; 80; j++)
    {
      if(j &lt; 16) w[j] = x[i + j];
      else w[j] = rol(w[j-3] ^ w[j-8] ^ w[j-14] ^ w[j-16], 1);
      var t = safe_add(safe_add(rol(a, 5), sha1_ft(j, b, c, d)),
                       safe_add(safe_add(e, w[j]), sha1_kt(j)));
      e = d;
      d = c;
      c = rol(b, 30);
      b = a;
      a = t;
    }

    a = safe_add(a, olda);
    b = safe_add(b, oldb);
    c = safe_add(c, oldc);
    d = safe_add(d, oldd);
    e = safe_add(e, olde);
  }
  return Array(a, b, c, d, e);

}

/*
 * Perform the appropriate triplet combination function for the current
 * iteration
 */
function sha1_ft(t, b, c, d)
{
  if(t &lt; 20) return (b &amp; c) | ((~b) &amp; d);
  if(t &lt; 40) return b ^ c ^ d;
  if(t &lt; 60) return (b &amp; c) | (b &amp; d) | (c &amp; d);
  return b ^ c ^ d;
}

/*
 * Determine the appropriate additive constant for the current iteration
 */
function sha1_kt(t)
{
  return (t &lt; 20) ?  1518500249 : (t &lt; 40) ?  1859775393 :
         (t &lt; 60) ? -1894007588 : -899497514;
}

/*
 * Calculate the HMAC-SHA1 of a key and some data
 */
function core_hmac_sha1(key, data)
{
  var bkey = str2binb(key);
  if(bkey.length &gt; 16) bkey = core_sha1(bkey, key.length * chrsz);

  var ipad = Array(16), opad = Array(16);
  for(var i = 0; i &lt; 16; i++)
  {
    ipad[i] = bkey[i] ^ 0x36363636;
    opad[i] = bkey[i] ^ 0x5C5C5C5C;
  }

  var hash = core_sha1(ipad.concat(str2binb(data)), 512 + data.length * chrsz);
  return core_sha1(opad.concat(hash), 512 + 160);
}

/*
 * Add integers, wrapping at 2^32. This uses 16-bit operations internally
 * to work around bugs in some JS interpreters.
 */
function safe_add(x, y)
{
  var lsw = (x &amp; 0xFFFF) + (y &amp; 0xFFFF);
  var msw = (x &gt;&gt; 16) + (y &gt;&gt; 16) + (lsw &gt;&gt; 16);
  return (msw &lt;&lt; 16) | (lsw &amp; 0xFFFF);
}

/*
 * Bitwise rotate a 32-bit number to the left.
 */
function rol(num, cnt)
{
  return (num &lt;&lt; cnt) | (num &gt;&gt;&gt; (32 - cnt));
}

/*
 * Convert an 8-bit or 16-bit string to an array of big-endian words
 * In 8-bit function, characters &gt;255 have their hi-byte silently ignored.
 */
function str2binb(str)
{
  var bin = Array();
  var mask = (1 &lt;&lt; chrsz) - 1;
  for(var i = 0; i &lt; str.length * chrsz; i += chrsz)
    bin[i&gt;&gt;5] |= (str.charCodeAt(i / chrsz) &amp; mask) &lt;&lt; (32 - chrsz - i%32);
  return bin;
}

/*
 * Convert an array of big-endian words to a string
 */
function binb2str(bin)
{
  var str = &quot;&quot;;
  var mask = (1 &lt;&lt; chrsz) - 1;
  for(var i = 0; i &lt; bin.length * 32; i += chrsz)
    str += String.fromCharCode((bin[i&gt;&gt;5] &gt;&gt;&gt; (32 - chrsz - i%32)) &amp; mask);
  return str;
}

/*
 * Convert an array of big-endian words to a hex string.
 */
function binb2hex(binarray)
{
  var hex_tab = hexcase ? &quot;0123456789ABCDEF&quot; : &quot;0123456789abcdef&quot;;
  var str = &quot;&quot;;
  for(var i = 0; i &lt; binarray.length * 4; i++)
  {
    str += hex_tab.charAt((binarray[i&gt;&gt;2] &gt;&gt; ((3 - i%4)*8+4)) &amp; 0xF) +
           hex_tab.charAt((binarray[i&gt;&gt;2] &gt;&gt; ((3 - i%4)*8  )) &amp; 0xF);
  }
  return str;
}

/*
 * Convert an array of big-endian words to a base-64 string
 */
function binb2b64(binarray)
{
  var tab = &quot;ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/&quot;;
  var str = &quot;&quot;;
  for(var i = 0; i &lt; binarray.length * 4; i += 3)
  {
    var triplet = (((binarray[i   &gt;&gt; 2] &gt;&gt; 8 * (3 -  i   %4)) &amp; 0xFF) &lt;&lt; 16)
                | (((binarray[i+1 &gt;&gt; 2] &gt;&gt; 8 * (3 - (i+1)%4)) &amp; 0xFF) &lt;&lt; 8 )
                |  ((binarray[i+2 &gt;&gt; 2] &gt;&gt; 8 * (3 - (i+2)%4)) &amp; 0xFF);
    for(var j = 0; j &lt; 4; j++)
    {
      if(i * 8 + j * 6 &gt; binarray.length * 32) str += b64pad;
      else str += tab.charAt((triplet &gt;&gt; 6*(3-j)) &amp; 0x3F);
    }
  }
  return str;
}

/*
 * Copyright 2008 Netflix, Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/* Here&apos;s some JavaScript software for implementing OAuth.

   This isn&apos;t as useful as you might hope.  OAuth is based around
   allowing tools and websites to talk to each other.  However,
   JavaScript running in web browsers is hampered by security
   restrictions that prevent code running on one website from
   accessing data stored or served on another.

   Before you start hacking, make sure you understand the limitations
   posed by cross-domain XMLHttpRequest.

   On the bright side, some platforms use JavaScript as their
   language, but enable the programmer to access other web sites.
   Examples include Google Gadgets, and Microsoft Vista Sidebar.
   For those platforms, this library should come in handy.
*/

// The HMAC-SHA1 signature method calls b64_hmac_sha1, defined by
// http://pajhome.org.uk/crypt/md5/sha1.js

/* An OAuth message is represented as an object like this:
   {method: &quot;GET&quot;, action: &quot;http://server.com/path&quot;, parameters: ...}

   The parameters may be either a map {name: value, name2: value2}
   or an Array of name-value pairs [[name, value], [name2, value2]].
   The latter representation is more powerful: it supports parameters
   in a specific sequence, or several parameters with the same name;
   for example [[&quot;a&quot;, 1], [&quot;b&quot;, 2], [&quot;a&quot;, 3]].

   Parameter names and values are NOT percent-encoded in an object.
   They must be encoded before transmission and decoded after reception.
   For example, this message object:
   {method: &quot;GET&quot;, action: &quot;http://server/path&quot;, parameters: {p: &quot;x y&quot;}}
   ... can be transmitted as an HTTP request that begins:
   GET /path?p=x%20y HTTP/1.0
   (This isn&apos;t a valid OAuth request, since it lacks a signature etc.)
   Note that the object &quot;x y&quot; is transmitted as x%20y.  To encode
   parameters, you can call OAuth.addToURL, OAuth.formEncode or
   OAuth.getAuthorization.

   This message object model harmonizes with the browser object model for
   input elements of an form, whose value property isn&apos;t percent encoded.
   The browser encodes each value before transmitting it. For example,
   see consumer.setInputs in example/consumer.js.
 */

/* This script needs to know what time it is. By default, it uses the local
   clock (new Date), which is apt to be inaccurate in browsers. To do
   better, you can load this script from a URL whose query string contains
   an oauth_timestamp parameter, whose value is a current Unix timestamp.
   For example, when generating the enclosing document using PHP:

   &lt;script src=&quot;oauth.js?oauth_timestamp=&lt;?=time()?&gt;&quot; ...

   Another option is to call OAuth.correctTimestamp with a Unix timestamp.
 */

var OAuth; if (OAuth == null) OAuth = {};

OAuth.setProperties = function setProperties(into, from) {
    if (into != null &amp;&amp; from != null) {
        for (var key in from) {
            into[key] = from[key];
        }
    }
    return into;
}

OAuth.setProperties(OAuth, // utility functions
{
    percentEncode: function percentEncode(s) {
        if (s == null) {
            return &quot;&quot;;
        }
        if (s instanceof Array) {
            var e = &quot;&quot;;
            for (var i = 0; i &lt; s.length; ++s) {
                if (e != &quot;&quot;) e += &apos;&amp;&apos;;
                e += OAuth.percentEncode(s[i]);
            }
            return e;
        }
        s = encodeURIComponent(s);
        // Now replace the values which encodeURIComponent doesn&apos;t do
        // encodeURIComponent ignores: - _ . ! ~ * &apos; ( )
        // OAuth dictates the only ones you can ignore are: - _ . ~
        // Source: http://developer.mozilla.org/en/docs/Core_JavaScript_1.5_Reference:Global_Functions:encodeURIComponent
        s = s.replace(/\!/g, &quot;%21&quot;);
        s = s.replace(/\*/g, &quot;%2A&quot;);
        s = s.replace(/\&apos;/g, &quot;%27&quot;);
        s = s.replace(/\(/g, &quot;%28&quot;);
        s = s.replace(/\)/g, &quot;%29&quot;);
        return s;
    }
,
    decodePercent: function decodePercent(s) {
        if (s != null) {
            // Handle application/x-www-form-urlencoded, which is defined by
            // http://www.w3.org/TR/html4/interact/forms.html#h-17.13.4.1
            s = s.replace(/\+/g, &quot; &quot;);
        }
        return decodeURIComponent(s);
    }
,
    /** Convert the given parameters to an Array of name-value pairs. */
    getParameterList: function getParameterList(parameters) {
        if (parameters == null) {
            return [];
        }
        if (typeof parameters != &quot;object&quot;) {
            return OAuth.decodeForm(parameters + &quot;&quot;);
        }
        if (parameters instanceof Array) {
            return parameters;
        }
        var list = [];
        for (var p in parameters) {
            list.push([p, parameters[p]]);
        }
        return list;
    }
,
    /** Convert the given parameters to a map from name to value. */
    getParameterMap: function getParameterMap(parameters) {
        if (parameters == null) {
            return {};
        }
        if (typeof parameters != &quot;object&quot;) {
            return OAuth.getParameterMap(OAuth.decodeForm(parameters + &quot;&quot;));
        }
        if (parameters instanceof Array) {
            var map = {};
            for (var p = 0; p &lt; parameters.length; ++p) {
                var key = parameters[p][0];
                if (map[key] === undefined) { // first value wins
                    map[key] = parameters[p][1];
                }
            }
            return map;
        }
        return parameters;
    }
,
    getParameter: function getParameter(parameters, name) {
        if (parameters instanceof Array) {
            for (var p = 0; p &lt; parameters.length; ++p) {
                if (parameters[p][0] == name) {
                    return parameters[p][1]; // first value wins
                }
            }
        } else {
            return OAuth.getParameterMap(parameters)[name];
        }
        return null;
    }
,
    formEncode: function formEncode(parameters) {
        var form = &quot;&quot;;
        var list = OAuth.getParameterList(parameters);
        for (var p = 0; p &lt; list.length; ++p) {
            var value = list[p][1];
            if (value == null) value = &quot;&quot;;
            if (form != &quot;&quot;) form += &apos;&amp;&apos;;
            form += OAuth.percentEncode(list[p][0])
              +&apos;=&apos;+ OAuth.percentEncode(value);
        }
        return form;
    }
,
    decodeForm: function decodeForm(form) {
        var list = [];
        var nvps = form.split(&apos;&amp;&apos;);
        for (var n = 0; n &lt; nvps.length; ++n) {
            var nvp = nvps[n];
            if (nvp == &quot;&quot;) {
                continue;
            }
            var equals = nvp.indexOf(&apos;=&apos;);
            var name;
            var value;
            if (equals &lt; 0) {
                name = OAuth.decodePercent(nvp);
                value = null;
            } else {
                name = OAuth.decodePercent(nvp.substring(0, equals));
                value = OAuth.decodePercent(nvp.substring(equals + 1));
            }
            list.push([name, value]);
        }
        return list;
    }
,
    setParameter: function setParameter(message, name, value) {
        var parameters = message.parameters;
        if (parameters instanceof Array) {
            for (var p = 0; p &lt; parameters.length; ++p) {
                if (parameters[p][0] == name) {
                    if (value === undefined) {
                        parameters.splice(p, 1);
                    } else {
                        parameters[p][1] = value;
                        value = undefined;
                    }
                }
            }
            if (value !== undefined) {
                parameters.push([name, value]);
            }
        } else {
            parameters = OAuth.getParameterMap(parameters);
            parameters[name] = value;
            message.parameters = parameters;
        }
    }
,
    setParameters: function setParameters(message, parameters) {
        var list = OAuth.getParameterList(parameters);
        for (var i = 0; i &lt; list.length; ++i) {
            OAuth.setParameter(message, list[i][0], list[i][1]);
        }
    }
,
    /** Fill in parameters to help construct a request message.
        This function doesn&apos;t fill in every parameter.
        The accessor object should be like:
        {consumerKey:&apos;foo&apos;, consumerSecret:&apos;bar&apos;, accessorSecret:&apos;nurn&apos;, token:&apos;krelm&apos;, tokenSecret:&apos;blah&apos;}
        The accessorSecret property is optional.
     */
    completeRequest: function completeRequest(message, accessor) {
        if (message.method == null) {
            message.method = &quot;GET&quot;;
        }
        var map = OAuth.getParameterMap(message.parameters);
        if (map.oauth_consumer_key == null) {
            OAuth.setParameter(message, &quot;oauth_consumer_key&quot;, accessor.consumerKey || &quot;&quot;);
        }
        if (map.oauth_token == null &amp;&amp; accessor.token != null) {
            OAuth.setParameter(message, &quot;oauth_token&quot;, accessor.token);
        }
        if (map.oauth_version == null) {
            OAuth.setParameter(message, &quot;oauth_version&quot;, &quot;1.0&quot;);
        }
        if (map.oauth_timestamp == null) {
            OAuth.setParameter(message, &quot;oauth_timestamp&quot;, OAuth.timestamp());
        }
        if (map.oauth_nonce == null) {
            OAuth.setParameter(message, &quot;oauth_nonce&quot;, OAuth.nonce(6));
        }
        OAuth.SignatureMethod.sign(message, accessor);
    }
,
    setTimestampAndNonce: function setTimestampAndNonce(message) {
        OAuth.setParameter(message, &quot;oauth_timestamp&quot;, OAuth.timestamp());
        OAuth.setParameter(message, &quot;oauth_nonce&quot;, OAuth.nonce(6));
    }
,
    addToURL: function addToURL(url, parameters) {
        newURL = url;
        if (parameters != null) {
            var toAdd = OAuth.formEncode(parameters);
            if (toAdd.length &gt; 0) {
                var q = url.indexOf(&apos;?&apos;);
                if (q &lt; 0) newURL += &apos;?&apos;;
                else       newURL += &apos;&amp;&apos;;
                newURL += toAdd;
            }
        }
        return newURL;
    }
,
    /** Construct the value of the Authorization header for an HTTP request. */
    getAuthorizationHeader: function getAuthorizationHeader(realm, parameters) {
        var header = &apos;OAuth realm=&quot;&apos; + OAuth.percentEncode(realm) + &apos;&quot;&apos;;
        var list = OAuth.getParameterList(parameters);
        for (var p = 0; p &lt; list.length; ++p) {
            var parameter = list[p];
            var name = parameter[0];
            if (name.indexOf(&quot;oauth_&quot;) == 0) {
                header += &apos;,&apos; + OAuth.percentEncode(name) + &apos;=&quot;&apos; + OAuth.percentEncode(parameter[1]) + &apos;&quot;&apos;;
            }
        }
        return header;
    }
,
    /** Correct the time using a parameter from the URL from which the last script was loaded. */
    correctTimestampFromSrc: function correctTimestampFromSrc(parameterName) {
        parameterName = parameterName || &quot;oauth_timestamp&quot;;
        var scripts = document.getElementsByTagName(&apos;script&apos;);
        if (scripts == null || !scripts.length) return;
        var src = scripts[scripts.length-1].src;
        if (!src) return;
        var q = src.indexOf(&quot;?&quot;);
        if (q &lt; 0) return;
        parameters = OAuth.getParameterMap(OAuth.decodeForm(src.substring(q+1)));
        var t = parameters[parameterName];
        if (t == null) return;
        OAuth.correctTimestamp(t);
    }
,
    /** Generate timestamps starting with the given value. */
    correctTimestamp: function correctTimestamp(timestamp) {
        OAuth.timeCorrectionMsec = (timestamp * 1000) - (new Date()).getTime();
    }
,
    /** The difference between the correct time and my clock. */
    timeCorrectionMsec: 0
,
    timestamp: function timestamp() {
        var t = (new Date()).getTime() + OAuth.timeCorrectionMsec;
        return Math.floor(t / 1000);
    }
,
    nonce: function nonce(length) {
        var chars = OAuth.nonce.CHARS;
        var result = &quot;&quot;;
        for (var i = 0; i &lt; length; ++i) {
            var rnum = Math.floor(Math.random() * chars.length);
            result += chars.substring(rnum, rnum+1);
        }
        return result;
    }
});

OAuth.nonce.CHARS = &quot;0123456789ABCDEFGHIJKLMNOPQRSTUVWXTZabcdefghiklmnopqrstuvwxyz&quot;;

/** Define a constructor function,
    without causing trouble to anyone who was using it as a namespace.
    That is, if parent[name] already existed and had properties,
    copy those properties into the new constructor.
 */
OAuth.declareClass = function declareClass(parent, name, newConstructor) {
    var previous = parent[name];
    parent[name] = newConstructor;
    if (newConstructor != null &amp;&amp; previous != null) {
        for (var key in previous) {
            if (key != &quot;prototype&quot;) {
                newConstructor[key] = previous[key];
            }
        }
    }
    return newConstructor;
}

/** An abstract algorithm for signing messages. */
OAuth.declareClass(OAuth, &quot;SignatureMethod&quot;, function OAuthSignatureMethod(){});

OAuth.setProperties(OAuth.SignatureMethod.prototype, // instance members
{
    /** Add a signature to the message. */
    sign: function sign(message) {
        var baseString = OAuth.SignatureMethod.getBaseString(message);
        var signature = this.getSignature(baseString);
        OAuth.setParameter(message, &quot;oauth_signature&quot;, signature);
        return signature; // just in case someone&apos;s interested
    }
,
    /** Set the key string for signing. */
    initialize: function initialize(name, accessor) {
        var consumerSecret;
        if (accessor.accessorSecret != null
            &amp;&amp; name.length &gt; 9
            &amp;&amp; name.substring(name.length-9) == &quot;-Accessor&quot;)
        {
            consumerSecret = accessor.accessorSecret;
        } else {
            consumerSecret = accessor.consumerSecret;
        }
        this.key = OAuth.percentEncode(consumerSecret)
             +&quot;&amp;&quot;+ OAuth.percentEncode(accessor.tokenSecret);
    }
});

/* SignatureMethod expects an accessor object to be like this:
   {tokenSecret: &quot;lakjsdflkj...&quot;, consumerSecret: &quot;QOUEWRI..&quot;, accessorSecret: &quot;xcmvzc...&quot;}
   The accessorSecret property is optional.
 */
// Class members:
OAuth.setProperties(OAuth.SignatureMethod, // class members
{
    sign: function sign(message, accessor) {
        var name = OAuth.getParameterMap(message.parameters).oauth_signature_method;
        if (name == null || name == &quot;&quot;) {
            name = &quot;HMAC-SHA1&quot;;
            OAuth.setParameter(message, &quot;oauth_signature_method&quot;, name);
        }
        OAuth.SignatureMethod.newMethod(name, accessor).sign(message);
    }
,
    /** Instantiate a SignatureMethod for the given method name. */
    newMethod: function newMethod(name, accessor) {
        var impl = OAuth.SignatureMethod.REGISTERED[name];
        if (impl != null) {
            var method = new impl();
            method.initialize(name, accessor);
            return method;
        }
        var err = new Error(&quot;signature_method_rejected&quot;);
        var acceptable = &quot;&quot;;
        for (var r in OAuth.SignatureMethod.REGISTERED) {
            if (acceptable != &quot;&quot;) acceptable += &apos;&amp;&apos;;
            acceptable += OAuth.percentEncode(r);
        }
        err.oauth_acceptable_signature_methods = acceptable;
        throw err;
    }
,
    /** A map from signature method name to constructor. */
    REGISTERED : {}
,
    /** Subsequently, the given constructor will be used for the named methods.
        The constructor will be called with no parameters.
        The resulting object should usually implement getSignature(baseString).
        You can easily define such a constructor by calling makeSubclass, below.
     */
    registerMethodClass: function registerMethodClass(names, classConstructor) {
        for (var n = 0; n &lt; names.length; ++n) {
            OAuth.SignatureMethod.REGISTERED[names[n]] = classConstructor;
        }
    }
,
    /** Create a subclass of OAuth.SignatureMethod, with the given getSignature function. */
    makeSubclass: function makeSubclass(getSignatureFunction) {
        var superClass = OAuth.SignatureMethod;
        var subClass = function() {
            superClass.call(this);
        };
        subClass.prototype = new superClass();
        // Delete instance variables from prototype:
        // delete subclass.prototype... There aren&apos;t any.
        subClass.prototype.getSignature = getSignatureFunction;
        subClass.prototype.constructor = subClass;
        return subClass;
    }
,
    getBaseString: function getBaseString(message) {
        var URL = message.action;
        var q = URL.indexOf(&apos;?&apos;);
        var parameters;
        if (q &lt; 0) {
            parameters = message.parameters;
        } else {
            // Combine the URL query string with the other parameters:
            parameters = OAuth.decodeForm(URL.substring(q + 1));
            var toAdd = OAuth.getParameterList(message.parameters);
            for (var a = 0; a &lt; toAdd.length; ++a) {
                parameters.push(toAdd[a]);
            }
        }
        return OAuth.percentEncode(message.method.toUpperCase())
         +&apos;&amp;&apos;+ OAuth.percentEncode(OAuth.SignatureMethod.normalizeUrl(URL))
         +&apos;&amp;&apos;+ OAuth.percentEncode(OAuth.SignatureMethod.normalizeParameters(parameters));
    }
,
    normalizeUrl: function normalizeUrl(url) {
        var uri = OAuth.SignatureMethod.parseUri(url);
        var scheme = uri.protocol.toLowerCase();
        var authority = uri.authority.toLowerCase();
        var dropPort = (scheme == &quot;http&quot; &amp;&amp; uri.port == 80)
                    || (scheme == &quot;https&quot; &amp;&amp; uri.port == 443);
        if (dropPort) {
            // find the last : in the authority
            var index = authority.lastIndexOf(&quot;:&quot;);
            if (index &gt;= 0) {
                authority = authority.substring(0, index);
            }
        }
        var path = uri.path;
        if (!path) {
            path = &quot;/&quot;; // conforms to RFC 2616 section 3.2.2
        }
        // we know that there is no query and no fragment here.
        return scheme + &quot;://&quot; + authority + path;
    }
,
    parseUri: function parseUri (str) {
        /* This function was adapted from parseUri 1.2.1
           http://stevenlevithan.com/demo/parseuri/js/assets/parseuri.js
         */
        var o = {key: [&quot;source&quot;,&quot;protocol&quot;,&quot;authority&quot;,&quot;userInfo&quot;,&quot;user&quot;,&quot;password&quot;,&quot;host&quot;,&quot;port&quot;,&quot;relative&quot;,&quot;path&quot;,&quot;directory&quot;,&quot;file&quot;,&quot;query&quot;,&quot;anchor&quot;],
                 parser: {strict: /^(?:([^:\/?#]+):)?(?:\/\/((?:(([^:@\/]*):?([^:@\/]*))?@)?([^:\/?#]*)(?::(\d*))?))?((((?:[^?#\/]*\/)*)([^?#]*))(?:\?([^#]*))?(?:#(.*))?)/ }};
        var m = o.parser.strict.exec(str);
        var uri = {};
        var i = 14;
        while (i--) uri[o.key[i]] = m[i] || &quot;&quot;;
        return uri;
    }
,
    normalizeParameters: function normalizeParameters(parameters) {
        if (parameters == null) {
            return &quot;&quot;;
        }
        var list = OAuth.getParameterList(parameters);
        var sortable = [];
        for (var p = 0; p &lt; list.length; ++p) {
            var nvp = list[p];
            if (nvp[0] != &quot;oauth_signature&quot;) {
                sortable.push([ OAuth.percentEncode(nvp[0])
                              + &quot; &quot; // because it comes before any character that can appear in a percentEncoded string.
                              + OAuth.percentEncode(nvp[1])
                              , nvp]);
            }
        }
        sortable.sort(function(a,b) {
                          if (a[0] &lt; b[0]) return  -1;
                          if (a[0] &gt; b[0]) return 1;
                          return 0;
                      });
        var sorted = [];
        for (var s = 0; s &lt; sortable.length; ++s) {
            sorted.push(sortable[s][1]);
        }
        return OAuth.formEncode(sorted);
    }
});

OAuth.SignatureMethod.registerMethodClass([&quot;PLAINTEXT&quot;, &quot;PLAINTEXT-Accessor&quot;],
    OAuth.SignatureMethod.makeSubclass(
        function getSignature(baseString) {
            return this.key;
        }
    ));

OAuth.SignatureMethod.registerMethodClass([&quot;HMAC-SHA1&quot;, &quot;HMAC-SHA1-Accessor&quot;],
    OAuth.SignatureMethod.makeSubclass(
        function getSignature(baseString) {
            b64pad = &apos;=&apos;;
            var signature = b64_hmac_sha1(this.key, baseString);
            return signature;
        }
    ));

try {
    OAuth.correctTimestampFromSrc();
} catch(e) {
}


//--------------------------------------------------

var consumerKey = &quot;${consumer_key}&quot;;
var consumerSecret = &quot;${consumer_secret}&quot;;
var params = [];
var query = [];
query.push(&apos;access_token&apos; + &apos;=&apos; + &apos;${access_token}&apos;);
query.push(&apos;id_token&apos; + &apos;=&apos; + &apos;${id_token}&apos;);
var url =  &quot;${protocol}://${misp_url}/marvelous/people/@me/@self&quot;;

if (query.length) {
    url += &apos;?&apos; + query.join(&apos;&amp;&apos;);
}

var message = {
    method: &apos;put&apos;,
    parameters: params, 
    action: url
};

log.info(url);
log.info(consumerSecret);

var accessor = {
    consumerKey: consumerKey,
    consumerSecret: consumerSecret,
    token:  &apos;${access_token}&apos;,
    tokenSecret: &apos;${id_token}&apos;
};

OAuth.completeRequest(message, accessor);
vars.put(&apos;put_auth_header&apos;, OAuth.getAuthorizationHeader(&apos;&apos;, params).replace(&apos;OAuth realm=&quot;&quot;,&apos;, &apos; OAuth &apos;));
</stringProp>
            <stringProp name="scriptLanguage">javascript</stringProp>
          </BSFPreProcessor>
          <hashTree/>
          <HeaderManager guiclass="HeaderPanel" testclass="HeaderManager" testname="HTTP ヘッダマネージャ" enabled="true">
            <collectionProp name="HeaderManager.headers">
              <elementProp name="" elementType="Header">
                <stringProp name="Header.name">Authorization</stringProp>
                <stringProp name="Header.value">${put_auth_header}</stringProp>
              </elementProp>
              <elementProp name="" elementType="Header">
                <stringProp name="Header.name">content-type</stringProp>
                <stringProp name="Header.value">application/json; charset=utf8</stringProp>
              </elementProp>
              <elementProp name="" elementType="Header">
                <stringProp name="Header.name">Connection</stringProp>
                <stringProp name="Header.value">close</stringProp>
              </elementProp>
              <elementProp name="" elementType="Header">
                <stringProp name="Header.name">Accept-encoding</stringProp>
                <stringProp name="Header.value">gzip, deflate</stringProp>
              </elementProp>
            </collectionProp>
          </HeaderManager>
          <hashTree/>
          <RegexExtractor guiclass="RegexExtractorGui" testclass="RegexExtractor" testname="access_token" enabled="true">
            <stringProp name="RegexExtractor.useHeaders">false</stringProp>
            <stringProp name="RegexExtractor.refname">access_token</stringProp>
            <stringProp name="RegexExtractor.regex">&quot;accessToken&quot;:&quot;(.*?)&quot;</stringProp>
            <stringProp name="RegexExtractor.template">$1$</stringProp>
            <stringProp name="RegexExtractor.default"></stringProp>
            <stringProp name="RegexExtractor.match_number">1</stringProp>
          </RegexExtractor>
          <hashTree/>
          <RegexExtractor guiclass="RegexExtractorGui" testclass="RegexExtractor" testname="id_token" enabled="true">
            <stringProp name="RegexExtractor.useHeaders">false</stringProp>
            <stringProp name="RegexExtractor.refname">id_token</stringProp>
            <stringProp name="RegexExtractor.regex">&quot;idToken&quot;:&quot;(.*?)&quot;</stringProp>
            <stringProp name="RegexExtractor.template">$1$</stringProp>
            <stringProp name="RegexExtractor.default"></stringProp>
            <stringProp name="RegexExtractor.match_number">1</stringProp>
          </RegexExtractor>
          <hashTree/>
          <ResponseAssertion guiclass="AssertionGui" testclass="ResponseAssertion" testname="アサーション" enabled="true">
            <collectionProp name="Asserion.test_strings">
              <stringProp name="2033562336">&quot;username&quot;:&quot;proxy_user_3&quot;</stringProp>
              <stringProp name="-729315055">&quot;password&quot;:&quot;I_have_a_dream&quot;</stringProp>
            </collectionProp>
            <stringProp name="TestPlan.comments">確認項目
1.usernameが更新されているか
2.passwordが更新されているか</stringProp>
            <stringProp name="Assertion.test_field">Assertion.response_data</stringProp>
            <boolProp name="Assertion.assume_success">false</boolProp>
            <intProp name="Assertion.test_type">2</intProp>
          </ResponseAssertion>
          <hashTree/>
        </hashTree>
        <HTTPSamplerProxy guiclass="HttpTestSampleGui" testclass="HTTPSamplerProxy" testname="Implicit.ユーザ更新(変更なし)" enabled="true">
          <boolProp name="HTTPSampler.postBodyRaw">true</boolProp>
          <elementProp name="HTTPsampler.Arguments" elementType="Arguments">
            <collectionProp name="Arguments.arguments">
              <elementProp name="" elementType="HTTPArgument">
                <boolProp name="HTTPArgument.always_encode">false</boolProp>
                <stringProp name="Argument.value">{&#xd;
  &quot;entry&quot;: [&#xd;
    {&#xd;
      &quot;apps&quot;: [&#xd;
        {&#xd;
          &quot;value&quot;: {&#xd;
            &quot;appId&quot;: &quot;00000&quot;,&#xd;
            &quot;userId&quot;: &quot;proxy_test_3&quot;&#xd;
          }&#xd;
        }&#xd;
      ]&#xd;
    }&#xd;
  ]&#xd;
}</stringProp>
                <stringProp name="Argument.metadata">=</stringProp>
              </elementProp>
            </collectionProp>
          </elementProp>
          <stringProp name="HTTPSampler.domain"></stringProp>
          <stringProp name="HTTPSampler.port"></stringProp>
          <stringProp name="HTTPSampler.connect_timeout"></stringProp>
          <stringProp name="HTTPSampler.response_timeout"></stringProp>
          <stringProp name="HTTPSampler.protocol"></stringProp>
          <stringProp name="HTTPSampler.contentEncoding"></stringProp>
          <stringProp name="HTTPSampler.path">/marvelous/people/@me/@self?access_token=${access_token}&amp;id_token=${id_token}</stringProp>
          <stringProp name="HTTPSampler.method">PUT</stringProp>
          <boolProp name="HTTPSampler.follow_redirects">true</boolProp>
          <boolProp name="HTTPSampler.auto_redirects">false</boolProp>
          <boolProp name="HTTPSampler.use_keepalive">true</boolProp>
          <boolProp name="HTTPSampler.DO_MULTIPART_POST">false</boolProp>
          <boolProp name="HTTPSampler.monitor">false</boolProp>
          <stringProp name="HTTPSampler.embedded_url_re"></stringProp>
        </HTTPSamplerProxy>
        <hashTree>
          <BSFPreProcessor guiclass="TestBeanGUI" testclass="BSFPreProcessor" testname="BSF PreProcessor" enabled="true">
            <stringProp name="filename"></stringProp>
            <stringProp name="parameters"></stringProp>
            <stringProp name="script">/*
 * A JavaScript implementation of the Secure Hash Algorithm, SHA-1, as defined
 * in FIPS PUB 180-1
 * Version 2.1a Copyright Paul Johnston 2000 - 2002.
 * Other contributors: Greg Holt, Andrew Kepert, Ydnar, Lostinet
 * Distributed under the BSD License
 * See http://pajhome.org.uk/crypt/md5 for details.
 */

/*
 * Configurable variables. You may need to tweak these to be compatible with
 * the server-side, but the defaults work in most cases.
 */
var hexcase = 0;  /* hex output format. 0 - lowercase; 1 - uppercase        */
var b64pad  = &quot;&quot;; /* base-64 pad character. &quot;=&quot; for strict RFC compliance   */
var chrsz   = 8;  /* bits per input character. 8 - ASCII; 16 - Unicode      */

/*
 * These are the functions you&apos;ll usually want to call
 * They take string arguments and return either hex or base-64 encoded strings
 */
function hex_sha1(s){return binb2hex(core_sha1(str2binb(s),s.length * chrsz));}
function b64_sha1(s){return binb2b64(core_sha1(str2binb(s),s.length * chrsz));}
function str_sha1(s){return binb2str(core_sha1(str2binb(s),s.length * chrsz));}
function hex_hmac_sha1(key, data){ return binb2hex(core_hmac_sha1(key, data));}
function b64_hmac_sha1(key, data){ return binb2b64(core_hmac_sha1(key, data));}
function str_hmac_sha1(key, data){ return binb2str(core_hmac_sha1(key, data));}

/*
 * Perform a simple self-test to see if the VM is working
 */
function sha1_vm_test()
{
  return hex_sha1(&quot;abc&quot;) == &quot;a9993e364706816aba3e25717850c26c9cd0d89d&quot;;
}

/*
 * Calculate the SHA-1 of an array of big-endian words, and a bit length
 */
function core_sha1(x, len)
{
  /* append padding */
  x[len &gt;&gt; 5] |= 0x80 &lt;&lt; (24 - len % 32);
  x[((len + 64 &gt;&gt; 9) &lt;&lt; 4) + 15] = len;

  var w = Array(80);
  var a =  1732584193;
  var b = -271733879;
  var c = -1732584194;
  var d =  271733878;
  var e = -1009589776;

  for(var i = 0; i &lt; x.length; i += 16)
  {
    var olda = a;
    var oldb = b;
    var oldc = c;
    var oldd = d;
    var olde = e;

    for(var j = 0; j &lt; 80; j++)
    {
      if(j &lt; 16) w[j] = x[i + j];
      else w[j] = rol(w[j-3] ^ w[j-8] ^ w[j-14] ^ w[j-16], 1);
      var t = safe_add(safe_add(rol(a, 5), sha1_ft(j, b, c, d)),
                       safe_add(safe_add(e, w[j]), sha1_kt(j)));
      e = d;
      d = c;
      c = rol(b, 30);
      b = a;
      a = t;
    }

    a = safe_add(a, olda);
    b = safe_add(b, oldb);
    c = safe_add(c, oldc);
    d = safe_add(d, oldd);
    e = safe_add(e, olde);
  }
  return Array(a, b, c, d, e);

}

/*
 * Perform the appropriate triplet combination function for the current
 * iteration
 */
function sha1_ft(t, b, c, d)
{
  if(t &lt; 20) return (b &amp; c) | ((~b) &amp; d);
  if(t &lt; 40) return b ^ c ^ d;
  if(t &lt; 60) return (b &amp; c) | (b &amp; d) | (c &amp; d);
  return b ^ c ^ d;
}

/*
 * Determine the appropriate additive constant for the current iteration
 */
function sha1_kt(t)
{
  return (t &lt; 20) ?  1518500249 : (t &lt; 40) ?  1859775393 :
         (t &lt; 60) ? -1894007588 : -899497514;
}

/*
 * Calculate the HMAC-SHA1 of a key and some data
 */
function core_hmac_sha1(key, data)
{
  var bkey = str2binb(key);
  if(bkey.length &gt; 16) bkey = core_sha1(bkey, key.length * chrsz);

  var ipad = Array(16), opad = Array(16);
  for(var i = 0; i &lt; 16; i++)
  {
    ipad[i] = bkey[i] ^ 0x36363636;
    opad[i] = bkey[i] ^ 0x5C5C5C5C;
  }

  var hash = core_sha1(ipad.concat(str2binb(data)), 512 + data.length * chrsz);
  return core_sha1(opad.concat(hash), 512 + 160);
}

/*
 * Add integers, wrapping at 2^32. This uses 16-bit operations internally
 * to work around bugs in some JS interpreters.
 */
function safe_add(x, y)
{
  var lsw = (x &amp; 0xFFFF) + (y &amp; 0xFFFF);
  var msw = (x &gt;&gt; 16) + (y &gt;&gt; 16) + (lsw &gt;&gt; 16);
  return (msw &lt;&lt; 16) | (lsw &amp; 0xFFFF);
}

/*
 * Bitwise rotate a 32-bit number to the left.
 */
function rol(num, cnt)
{
  return (num &lt;&lt; cnt) | (num &gt;&gt;&gt; (32 - cnt));
}

/*
 * Convert an 8-bit or 16-bit string to an array of big-endian words
 * In 8-bit function, characters &gt;255 have their hi-byte silently ignored.
 */
function str2binb(str)
{
  var bin = Array();
  var mask = (1 &lt;&lt; chrsz) - 1;
  for(var i = 0; i &lt; str.length * chrsz; i += chrsz)
    bin[i&gt;&gt;5] |= (str.charCodeAt(i / chrsz) &amp; mask) &lt;&lt; (32 - chrsz - i%32);
  return bin;
}

/*
 * Convert an array of big-endian words to a string
 */
function binb2str(bin)
{
  var str = &quot;&quot;;
  var mask = (1 &lt;&lt; chrsz) - 1;
  for(var i = 0; i &lt; bin.length * 32; i += chrsz)
    str += String.fromCharCode((bin[i&gt;&gt;5] &gt;&gt;&gt; (32 - chrsz - i%32)) &amp; mask);
  return str;
}

/*
 * Convert an array of big-endian words to a hex string.
 */
function binb2hex(binarray)
{
  var hex_tab = hexcase ? &quot;0123456789ABCDEF&quot; : &quot;0123456789abcdef&quot;;
  var str = &quot;&quot;;
  for(var i = 0; i &lt; binarray.length * 4; i++)
  {
    str += hex_tab.charAt((binarray[i&gt;&gt;2] &gt;&gt; ((3 - i%4)*8+4)) &amp; 0xF) +
           hex_tab.charAt((binarray[i&gt;&gt;2] &gt;&gt; ((3 - i%4)*8  )) &amp; 0xF);
  }
  return str;
}

/*
 * Convert an array of big-endian words to a base-64 string
 */
function binb2b64(binarray)
{
  var tab = &quot;ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/&quot;;
  var str = &quot;&quot;;
  for(var i = 0; i &lt; binarray.length * 4; i += 3)
  {
    var triplet = (((binarray[i   &gt;&gt; 2] &gt;&gt; 8 * (3 -  i   %4)) &amp; 0xFF) &lt;&lt; 16)
                | (((binarray[i+1 &gt;&gt; 2] &gt;&gt; 8 * (3 - (i+1)%4)) &amp; 0xFF) &lt;&lt; 8 )
                |  ((binarray[i+2 &gt;&gt; 2] &gt;&gt; 8 * (3 - (i+2)%4)) &amp; 0xFF);
    for(var j = 0; j &lt; 4; j++)
    {
      if(i * 8 + j * 6 &gt; binarray.length * 32) str += b64pad;
      else str += tab.charAt((triplet &gt;&gt; 6*(3-j)) &amp; 0x3F);
    }
  }
  return str;
}

/*
 * Copyright 2008 Netflix, Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/* Here&apos;s some JavaScript software for implementing OAuth.

   This isn&apos;t as useful as you might hope.  OAuth is based around
   allowing tools and websites to talk to each other.  However,
   JavaScript running in web browsers is hampered by security
   restrictions that prevent code running on one website from
   accessing data stored or served on another.

   Before you start hacking, make sure you understand the limitations
   posed by cross-domain XMLHttpRequest.

   On the bright side, some platforms use JavaScript as their
   language, but enable the programmer to access other web sites.
   Examples include Google Gadgets, and Microsoft Vista Sidebar.
   For those platforms, this library should come in handy.
*/

// The HMAC-SHA1 signature method calls b64_hmac_sha1, defined by
// http://pajhome.org.uk/crypt/md5/sha1.js

/* An OAuth message is represented as an object like this:
   {method: &quot;GET&quot;, action: &quot;http://server.com/path&quot;, parameters: ...}

   The parameters may be either a map {name: value, name2: value2}
   or an Array of name-value pairs [[name, value], [name2, value2]].
   The latter representation is more powerful: it supports parameters
   in a specific sequence, or several parameters with the same name;
   for example [[&quot;a&quot;, 1], [&quot;b&quot;, 2], [&quot;a&quot;, 3]].

   Parameter names and values are NOT percent-encoded in an object.
   They must be encoded before transmission and decoded after reception.
   For example, this message object:
   {method: &quot;GET&quot;, action: &quot;http://server/path&quot;, parameters: {p: &quot;x y&quot;}}
   ... can be transmitted as an HTTP request that begins:
   GET /path?p=x%20y HTTP/1.0
   (This isn&apos;t a valid OAuth request, since it lacks a signature etc.)
   Note that the object &quot;x y&quot; is transmitted as x%20y.  To encode
   parameters, you can call OAuth.addToURL, OAuth.formEncode or
   OAuth.getAuthorization.

   This message object model harmonizes with the browser object model for
   input elements of an form, whose value property isn&apos;t percent encoded.
   The browser encodes each value before transmitting it. For example,
   see consumer.setInputs in example/consumer.js.
 */

/* This script needs to know what time it is. By default, it uses the local
   clock (new Date), which is apt to be inaccurate in browsers. To do
   better, you can load this script from a URL whose query string contains
   an oauth_timestamp parameter, whose value is a current Unix timestamp.
   For example, when generating the enclosing document using PHP:

   &lt;script src=&quot;oauth.js?oauth_timestamp=&lt;?=time()?&gt;&quot; ...

   Another option is to call OAuth.correctTimestamp with a Unix timestamp.
 */

var OAuth; if (OAuth == null) OAuth = {};

OAuth.setProperties = function setProperties(into, from) {
    if (into != null &amp;&amp; from != null) {
        for (var key in from) {
            into[key] = from[key];
        }
    }
    return into;
}

OAuth.setProperties(OAuth, // utility functions
{
    percentEncode: function percentEncode(s) {
        if (s == null) {
            return &quot;&quot;;
        }
        if (s instanceof Array) {
            var e = &quot;&quot;;
            for (var i = 0; i &lt; s.length; ++s) {
                if (e != &quot;&quot;) e += &apos;&amp;&apos;;
                e += OAuth.percentEncode(s[i]);
            }
            return e;
        }
        s = encodeURIComponent(s);
        // Now replace the values which encodeURIComponent doesn&apos;t do
        // encodeURIComponent ignores: - _ . ! ~ * &apos; ( )
        // OAuth dictates the only ones you can ignore are: - _ . ~
        // Source: http://developer.mozilla.org/en/docs/Core_JavaScript_1.5_Reference:Global_Functions:encodeURIComponent
        s = s.replace(/\!/g, &quot;%21&quot;);
        s = s.replace(/\*/g, &quot;%2A&quot;);
        s = s.replace(/\&apos;/g, &quot;%27&quot;);
        s = s.replace(/\(/g, &quot;%28&quot;);
        s = s.replace(/\)/g, &quot;%29&quot;);
        return s;
    }
,
    decodePercent: function decodePercent(s) {
        if (s != null) {
            // Handle application/x-www-form-urlencoded, which is defined by
            // http://www.w3.org/TR/html4/interact/forms.html#h-17.13.4.1
            s = s.replace(/\+/g, &quot; &quot;);
        }
        return decodeURIComponent(s);
    }
,
    /** Convert the given parameters to an Array of name-value pairs. */
    getParameterList: function getParameterList(parameters) {
        if (parameters == null) {
            return [];
        }
        if (typeof parameters != &quot;object&quot;) {
            return OAuth.decodeForm(parameters + &quot;&quot;);
        }
        if (parameters instanceof Array) {
            return parameters;
        }
        var list = [];
        for (var p in parameters) {
            list.push([p, parameters[p]]);
        }
        return list;
    }
,
    /** Convert the given parameters to a map from name to value. */
    getParameterMap: function getParameterMap(parameters) {
        if (parameters == null) {
            return {};
        }
        if (typeof parameters != &quot;object&quot;) {
            return OAuth.getParameterMap(OAuth.decodeForm(parameters + &quot;&quot;));
        }
        if (parameters instanceof Array) {
            var map = {};
            for (var p = 0; p &lt; parameters.length; ++p) {
                var key = parameters[p][0];
                if (map[key] === undefined) { // first value wins
                    map[key] = parameters[p][1];
                }
            }
            return map;
        }
        return parameters;
    }
,
    getParameter: function getParameter(parameters, name) {
        if (parameters instanceof Array) {
            for (var p = 0; p &lt; parameters.length; ++p) {
                if (parameters[p][0] == name) {
                    return parameters[p][1]; // first value wins
                }
            }
        } else {
            return OAuth.getParameterMap(parameters)[name];
        }
        return null;
    }
,
    formEncode: function formEncode(parameters) {
        var form = &quot;&quot;;
        var list = OAuth.getParameterList(parameters);
        for (var p = 0; p &lt; list.length; ++p) {
            var value = list[p][1];
            if (value == null) value = &quot;&quot;;
            if (form != &quot;&quot;) form += &apos;&amp;&apos;;
            form += OAuth.percentEncode(list[p][0])
              +&apos;=&apos;+ OAuth.percentEncode(value);
        }
        return form;
    }
,
    decodeForm: function decodeForm(form) {
        var list = [];
        var nvps = form.split(&apos;&amp;&apos;);
        for (var n = 0; n &lt; nvps.length; ++n) {
            var nvp = nvps[n];
            if (nvp == &quot;&quot;) {
                continue;
            }
            var equals = nvp.indexOf(&apos;=&apos;);
            var name;
            var value;
            if (equals &lt; 0) {
                name = OAuth.decodePercent(nvp);
                value = null;
            } else {
                name = OAuth.decodePercent(nvp.substring(0, equals));
                value = OAuth.decodePercent(nvp.substring(equals + 1));
            }
            list.push([name, value]);
        }
        return list;
    }
,
    setParameter: function setParameter(message, name, value) {
        var parameters = message.parameters;
        if (parameters instanceof Array) {
            for (var p = 0; p &lt; parameters.length; ++p) {
                if (parameters[p][0] == name) {
                    if (value === undefined) {
                        parameters.splice(p, 1);
                    } else {
                        parameters[p][1] = value;
                        value = undefined;
                    }
                }
            }
            if (value !== undefined) {
                parameters.push([name, value]);
            }
        } else {
            parameters = OAuth.getParameterMap(parameters);
            parameters[name] = value;
            message.parameters = parameters;
        }
    }
,
    setParameters: function setParameters(message, parameters) {
        var list = OAuth.getParameterList(parameters);
        for (var i = 0; i &lt; list.length; ++i) {
            OAuth.setParameter(message, list[i][0], list[i][1]);
        }
    }
,
    /** Fill in parameters to help construct a request message.
        This function doesn&apos;t fill in every parameter.
        The accessor object should be like:
        {consumerKey:&apos;foo&apos;, consumerSecret:&apos;bar&apos;, accessorSecret:&apos;nurn&apos;, token:&apos;krelm&apos;, tokenSecret:&apos;blah&apos;}
        The accessorSecret property is optional.
     */
    completeRequest: function completeRequest(message, accessor) {
        if (message.method == null) {
            message.method = &quot;GET&quot;;
        }
        var map = OAuth.getParameterMap(message.parameters);
        if (map.oauth_consumer_key == null) {
            OAuth.setParameter(message, &quot;oauth_consumer_key&quot;, accessor.consumerKey || &quot;&quot;);
        }
        if (map.oauth_token == null &amp;&amp; accessor.token != null) {
            OAuth.setParameter(message, &quot;oauth_token&quot;, accessor.token);
        }
        if (map.oauth_version == null) {
            OAuth.setParameter(message, &quot;oauth_version&quot;, &quot;1.0&quot;);
        }
        if (map.oauth_timestamp == null) {
            OAuth.setParameter(message, &quot;oauth_timestamp&quot;, OAuth.timestamp());
        }
        if (map.oauth_nonce == null) {
            OAuth.setParameter(message, &quot;oauth_nonce&quot;, OAuth.nonce(6));
        }
        OAuth.SignatureMethod.sign(message, accessor);
    }
,
    setTimestampAndNonce: function setTimestampAndNonce(message) {
        OAuth.setParameter(message, &quot;oauth_timestamp&quot;, OAuth.timestamp());
        OAuth.setParameter(message, &quot;oauth_nonce&quot;, OAuth.nonce(6));
    }
,
    addToURL: function addToURL(url, parameters) {
        newURL = url;
        if (parameters != null) {
            var toAdd = OAuth.formEncode(parameters);
            if (toAdd.length &gt; 0) {
                var q = url.indexOf(&apos;?&apos;);
                if (q &lt; 0) newURL += &apos;?&apos;;
                else       newURL += &apos;&amp;&apos;;
                newURL += toAdd;
            }
        }
        return newURL;
    }
,
    /** Construct the value of the Authorization header for an HTTP request. */
    getAuthorizationHeader: function getAuthorizationHeader(realm, parameters) {
        var header = &apos;OAuth realm=&quot;&apos; + OAuth.percentEncode(realm) + &apos;&quot;&apos;;
        var list = OAuth.getParameterList(parameters);
        for (var p = 0; p &lt; list.length; ++p) {
            var parameter = list[p];
            var name = parameter[0];
            if (name.indexOf(&quot;oauth_&quot;) == 0) {
                header += &apos;,&apos; + OAuth.percentEncode(name) + &apos;=&quot;&apos; + OAuth.percentEncode(parameter[1]) + &apos;&quot;&apos;;
            }
        }
        return header;
    }
,
    /** Correct the time using a parameter from the URL from which the last script was loaded. */
    correctTimestampFromSrc: function correctTimestampFromSrc(parameterName) {
        parameterName = parameterName || &quot;oauth_timestamp&quot;;
        var scripts = document.getElementsByTagName(&apos;script&apos;);
        if (scripts == null || !scripts.length) return;
        var src = scripts[scripts.length-1].src;
        if (!src) return;
        var q = src.indexOf(&quot;?&quot;);
        if (q &lt; 0) return;
        parameters = OAuth.getParameterMap(OAuth.decodeForm(src.substring(q+1)));
        var t = parameters[parameterName];
        if (t == null) return;
        OAuth.correctTimestamp(t);
    }
,
    /** Generate timestamps starting with the given value. */
    correctTimestamp: function correctTimestamp(timestamp) {
        OAuth.timeCorrectionMsec = (timestamp * 1000) - (new Date()).getTime();
    }
,
    /** The difference between the correct time and my clock. */
    timeCorrectionMsec: 0
,
    timestamp: function timestamp() {
        var t = (new Date()).getTime() + OAuth.timeCorrectionMsec;
        return Math.floor(t / 1000);
    }
,
    nonce: function nonce(length) {
        var chars = OAuth.nonce.CHARS;
        var result = &quot;&quot;;
        for (var i = 0; i &lt; length; ++i) {
            var rnum = Math.floor(Math.random() * chars.length);
            result += chars.substring(rnum, rnum+1);
        }
        return result;
    }
});

OAuth.nonce.CHARS = &quot;0123456789ABCDEFGHIJKLMNOPQRSTUVWXTZabcdefghiklmnopqrstuvwxyz&quot;;

/** Define a constructor function,
    without causing trouble to anyone who was using it as a namespace.
    That is, if parent[name] already existed and had properties,
    copy those properties into the new constructor.
 */
OAuth.declareClass = function declareClass(parent, name, newConstructor) {
    var previous = parent[name];
    parent[name] = newConstructor;
    if (newConstructor != null &amp;&amp; previous != null) {
        for (var key in previous) {
            if (key != &quot;prototype&quot;) {
                newConstructor[key] = previous[key];
            }
        }
    }
    return newConstructor;
}

/** An abstract algorithm for signing messages. */
OAuth.declareClass(OAuth, &quot;SignatureMethod&quot;, function OAuthSignatureMethod(){});

OAuth.setProperties(OAuth.SignatureMethod.prototype, // instance members
{
    /** Add a signature to the message. */
    sign: function sign(message) {
        var baseString = OAuth.SignatureMethod.getBaseString(message);
        var signature = this.getSignature(baseString);
        OAuth.setParameter(message, &quot;oauth_signature&quot;, signature);
        return signature; // just in case someone&apos;s interested
    }
,
    /** Set the key string for signing. */
    initialize: function initialize(name, accessor) {
        var consumerSecret;
        if (accessor.accessorSecret != null
            &amp;&amp; name.length &gt; 9
            &amp;&amp; name.substring(name.length-9) == &quot;-Accessor&quot;)
        {
            consumerSecret = accessor.accessorSecret;
        } else {
            consumerSecret = accessor.consumerSecret;
        }
        this.key = OAuth.percentEncode(consumerSecret)
             +&quot;&amp;&quot;+ OAuth.percentEncode(accessor.tokenSecret);
    }
});

/* SignatureMethod expects an accessor object to be like this:
   {tokenSecret: &quot;lakjsdflkj...&quot;, consumerSecret: &quot;QOUEWRI..&quot;, accessorSecret: &quot;xcmvzc...&quot;}
   The accessorSecret property is optional.
 */
// Class members:
OAuth.setProperties(OAuth.SignatureMethod, // class members
{
    sign: function sign(message, accessor) {
        var name = OAuth.getParameterMap(message.parameters).oauth_signature_method;
        if (name == null || name == &quot;&quot;) {
            name = &quot;HMAC-SHA1&quot;;
            OAuth.setParameter(message, &quot;oauth_signature_method&quot;, name);
        }
        OAuth.SignatureMethod.newMethod(name, accessor).sign(message);
    }
,
    /** Instantiate a SignatureMethod for the given method name. */
    newMethod: function newMethod(name, accessor) {
        var impl = OAuth.SignatureMethod.REGISTERED[name];
        if (impl != null) {
            var method = new impl();
            method.initialize(name, accessor);
            return method;
        }
        var err = new Error(&quot;signature_method_rejected&quot;);
        var acceptable = &quot;&quot;;
        for (var r in OAuth.SignatureMethod.REGISTERED) {
            if (acceptable != &quot;&quot;) acceptable += &apos;&amp;&apos;;
            acceptable += OAuth.percentEncode(r);
        }
        err.oauth_acceptable_signature_methods = acceptable;
        throw err;
    }
,
    /** A map from signature method name to constructor. */
    REGISTERED : {}
,
    /** Subsequently, the given constructor will be used for the named methods.
        The constructor will be called with no parameters.
        The resulting object should usually implement getSignature(baseString).
        You can easily define such a constructor by calling makeSubclass, below.
     */
    registerMethodClass: function registerMethodClass(names, classConstructor) {
        for (var n = 0; n &lt; names.length; ++n) {
            OAuth.SignatureMethod.REGISTERED[names[n]] = classConstructor;
        }
    }
,
    /** Create a subclass of OAuth.SignatureMethod, with the given getSignature function. */
    makeSubclass: function makeSubclass(getSignatureFunction) {
        var superClass = OAuth.SignatureMethod;
        var subClass = function() {
            superClass.call(this);
        };
        subClass.prototype = new superClass();
        // Delete instance variables from prototype:
        // delete subclass.prototype... There aren&apos;t any.
        subClass.prototype.getSignature = getSignatureFunction;
        subClass.prototype.constructor = subClass;
        return subClass;
    }
,
    getBaseString: function getBaseString(message) {
        var URL = message.action;
        var q = URL.indexOf(&apos;?&apos;);
        var parameters;
        if (q &lt; 0) {
            parameters = message.parameters;
        } else {
            // Combine the URL query string with the other parameters:
            parameters = OAuth.decodeForm(URL.substring(q + 1));
            var toAdd = OAuth.getParameterList(message.parameters);
            for (var a = 0; a &lt; toAdd.length; ++a) {
                parameters.push(toAdd[a]);
            }
        }
        return OAuth.percentEncode(message.method.toUpperCase())
         +&apos;&amp;&apos;+ OAuth.percentEncode(OAuth.SignatureMethod.normalizeUrl(URL))
         +&apos;&amp;&apos;+ OAuth.percentEncode(OAuth.SignatureMethod.normalizeParameters(parameters));
    }
,
    normalizeUrl: function normalizeUrl(url) {
        var uri = OAuth.SignatureMethod.parseUri(url);
        var scheme = uri.protocol.toLowerCase();
        var authority = uri.authority.toLowerCase();
        var dropPort = (scheme == &quot;http&quot; &amp;&amp; uri.port == 80)
                    || (scheme == &quot;https&quot; &amp;&amp; uri.port == 443);
        if (dropPort) {
            // find the last : in the authority
            var index = authority.lastIndexOf(&quot;:&quot;);
            if (index &gt;= 0) {
                authority = authority.substring(0, index);
            }
        }
        var path = uri.path;
        if (!path) {
            path = &quot;/&quot;; // conforms to RFC 2616 section 3.2.2
        }
        // we know that there is no query and no fragment here.
        return scheme + &quot;://&quot; + authority + path;
    }
,
    parseUri: function parseUri (str) {
        /* This function was adapted from parseUri 1.2.1
           http://stevenlevithan.com/demo/parseuri/js/assets/parseuri.js
         */
        var o = {key: [&quot;source&quot;,&quot;protocol&quot;,&quot;authority&quot;,&quot;userInfo&quot;,&quot;user&quot;,&quot;password&quot;,&quot;host&quot;,&quot;port&quot;,&quot;relative&quot;,&quot;path&quot;,&quot;directory&quot;,&quot;file&quot;,&quot;query&quot;,&quot;anchor&quot;],
                 parser: {strict: /^(?:([^:\/?#]+):)?(?:\/\/((?:(([^:@\/]*):?([^:@\/]*))?@)?([^:\/?#]*)(?::(\d*))?))?((((?:[^?#\/]*\/)*)([^?#]*))(?:\?([^#]*))?(?:#(.*))?)/ }};
        var m = o.parser.strict.exec(str);
        var uri = {};
        var i = 14;
        while (i--) uri[o.key[i]] = m[i] || &quot;&quot;;
        return uri;
    }
,
    normalizeParameters: function normalizeParameters(parameters) {
        if (parameters == null) {
            return &quot;&quot;;
        }
        var list = OAuth.getParameterList(parameters);
        var sortable = [];
        for (var p = 0; p &lt; list.length; ++p) {
            var nvp = list[p];
            if (nvp[0] != &quot;oauth_signature&quot;) {
                sortable.push([ OAuth.percentEncode(nvp[0])
                              + &quot; &quot; // because it comes before any character that can appear in a percentEncoded string.
                              + OAuth.percentEncode(nvp[1])
                              , nvp]);
            }
        }
        sortable.sort(function(a,b) {
                          if (a[0] &lt; b[0]) return  -1;
                          if (a[0] &gt; b[0]) return 1;
                          return 0;
                      });
        var sorted = [];
        for (var s = 0; s &lt; sortable.length; ++s) {
            sorted.push(sortable[s][1]);
        }
        return OAuth.formEncode(sorted);
    }
});

OAuth.SignatureMethod.registerMethodClass([&quot;PLAINTEXT&quot;, &quot;PLAINTEXT-Accessor&quot;],
    OAuth.SignatureMethod.makeSubclass(
        function getSignature(baseString) {
            return this.key;
        }
    ));

OAuth.SignatureMethod.registerMethodClass([&quot;HMAC-SHA1&quot;, &quot;HMAC-SHA1-Accessor&quot;],
    OAuth.SignatureMethod.makeSubclass(
        function getSignature(baseString) {
            b64pad = &apos;=&apos;;
            var signature = b64_hmac_sha1(this.key, baseString);
            return signature;
        }
    ));

try {
    OAuth.correctTimestampFromSrc();
} catch(e) {
}


//--------------------------------------------------

var consumerKey = &quot;${consumer_key}&quot;;
var consumerSecret = &quot;${consumer_secret}&quot;;
var params = [];
var query = [];
query.push(&apos;access_token&apos; + &apos;=&apos; + &apos;${access_token}&apos;);
query.push(&apos;id_token&apos; + &apos;=&apos; + &apos;${id_token}&apos;);
var url =  &quot;${protocol}://${misp_url}/marvelous/people/@me/@self&quot;;

if (query.length) {
    url += &apos;?&apos; + query.join(&apos;&amp;&apos;);
}

var message = {
    method: &apos;put&apos;,
    parameters: params, 
    action: url
};

log.info(url);
log.info(consumerSecret);

var accessor = {
    consumerKey: consumerKey,
    consumerSecret: consumerSecret,
    token:  &apos;${access_token}&apos;,
    tokenSecret: &apos;${id_token}&apos;
};

OAuth.completeRequest(message, accessor);
vars.put(&apos;put_auth_header&apos;, OAuth.getAuthorizationHeader(&apos;&apos;, params).replace(&apos;OAuth realm=&quot;&quot;,&apos;, &apos; OAuth &apos;));
</stringProp>
            <stringProp name="scriptLanguage">javascript</stringProp>
          </BSFPreProcessor>
          <hashTree/>
          <HeaderManager guiclass="HeaderPanel" testclass="HeaderManager" testname="HTTP ヘッダマネージャ" enabled="true">
            <collectionProp name="HeaderManager.headers">
              <elementProp name="" elementType="Header">
                <stringProp name="Header.name">Authorization</stringProp>
                <stringProp name="Header.value">${put_auth_header}</stringProp>
              </elementProp>
              <elementProp name="" elementType="Header">
                <stringProp name="Header.name">content-type</stringProp>
                <stringProp name="Header.value">application/json; charset=utf8</stringProp>
              </elementProp>
              <elementProp name="" elementType="Header">
                <stringProp name="Header.name">Connection</stringProp>
                <stringProp name="Header.value">close</stringProp>
              </elementProp>
              <elementProp name="" elementType="Header">
                <stringProp name="Header.name">Accept-encoding</stringProp>
                <stringProp name="Header.value">gzip, deflate</stringProp>
              </elementProp>
            </collectionProp>
          </HeaderManager>
          <hashTree/>
          <RegexExtractor guiclass="RegexExtractorGui" testclass="RegexExtractor" testname="access_token" enabled="true">
            <stringProp name="RegexExtractor.useHeaders">false</stringProp>
            <stringProp name="RegexExtractor.refname">access_token</stringProp>
            <stringProp name="RegexExtractor.regex">&quot;accessToken&quot;:&quot;(.*?)&quot;</stringProp>
            <stringProp name="RegexExtractor.template">$1$</stringProp>
            <stringProp name="RegexExtractor.default"></stringProp>
            <stringProp name="RegexExtractor.match_number">1</stringProp>
          </RegexExtractor>
          <hashTree/>
          <RegexExtractor guiclass="RegexExtractorGui" testclass="RegexExtractor" testname="id_token" enabled="true">
            <stringProp name="RegexExtractor.useHeaders">false</stringProp>
            <stringProp name="RegexExtractor.refname">id_token</stringProp>
            <stringProp name="RegexExtractor.regex">&quot;idToken&quot;:&quot;(.*?)&quot;</stringProp>
            <stringProp name="RegexExtractor.template">$1$</stringProp>
            <stringProp name="RegexExtractor.default"></stringProp>
            <stringProp name="RegexExtractor.match_number">1</stringProp>
          </RegexExtractor>
          <hashTree/>
          <ResponseAssertion guiclass="AssertionGui" testclass="ResponseAssertion" testname="アサーション" enabled="true">
            <collectionProp name="Asserion.test_strings">
              <stringProp name="-729315055">&quot;password&quot;:&quot;I_have_a_dream&quot;</stringProp>
              <stringProp name="2033562336">&quot;username&quot;:&quot;proxy_user_3&quot;</stringProp>
            </collectionProp>
            <stringProp name="TestPlan.comments">確認項目
1.パスワードが更新されていないこと
2.usernameが更新されていないこと</stringProp>
            <stringProp name="Assertion.test_field">Assertion.response_data</stringProp>
            <boolProp name="Assertion.assume_success">false</boolProp>
            <intProp name="Assertion.test_type">2</intProp>
          </ResponseAssertion>
          <hashTree/>
        </hashTree>
        <HTTPSamplerProxy guiclass="HttpTestSampleGui" testclass="HTTPSamplerProxy" testname="Implicit.ユーザ更新(パスワード自動生成)" enabled="true">
          <boolProp name="HTTPSampler.postBodyRaw">true</boolProp>
          <elementProp name="HTTPsampler.Arguments" elementType="Arguments">
            <collectionProp name="Arguments.arguments">
              <elementProp name="" elementType="HTTPArgument">
                <boolProp name="HTTPArgument.always_encode">false</boolProp>
                <stringProp name="Argument.value">{&#xd;
  &quot;entry&quot;: [&#xd;
    {&#xd;
      &quot;apps&quot;: [&#xd;
        {&#xd;
          &quot;value&quot;: {&#xd;
            &quot;appId&quot;: &quot;00000&quot;,&#xd;
            &quot;userId&quot;: &quot;proxy_test_3&quot;,&#xd;
            &quot;password&quot;: &quot;&quot;&#xd;
          }&#xd;
        }&#xd;
      ]&#xd;
    }&#xd;
  ]&#xd;
}</stringProp>
                <stringProp name="Argument.metadata">=</stringProp>
              </elementProp>
            </collectionProp>
          </elementProp>
          <stringProp name="HTTPSampler.domain"></stringProp>
          <stringProp name="HTTPSampler.port"></stringProp>
          <stringProp name="HTTPSampler.connect_timeout"></stringProp>
          <stringProp name="HTTPSampler.response_timeout"></stringProp>
          <stringProp name="HTTPSampler.protocol"></stringProp>
          <stringProp name="HTTPSampler.contentEncoding"></stringProp>
          <stringProp name="HTTPSampler.path">/marvelous/people/@me/@self?access_token=${access_token}&amp;id_token=${id_token}</stringProp>
          <stringProp name="HTTPSampler.method">PUT</stringProp>
          <boolProp name="HTTPSampler.follow_redirects">true</boolProp>
          <boolProp name="HTTPSampler.auto_redirects">false</boolProp>
          <boolProp name="HTTPSampler.use_keepalive">true</boolProp>
          <boolProp name="HTTPSampler.DO_MULTIPART_POST">false</boolProp>
          <boolProp name="HTTPSampler.monitor">false</boolProp>
          <stringProp name="HTTPSampler.embedded_url_re"></stringProp>
        </HTTPSamplerProxy>
        <hashTree>
          <BSFPreProcessor guiclass="TestBeanGUI" testclass="BSFPreProcessor" testname="BSF PreProcessor" enabled="true">
            <stringProp name="filename"></stringProp>
            <stringProp name="parameters"></stringProp>
            <stringProp name="script">/*
 * A JavaScript implementation of the Secure Hash Algorithm, SHA-1, as defined
 * in FIPS PUB 180-1
 * Version 2.1a Copyright Paul Johnston 2000 - 2002.
 * Other contributors: Greg Holt, Andrew Kepert, Ydnar, Lostinet
 * Distributed under the BSD License
 * See http://pajhome.org.uk/crypt/md5 for details.
 */

/*
 * Configurable variables. You may need to tweak these to be compatible with
 * the server-side, but the defaults work in most cases.
 */
var hexcase = 0;  /* hex output format. 0 - lowercase; 1 - uppercase        */
var b64pad  = &quot;&quot;; /* base-64 pad character. &quot;=&quot; for strict RFC compliance   */
var chrsz   = 8;  /* bits per input character. 8 - ASCII; 16 - Unicode      */

/*
 * These are the functions you&apos;ll usually want to call
 * They take string arguments and return either hex or base-64 encoded strings
 */
function hex_sha1(s){return binb2hex(core_sha1(str2binb(s),s.length * chrsz));}
function b64_sha1(s){return binb2b64(core_sha1(str2binb(s),s.length * chrsz));}
function str_sha1(s){return binb2str(core_sha1(str2binb(s),s.length * chrsz));}
function hex_hmac_sha1(key, data){ return binb2hex(core_hmac_sha1(key, data));}
function b64_hmac_sha1(key, data){ return binb2b64(core_hmac_sha1(key, data));}
function str_hmac_sha1(key, data){ return binb2str(core_hmac_sha1(key, data));}

/*
 * Perform a simple self-test to see if the VM is working
 */
function sha1_vm_test()
{
  return hex_sha1(&quot;abc&quot;) == &quot;a9993e364706816aba3e25717850c26c9cd0d89d&quot;;
}

/*
 * Calculate the SHA-1 of an array of big-endian words, and a bit length
 */
function core_sha1(x, len)
{
  /* append padding */
  x[len &gt;&gt; 5] |= 0x80 &lt;&lt; (24 - len % 32);
  x[((len + 64 &gt;&gt; 9) &lt;&lt; 4) + 15] = len;

  var w = Array(80);
  var a =  1732584193;
  var b = -271733879;
  var c = -1732584194;
  var d =  271733878;
  var e = -1009589776;

  for(var i = 0; i &lt; x.length; i += 16)
  {
    var olda = a;
    var oldb = b;
    var oldc = c;
    var oldd = d;
    var olde = e;

    for(var j = 0; j &lt; 80; j++)
    {
      if(j &lt; 16) w[j] = x[i + j];
      else w[j] = rol(w[j-3] ^ w[j-8] ^ w[j-14] ^ w[j-16], 1);
      var t = safe_add(safe_add(rol(a, 5), sha1_ft(j, b, c, d)),
                       safe_add(safe_add(e, w[j]), sha1_kt(j)));
      e = d;
      d = c;
      c = rol(b, 30);
      b = a;
      a = t;
    }

    a = safe_add(a, olda);
    b = safe_add(b, oldb);
    c = safe_add(c, oldc);
    d = safe_add(d, oldd);
    e = safe_add(e, olde);
  }
  return Array(a, b, c, d, e);

}

/*
 * Perform the appropriate triplet combination function for the current
 * iteration
 */
function sha1_ft(t, b, c, d)
{
  if(t &lt; 20) return (b &amp; c) | ((~b) &amp; d);
  if(t &lt; 40) return b ^ c ^ d;
  if(t &lt; 60) return (b &amp; c) | (b &amp; d) | (c &amp; d);
  return b ^ c ^ d;
}

/*
 * Determine the appropriate additive constant for the current iteration
 */
function sha1_kt(t)
{
  return (t &lt; 20) ?  1518500249 : (t &lt; 40) ?  1859775393 :
         (t &lt; 60) ? -1894007588 : -899497514;
}

/*
 * Calculate the HMAC-SHA1 of a key and some data
 */
function core_hmac_sha1(key, data)
{
  var bkey = str2binb(key);
  if(bkey.length &gt; 16) bkey = core_sha1(bkey, key.length * chrsz);

  var ipad = Array(16), opad = Array(16);
  for(var i = 0; i &lt; 16; i++)
  {
    ipad[i] = bkey[i] ^ 0x36363636;
    opad[i] = bkey[i] ^ 0x5C5C5C5C;
  }

  var hash = core_sha1(ipad.concat(str2binb(data)), 512 + data.length * chrsz);
  return core_sha1(opad.concat(hash), 512 + 160);
}

/*
 * Add integers, wrapping at 2^32. This uses 16-bit operations internally
 * to work around bugs in some JS interpreters.
 */
function safe_add(x, y)
{
  var lsw = (x &amp; 0xFFFF) + (y &amp; 0xFFFF);
  var msw = (x &gt;&gt; 16) + (y &gt;&gt; 16) + (lsw &gt;&gt; 16);
  return (msw &lt;&lt; 16) | (lsw &amp; 0xFFFF);
}

/*
 * Bitwise rotate a 32-bit number to the left.
 */
function rol(num, cnt)
{
  return (num &lt;&lt; cnt) | (num &gt;&gt;&gt; (32 - cnt));
}

/*
 * Convert an 8-bit or 16-bit string to an array of big-endian words
 * In 8-bit function, characters &gt;255 have their hi-byte silently ignored.
 */
function str2binb(str)
{
  var bin = Array();
  var mask = (1 &lt;&lt; chrsz) - 1;
  for(var i = 0; i &lt; str.length * chrsz; i += chrsz)
    bin[i&gt;&gt;5] |= (str.charCodeAt(i / chrsz) &amp; mask) &lt;&lt; (32 - chrsz - i%32);
  return bin;
}

/*
 * Convert an array of big-endian words to a string
 */
function binb2str(bin)
{
  var str = &quot;&quot;;
  var mask = (1 &lt;&lt; chrsz) - 1;
  for(var i = 0; i &lt; bin.length * 32; i += chrsz)
    str += String.fromCharCode((bin[i&gt;&gt;5] &gt;&gt;&gt; (32 - chrsz - i%32)) &amp; mask);
  return str;
}

/*
 * Convert an array of big-endian words to a hex string.
 */
function binb2hex(binarray)
{
  var hex_tab = hexcase ? &quot;0123456789ABCDEF&quot; : &quot;0123456789abcdef&quot;;
  var str = &quot;&quot;;
  for(var i = 0; i &lt; binarray.length * 4; i++)
  {
    str += hex_tab.charAt((binarray[i&gt;&gt;2] &gt;&gt; ((3 - i%4)*8+4)) &amp; 0xF) +
           hex_tab.charAt((binarray[i&gt;&gt;2] &gt;&gt; ((3 - i%4)*8  )) &amp; 0xF);
  }
  return str;
}

/*
 * Convert an array of big-endian words to a base-64 string
 */
function binb2b64(binarray)
{
  var tab = &quot;ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/&quot;;
  var str = &quot;&quot;;
  for(var i = 0; i &lt; binarray.length * 4; i += 3)
  {
    var triplet = (((binarray[i   &gt;&gt; 2] &gt;&gt; 8 * (3 -  i   %4)) &amp; 0xFF) &lt;&lt; 16)
                | (((binarray[i+1 &gt;&gt; 2] &gt;&gt; 8 * (3 - (i+1)%4)) &amp; 0xFF) &lt;&lt; 8 )
                |  ((binarray[i+2 &gt;&gt; 2] &gt;&gt; 8 * (3 - (i+2)%4)) &amp; 0xFF);
    for(var j = 0; j &lt; 4; j++)
    {
      if(i * 8 + j * 6 &gt; binarray.length * 32) str += b64pad;
      else str += tab.charAt((triplet &gt;&gt; 6*(3-j)) &amp; 0x3F);
    }
  }
  return str;
}

/*
 * Copyright 2008 Netflix, Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/* Here&apos;s some JavaScript software for implementing OAuth.

   This isn&apos;t as useful as you might hope.  OAuth is based around
   allowing tools and websites to talk to each other.  However,
   JavaScript running in web browsers is hampered by security
   restrictions that prevent code running on one website from
   accessing data stored or served on another.

   Before you start hacking, make sure you understand the limitations
   posed by cross-domain XMLHttpRequest.

   On the bright side, some platforms use JavaScript as their
   language, but enable the programmer to access other web sites.
   Examples include Google Gadgets, and Microsoft Vista Sidebar.
   For those platforms, this library should come in handy.
*/

// The HMAC-SHA1 signature method calls b64_hmac_sha1, defined by
// http://pajhome.org.uk/crypt/md5/sha1.js

/* An OAuth message is represented as an object like this:
   {method: &quot;GET&quot;, action: &quot;http://server.com/path&quot;, parameters: ...}

   The parameters may be either a map {name: value, name2: value2}
   or an Array of name-value pairs [[name, value], [name2, value2]].
   The latter representation is more powerful: it supports parameters
   in a specific sequence, or several parameters with the same name;
   for example [[&quot;a&quot;, 1], [&quot;b&quot;, 2], [&quot;a&quot;, 3]].

   Parameter names and values are NOT percent-encoded in an object.
   They must be encoded before transmission and decoded after reception.
   For example, this message object:
   {method: &quot;GET&quot;, action: &quot;http://server/path&quot;, parameters: {p: &quot;x y&quot;}}
   ... can be transmitted as an HTTP request that begins:
   GET /path?p=x%20y HTTP/1.0
   (This isn&apos;t a valid OAuth request, since it lacks a signature etc.)
   Note that the object &quot;x y&quot; is transmitted as x%20y.  To encode
   parameters, you can call OAuth.addToURL, OAuth.formEncode or
   OAuth.getAuthorization.

   This message object model harmonizes with the browser object model for
   input elements of an form, whose value property isn&apos;t percent encoded.
   The browser encodes each value before transmitting it. For example,
   see consumer.setInputs in example/consumer.js.
 */

/* This script needs to know what time it is. By default, it uses the local
   clock (new Date), which is apt to be inaccurate in browsers. To do
   better, you can load this script from a URL whose query string contains
   an oauth_timestamp parameter, whose value is a current Unix timestamp.
   For example, when generating the enclosing document using PHP:

   &lt;script src=&quot;oauth.js?oauth_timestamp=&lt;?=time()?&gt;&quot; ...

   Another option is to call OAuth.correctTimestamp with a Unix timestamp.
 */

var OAuth; if (OAuth == null) OAuth = {};

OAuth.setProperties = function setProperties(into, from) {
    if (into != null &amp;&amp; from != null) {
        for (var key in from) {
            into[key] = from[key];
        }
    }
    return into;
}

OAuth.setProperties(OAuth, // utility functions
{
    percentEncode: function percentEncode(s) {
        if (s == null) {
            return &quot;&quot;;
        }
        if (s instanceof Array) {
            var e = &quot;&quot;;
            for (var i = 0; i &lt; s.length; ++s) {
                if (e != &quot;&quot;) e += &apos;&amp;&apos;;
                e += OAuth.percentEncode(s[i]);
            }
            return e;
        }
        s = encodeURIComponent(s);
        // Now replace the values which encodeURIComponent doesn&apos;t do
        // encodeURIComponent ignores: - _ . ! ~ * &apos; ( )
        // OAuth dictates the only ones you can ignore are: - _ . ~
        // Source: http://developer.mozilla.org/en/docs/Core_JavaScript_1.5_Reference:Global_Functions:encodeURIComponent
        s = s.replace(/\!/g, &quot;%21&quot;);
        s = s.replace(/\*/g, &quot;%2A&quot;);
        s = s.replace(/\&apos;/g, &quot;%27&quot;);
        s = s.replace(/\(/g, &quot;%28&quot;);
        s = s.replace(/\)/g, &quot;%29&quot;);
        return s;
    }
,
    decodePercent: function decodePercent(s) {
        if (s != null) {
            // Handle application/x-www-form-urlencoded, which is defined by
            // http://www.w3.org/TR/html4/interact/forms.html#h-17.13.4.1
            s = s.replace(/\+/g, &quot; &quot;);
        }
        return decodeURIComponent(s);
    }
,
    /** Convert the given parameters to an Array of name-value pairs. */
    getParameterList: function getParameterList(parameters) {
        if (parameters == null) {
            return [];
        }
        if (typeof parameters != &quot;object&quot;) {
            return OAuth.decodeForm(parameters + &quot;&quot;);
        }
        if (parameters instanceof Array) {
            return parameters;
        }
        var list = [];
        for (var p in parameters) {
            list.push([p, parameters[p]]);
        }
        return list;
    }
,
    /** Convert the given parameters to a map from name to value. */
    getParameterMap: function getParameterMap(parameters) {
        if (parameters == null) {
            return {};
        }
        if (typeof parameters != &quot;object&quot;) {
            return OAuth.getParameterMap(OAuth.decodeForm(parameters + &quot;&quot;));
        }
        if (parameters instanceof Array) {
            var map = {};
            for (var p = 0; p &lt; parameters.length; ++p) {
                var key = parameters[p][0];
                if (map[key] === undefined) { // first value wins
                    map[key] = parameters[p][1];
                }
            }
            return map;
        }
        return parameters;
    }
,
    getParameter: function getParameter(parameters, name) {
        if (parameters instanceof Array) {
            for (var p = 0; p &lt; parameters.length; ++p) {
                if (parameters[p][0] == name) {
                    return parameters[p][1]; // first value wins
                }
            }
        } else {
            return OAuth.getParameterMap(parameters)[name];
        }
        return null;
    }
,
    formEncode: function formEncode(parameters) {
        var form = &quot;&quot;;
        var list = OAuth.getParameterList(parameters);
        for (var p = 0; p &lt; list.length; ++p) {
            var value = list[p][1];
            if (value == null) value = &quot;&quot;;
            if (form != &quot;&quot;) form += &apos;&amp;&apos;;
            form += OAuth.percentEncode(list[p][0])
              +&apos;=&apos;+ OAuth.percentEncode(value);
        }
        return form;
    }
,
    decodeForm: function decodeForm(form) {
        var list = [];
        var nvps = form.split(&apos;&amp;&apos;);
        for (var n = 0; n &lt; nvps.length; ++n) {
            var nvp = nvps[n];
            if (nvp == &quot;&quot;) {
                continue;
            }
            var equals = nvp.indexOf(&apos;=&apos;);
            var name;
            var value;
            if (equals &lt; 0) {
                name = OAuth.decodePercent(nvp);
                value = null;
            } else {
                name = OAuth.decodePercent(nvp.substring(0, equals));
                value = OAuth.decodePercent(nvp.substring(equals + 1));
            }
            list.push([name, value]);
        }
        return list;
    }
,
    setParameter: function setParameter(message, name, value) {
        var parameters = message.parameters;
        if (parameters instanceof Array) {
            for (var p = 0; p &lt; parameters.length; ++p) {
                if (parameters[p][0] == name) {
                    if (value === undefined) {
                        parameters.splice(p, 1);
                    } else {
                        parameters[p][1] = value;
                        value = undefined;
                    }
                }
            }
            if (value !== undefined) {
                parameters.push([name, value]);
            }
        } else {
            parameters = OAuth.getParameterMap(parameters);
            parameters[name] = value;
            message.parameters = parameters;
        }
    }
,
    setParameters: function setParameters(message, parameters) {
        var list = OAuth.getParameterList(parameters);
        for (var i = 0; i &lt; list.length; ++i) {
            OAuth.setParameter(message, list[i][0], list[i][1]);
        }
    }
,
    /** Fill in parameters to help construct a request message.
        This function doesn&apos;t fill in every parameter.
        The accessor object should be like:
        {consumerKey:&apos;foo&apos;, consumerSecret:&apos;bar&apos;, accessorSecret:&apos;nurn&apos;, token:&apos;krelm&apos;, tokenSecret:&apos;blah&apos;}
        The accessorSecret property is optional.
     */
    completeRequest: function completeRequest(message, accessor) {
        if (message.method == null) {
            message.method = &quot;GET&quot;;
        }
        var map = OAuth.getParameterMap(message.parameters);
        if (map.oauth_consumer_key == null) {
            OAuth.setParameter(message, &quot;oauth_consumer_key&quot;, accessor.consumerKey || &quot;&quot;);
        }
        if (map.oauth_token == null &amp;&amp; accessor.token != null) {
            OAuth.setParameter(message, &quot;oauth_token&quot;, accessor.token);
        }
        if (map.oauth_version == null) {
            OAuth.setParameter(message, &quot;oauth_version&quot;, &quot;1.0&quot;);
        }
        if (map.oauth_timestamp == null) {
            OAuth.setParameter(message, &quot;oauth_timestamp&quot;, OAuth.timestamp());
        }
        if (map.oauth_nonce == null) {
            OAuth.setParameter(message, &quot;oauth_nonce&quot;, OAuth.nonce(6));
        }
        OAuth.SignatureMethod.sign(message, accessor);
    }
,
    setTimestampAndNonce: function setTimestampAndNonce(message) {
        OAuth.setParameter(message, &quot;oauth_timestamp&quot;, OAuth.timestamp());
        OAuth.setParameter(message, &quot;oauth_nonce&quot;, OAuth.nonce(6));
    }
,
    addToURL: function addToURL(url, parameters) {
        newURL = url;
        if (parameters != null) {
            var toAdd = OAuth.formEncode(parameters);
            if (toAdd.length &gt; 0) {
                var q = url.indexOf(&apos;?&apos;);
                if (q &lt; 0) newURL += &apos;?&apos;;
                else       newURL += &apos;&amp;&apos;;
                newURL += toAdd;
            }
        }
        return newURL;
    }
,
    /** Construct the value of the Authorization header for an HTTP request. */
    getAuthorizationHeader: function getAuthorizationHeader(realm, parameters) {
        var header = &apos;OAuth realm=&quot;&apos; + OAuth.percentEncode(realm) + &apos;&quot;&apos;;
        var list = OAuth.getParameterList(parameters);
        for (var p = 0; p &lt; list.length; ++p) {
            var parameter = list[p];
            var name = parameter[0];
            if (name.indexOf(&quot;oauth_&quot;) == 0) {
                header += &apos;,&apos; + OAuth.percentEncode(name) + &apos;=&quot;&apos; + OAuth.percentEncode(parameter[1]) + &apos;&quot;&apos;;
            }
        }
        return header;
    }
,
    /** Correct the time using a parameter from the URL from which the last script was loaded. */
    correctTimestampFromSrc: function correctTimestampFromSrc(parameterName) {
        parameterName = parameterName || &quot;oauth_timestamp&quot;;
        var scripts = document.getElementsByTagName(&apos;script&apos;);
        if (scripts == null || !scripts.length) return;
        var src = scripts[scripts.length-1].src;
        if (!src) return;
        var q = src.indexOf(&quot;?&quot;);
        if (q &lt; 0) return;
        parameters = OAuth.getParameterMap(OAuth.decodeForm(src.substring(q+1)));
        var t = parameters[parameterName];
        if (t == null) return;
        OAuth.correctTimestamp(t);
    }
,
    /** Generate timestamps starting with the given value. */
    correctTimestamp: function correctTimestamp(timestamp) {
        OAuth.timeCorrectionMsec = (timestamp * 1000) - (new Date()).getTime();
    }
,
    /** The difference between the correct time and my clock. */
    timeCorrectionMsec: 0
,
    timestamp: function timestamp() {
        var t = (new Date()).getTime() + OAuth.timeCorrectionMsec;
        return Math.floor(t / 1000);
    }
,
    nonce: function nonce(length) {
        var chars = OAuth.nonce.CHARS;
        var result = &quot;&quot;;
        for (var i = 0; i &lt; length; ++i) {
            var rnum = Math.floor(Math.random() * chars.length);
            result += chars.substring(rnum, rnum+1);
        }
        return result;
    }
});

OAuth.nonce.CHARS = &quot;0123456789ABCDEFGHIJKLMNOPQRSTUVWXTZabcdefghiklmnopqrstuvwxyz&quot;;

/** Define a constructor function,
    without causing trouble to anyone who was using it as a namespace.
    That is, if parent[name] already existed and had properties,
    copy those properties into the new constructor.
 */
OAuth.declareClass = function declareClass(parent, name, newConstructor) {
    var previous = parent[name];
    parent[name] = newConstructor;
    if (newConstructor != null &amp;&amp; previous != null) {
        for (var key in previous) {
            if (key != &quot;prototype&quot;) {
                newConstructor[key] = previous[key];
            }
        }
    }
    return newConstructor;
}

/** An abstract algorithm for signing messages. */
OAuth.declareClass(OAuth, &quot;SignatureMethod&quot;, function OAuthSignatureMethod(){});

OAuth.setProperties(OAuth.SignatureMethod.prototype, // instance members
{
    /** Add a signature to the message. */
    sign: function sign(message) {
        var baseString = OAuth.SignatureMethod.getBaseString(message);
        var signature = this.getSignature(baseString);
        OAuth.setParameter(message, &quot;oauth_signature&quot;, signature);
        return signature; // just in case someone&apos;s interested
    }
,
    /** Set the key string for signing. */
    initialize: function initialize(name, accessor) {
        var consumerSecret;
        if (accessor.accessorSecret != null
            &amp;&amp; name.length &gt; 9
            &amp;&amp; name.substring(name.length-9) == &quot;-Accessor&quot;)
        {
            consumerSecret = accessor.accessorSecret;
        } else {
            consumerSecret = accessor.consumerSecret;
        }
        this.key = OAuth.percentEncode(consumerSecret)
             +&quot;&amp;&quot;+ OAuth.percentEncode(accessor.tokenSecret);
    }
});

/* SignatureMethod expects an accessor object to be like this:
   {tokenSecret: &quot;lakjsdflkj...&quot;, consumerSecret: &quot;QOUEWRI..&quot;, accessorSecret: &quot;xcmvzc...&quot;}
   The accessorSecret property is optional.
 */
// Class members:
OAuth.setProperties(OAuth.SignatureMethod, // class members
{
    sign: function sign(message, accessor) {
        var name = OAuth.getParameterMap(message.parameters).oauth_signature_method;
        if (name == null || name == &quot;&quot;) {
            name = &quot;HMAC-SHA1&quot;;
            OAuth.setParameter(message, &quot;oauth_signature_method&quot;, name);
        }
        OAuth.SignatureMethod.newMethod(name, accessor).sign(message);
    }
,
    /** Instantiate a SignatureMethod for the given method name. */
    newMethod: function newMethod(name, accessor) {
        var impl = OAuth.SignatureMethod.REGISTERED[name];
        if (impl != null) {
            var method = new impl();
            method.initialize(name, accessor);
            return method;
        }
        var err = new Error(&quot;signature_method_rejected&quot;);
        var acceptable = &quot;&quot;;
        for (var r in OAuth.SignatureMethod.REGISTERED) {
            if (acceptable != &quot;&quot;) acceptable += &apos;&amp;&apos;;
            acceptable += OAuth.percentEncode(r);
        }
        err.oauth_acceptable_signature_methods = acceptable;
        throw err;
    }
,
    /** A map from signature method name to constructor. */
    REGISTERED : {}
,
    /** Subsequently, the given constructor will be used for the named methods.
        The constructor will be called with no parameters.
        The resulting object should usually implement getSignature(baseString).
        You can easily define such a constructor by calling makeSubclass, below.
     */
    registerMethodClass: function registerMethodClass(names, classConstructor) {
        for (var n = 0; n &lt; names.length; ++n) {
            OAuth.SignatureMethod.REGISTERED[names[n]] = classConstructor;
        }
    }
,
    /** Create a subclass of OAuth.SignatureMethod, with the given getSignature function. */
    makeSubclass: function makeSubclass(getSignatureFunction) {
        var superClass = OAuth.SignatureMethod;
        var subClass = function() {
            superClass.call(this);
        };
        subClass.prototype = new superClass();
        // Delete instance variables from prototype:
        // delete subclass.prototype... There aren&apos;t any.
        subClass.prototype.getSignature = getSignatureFunction;
        subClass.prototype.constructor = subClass;
        return subClass;
    }
,
    getBaseString: function getBaseString(message) {
        var URL = message.action;
        var q = URL.indexOf(&apos;?&apos;);
        var parameters;
        if (q &lt; 0) {
            parameters = message.parameters;
        } else {
            // Combine the URL query string with the other parameters:
            parameters = OAuth.decodeForm(URL.substring(q + 1));
            var toAdd = OAuth.getParameterList(message.parameters);
            for (var a = 0; a &lt; toAdd.length; ++a) {
                parameters.push(toAdd[a]);
            }
        }
        return OAuth.percentEncode(message.method.toUpperCase())
         +&apos;&amp;&apos;+ OAuth.percentEncode(OAuth.SignatureMethod.normalizeUrl(URL))
         +&apos;&amp;&apos;+ OAuth.percentEncode(OAuth.SignatureMethod.normalizeParameters(parameters));
    }
,
    normalizeUrl: function normalizeUrl(url) {
        var uri = OAuth.SignatureMethod.parseUri(url);
        var scheme = uri.protocol.toLowerCase();
        var authority = uri.authority.toLowerCase();
        var dropPort = (scheme == &quot;http&quot; &amp;&amp; uri.port == 80)
                    || (scheme == &quot;https&quot; &amp;&amp; uri.port == 443);
        if (dropPort) {
            // find the last : in the authority
            var index = authority.lastIndexOf(&quot;:&quot;);
            if (index &gt;= 0) {
                authority = authority.substring(0, index);
            }
        }
        var path = uri.path;
        if (!path) {
            path = &quot;/&quot;; // conforms to RFC 2616 section 3.2.2
        }
        // we know that there is no query and no fragment here.
        return scheme + &quot;://&quot; + authority + path;
    }
,
    parseUri: function parseUri (str) {
        /* This function was adapted from parseUri 1.2.1
           http://stevenlevithan.com/demo/parseuri/js/assets/parseuri.js
         */
        var o = {key: [&quot;source&quot;,&quot;protocol&quot;,&quot;authority&quot;,&quot;userInfo&quot;,&quot;user&quot;,&quot;password&quot;,&quot;host&quot;,&quot;port&quot;,&quot;relative&quot;,&quot;path&quot;,&quot;directory&quot;,&quot;file&quot;,&quot;query&quot;,&quot;anchor&quot;],
                 parser: {strict: /^(?:([^:\/?#]+):)?(?:\/\/((?:(([^:@\/]*):?([^:@\/]*))?@)?([^:\/?#]*)(?::(\d*))?))?((((?:[^?#\/]*\/)*)([^?#]*))(?:\?([^#]*))?(?:#(.*))?)/ }};
        var m = o.parser.strict.exec(str);
        var uri = {};
        var i = 14;
        while (i--) uri[o.key[i]] = m[i] || &quot;&quot;;
        return uri;
    }
,
    normalizeParameters: function normalizeParameters(parameters) {
        if (parameters == null) {
            return &quot;&quot;;
        }
        var list = OAuth.getParameterList(parameters);
        var sortable = [];
        for (var p = 0; p &lt; list.length; ++p) {
            var nvp = list[p];
            if (nvp[0] != &quot;oauth_signature&quot;) {
                sortable.push([ OAuth.percentEncode(nvp[0])
                              + &quot; &quot; // because it comes before any character that can appear in a percentEncoded string.
                              + OAuth.percentEncode(nvp[1])
                              , nvp]);
            }
        }
        sortable.sort(function(a,b) {
                          if (a[0] &lt; b[0]) return  -1;
                          if (a[0] &gt; b[0]) return 1;
                          return 0;
                      });
        var sorted = [];
        for (var s = 0; s &lt; sortable.length; ++s) {
            sorted.push(sortable[s][1]);
        }
        return OAuth.formEncode(sorted);
    }
});

OAuth.SignatureMethod.registerMethodClass([&quot;PLAINTEXT&quot;, &quot;PLAINTEXT-Accessor&quot;],
    OAuth.SignatureMethod.makeSubclass(
        function getSignature(baseString) {
            return this.key;
        }
    ));

OAuth.SignatureMethod.registerMethodClass([&quot;HMAC-SHA1&quot;, &quot;HMAC-SHA1-Accessor&quot;],
    OAuth.SignatureMethod.makeSubclass(
        function getSignature(baseString) {
            b64pad = &apos;=&apos;;
            var signature = b64_hmac_sha1(this.key, baseString);
            return signature;
        }
    ));

try {
    OAuth.correctTimestampFromSrc();
} catch(e) {
}


//--------------------------------------------------

var consumerKey = &quot;${consumer_key}&quot;;
var consumerSecret = &quot;${consumer_secret}&quot;;
var params = [];
var query = [];
query.push(&apos;access_token&apos; + &apos;=&apos; + &apos;${access_token}&apos;);
query.push(&apos;id_token&apos; + &apos;=&apos; + &apos;${id_token}&apos;);
var url =  &quot;${protocol}://${misp_url}/marvelous/people/@me/@self&quot;;

if (query.length) {
    url += &apos;?&apos; + query.join(&apos;&amp;&apos;);
}

var message = {
    method: &apos;put&apos;,
    parameters: params, 
    action: url
};

log.info(url);
log.info(consumerSecret);

var accessor = {
    consumerKey: consumerKey,
    consumerSecret: consumerSecret,
    token:  &apos;${access_token}&apos;,
    tokenSecret: &apos;${id_token}&apos;
};

OAuth.completeRequest(message, accessor);
vars.put(&apos;put_auth_header&apos;, OAuth.getAuthorizationHeader(&apos;&apos;, params).replace(&apos;OAuth realm=&quot;&quot;,&apos;, &apos; OAuth &apos;));
</stringProp>
            <stringProp name="scriptLanguage">javascript</stringProp>
          </BSFPreProcessor>
          <hashTree/>
          <HeaderManager guiclass="HeaderPanel" testclass="HeaderManager" testname="HTTP ヘッダマネージャ" enabled="true">
            <collectionProp name="HeaderManager.headers">
              <elementProp name="" elementType="Header">
                <stringProp name="Header.name">Authorization</stringProp>
                <stringProp name="Header.value">${put_auth_header}</stringProp>
              </elementProp>
              <elementProp name="" elementType="Header">
                <stringProp name="Header.name">content-type</stringProp>
                <stringProp name="Header.value">application/json; charset=utf8</stringProp>
              </elementProp>
              <elementProp name="" elementType="Header">
                <stringProp name="Header.name">Connection</stringProp>
                <stringProp name="Header.value">close</stringProp>
              </elementProp>
              <elementProp name="" elementType="Header">
                <stringProp name="Header.name">Accept-encoding</stringProp>
                <stringProp name="Header.value">gzip, deflate</stringProp>
              </elementProp>
            </collectionProp>
          </HeaderManager>
          <hashTree/>
          <RegexExtractor guiclass="RegexExtractorGui" testclass="RegexExtractor" testname="access_token" enabled="true">
            <stringProp name="RegexExtractor.useHeaders">false</stringProp>
            <stringProp name="RegexExtractor.refname">access_token</stringProp>
            <stringProp name="RegexExtractor.regex">&quot;accessToken&quot;:&quot;(.*?)&quot;</stringProp>
            <stringProp name="RegexExtractor.template">$1$</stringProp>
            <stringProp name="RegexExtractor.default"></stringProp>
            <stringProp name="RegexExtractor.match_number">1</stringProp>
          </RegexExtractor>
          <hashTree/>
          <RegexExtractor guiclass="RegexExtractorGui" testclass="RegexExtractor" testname="id_token" enabled="true">
            <stringProp name="RegexExtractor.useHeaders">false</stringProp>
            <stringProp name="RegexExtractor.refname">id_token</stringProp>
            <stringProp name="RegexExtractor.regex">&quot;idToken&quot;:&quot;(.*?)&quot;</stringProp>
            <stringProp name="RegexExtractor.template">$1$</stringProp>
            <stringProp name="RegexExtractor.default"></stringProp>
            <stringProp name="RegexExtractor.match_number">1</stringProp>
          </RegexExtractor>
          <hashTree/>
          <ResponseAssertion guiclass="AssertionGui" testclass="ResponseAssertion" testname="アサーション" enabled="true">
            <collectionProp name="Asserion.test_strings">
              <stringProp name="2033562336">&quot;username&quot;:&quot;proxy_user_3&quot;</stringProp>
            </collectionProp>
            <stringProp name="TestPlan.comments">確認項目
usernameが更新されていないか</stringProp>
            <stringProp name="Assertion.test_field">Assertion.response_data</stringProp>
            <boolProp name="Assertion.assume_success">false</boolProp>
            <intProp name="Assertion.test_type">2</intProp>
          </ResponseAssertion>
          <hashTree/>
          <ResponseAssertion guiclass="AssertionGui" testclass="ResponseAssertion" testname="アサーション" enabled="true">
            <collectionProp name="Asserion.test_strings">
              <stringProp name="-820239147">&quot;password&quot;:&quot;&quot;</stringProp>
            </collectionProp>
            <stringProp name="TestPlan.comments">確認項目
パスワードが空になっていないか？</stringProp>
            <stringProp name="Assertion.test_field">Assertion.response_data</stringProp>
            <boolProp name="Assertion.assume_success">false</boolProp>
            <intProp name="Assertion.test_type">6</intProp>
          </ResponseAssertion>
          <hashTree/>
          <ResponseAssertion guiclass="AssertionGui" testclass="ResponseAssertion" testname="アサーション" enabled="true">
            <collectionProp name="Asserion.test_strings">
              <stringProp name="-729315055">&quot;password&quot;:&quot;I_have_a_dream&quot;</stringProp>
            </collectionProp>
            <stringProp name="TestPlan.comments">確認項目
passwordが更新されているか</stringProp>
            <stringProp name="Assertion.test_field">Assertion.response_data</stringProp>
            <boolProp name="Assertion.assume_success">false</boolProp>
            <intProp name="Assertion.test_type">6</intProp>
          </ResponseAssertion>
          <hashTree/>
        </hashTree>
        <HTTPSamplerProxy guiclass="HttpTestSampleGui" testclass="HTTPSamplerProxy" testname="Implicit.ユーザ更新エラー(秘密鍵が空)" enabled="true">
          <boolProp name="HTTPSampler.postBodyRaw">true</boolProp>
          <elementProp name="HTTPsampler.Arguments" elementType="Arguments">
            <collectionProp name="Arguments.arguments">
              <elementProp name="" elementType="HTTPArgument">
                <boolProp name="HTTPArgument.always_encode">false</boolProp>
                <stringProp name="Argument.value">{&#xd;
  &quot;entry&quot;: [&#xd;
    {&#xd;
      &quot;apps&quot;: [&#xd;
        {&#xd;
          &quot;value&quot;: {&#xd;
            &quot;appId&quot;: &quot;00000&quot;,&#xd;
            &quot;userId&quot;: &quot;proxy_test_3&quot;&#xd;
          }&#xd;
        }&#xd;
      ]&#xd;
    }&#xd;
  ]&#xd;
}</stringProp>
                <stringProp name="Argument.metadata">=</stringProp>
              </elementProp>
            </collectionProp>
          </elementProp>
          <stringProp name="HTTPSampler.domain"></stringProp>
          <stringProp name="HTTPSampler.port"></stringProp>
          <stringProp name="HTTPSampler.connect_timeout"></stringProp>
          <stringProp name="HTTPSampler.response_timeout"></stringProp>
          <stringProp name="HTTPSampler.protocol"></stringProp>
          <stringProp name="HTTPSampler.contentEncoding"></stringProp>
          <stringProp name="HTTPSampler.path">/marvelous/people/@me/@self?access_token=${access_token}&amp;id_token=${id_token}</stringProp>
          <stringProp name="HTTPSampler.method">PUT</stringProp>
          <boolProp name="HTTPSampler.follow_redirects">true</boolProp>
          <boolProp name="HTTPSampler.auto_redirects">false</boolProp>
          <boolProp name="HTTPSampler.use_keepalive">true</boolProp>
          <boolProp name="HTTPSampler.DO_MULTIPART_POST">false</boolProp>
          <boolProp name="HTTPSampler.monitor">false</boolProp>
          <stringProp name="HTTPSampler.embedded_url_re"></stringProp>
        </HTTPSamplerProxy>
        <hashTree>
          <BSFPreProcessor guiclass="TestBeanGUI" testclass="BSFPreProcessor" testname="BSF PreProcessor" enabled="true">
            <stringProp name="filename"></stringProp>
            <stringProp name="parameters"></stringProp>
            <stringProp name="script">/*
 * A JavaScript implementation of the Secure Hash Algorithm, SHA-1, as defined
 * in FIPS PUB 180-1
 * Version 2.1a Copyright Paul Johnston 2000 - 2002.
 * Other contributors: Greg Holt, Andrew Kepert, Ydnar, Lostinet
 * Distributed under the BSD License
 * See http://pajhome.org.uk/crypt/md5 for details.
 */

/*
 * Configurable variables. You may need to tweak these to be compatible with
 * the server-side, but the defaults work in most cases.
 */
var hexcase = 0;  /* hex output format. 0 - lowercase; 1 - uppercase        */
var b64pad  = &quot;&quot;; /* base-64 pad character. &quot;=&quot; for strict RFC compliance   */
var chrsz   = 8;  /* bits per input character. 8 - ASCII; 16 - Unicode      */

/*
 * These are the functions you&apos;ll usually want to call
 * They take string arguments and return either hex or base-64 encoded strings
 */
function hex_sha1(s){return binb2hex(core_sha1(str2binb(s),s.length * chrsz));}
function b64_sha1(s){return binb2b64(core_sha1(str2binb(s),s.length * chrsz));}
function str_sha1(s){return binb2str(core_sha1(str2binb(s),s.length * chrsz));}
function hex_hmac_sha1(key, data){ return binb2hex(core_hmac_sha1(key, data));}
function b64_hmac_sha1(key, data){ return binb2b64(core_hmac_sha1(key, data));}
function str_hmac_sha1(key, data){ return binb2str(core_hmac_sha1(key, data));}

/*
 * Perform a simple self-test to see if the VM is working
 */
function sha1_vm_test()
{
  return hex_sha1(&quot;abc&quot;) == &quot;a9993e364706816aba3e25717850c26c9cd0d89d&quot;;
}

/*
 * Calculate the SHA-1 of an array of big-endian words, and a bit length
 */
function core_sha1(x, len)
{
  /* append padding */
  x[len &gt;&gt; 5] |= 0x80 &lt;&lt; (24 - len % 32);
  x[((len + 64 &gt;&gt; 9) &lt;&lt; 4) + 15] = len;

  var w = Array(80);
  var a =  1732584193;
  var b = -271733879;
  var c = -1732584194;
  var d =  271733878;
  var e = -1009589776;

  for(var i = 0; i &lt; x.length; i += 16)
  {
    var olda = a;
    var oldb = b;
    var oldc = c;
    var oldd = d;
    var olde = e;

    for(var j = 0; j &lt; 80; j++)
    {
      if(j &lt; 16) w[j] = x[i + j];
      else w[j] = rol(w[j-3] ^ w[j-8] ^ w[j-14] ^ w[j-16], 1);
      var t = safe_add(safe_add(rol(a, 5), sha1_ft(j, b, c, d)),
                       safe_add(safe_add(e, w[j]), sha1_kt(j)));
      e = d;
      d = c;
      c = rol(b, 30);
      b = a;
      a = t;
    }

    a = safe_add(a, olda);
    b = safe_add(b, oldb);
    c = safe_add(c, oldc);
    d = safe_add(d, oldd);
    e = safe_add(e, olde);
  }
  return Array(a, b, c, d, e);

}

/*
 * Perform the appropriate triplet combination function for the current
 * iteration
 */
function sha1_ft(t, b, c, d)
{
  if(t &lt; 20) return (b &amp; c) | ((~b) &amp; d);
  if(t &lt; 40) return b ^ c ^ d;
  if(t &lt; 60) return (b &amp; c) | (b &amp; d) | (c &amp; d);
  return b ^ c ^ d;
}

/*
 * Determine the appropriate additive constant for the current iteration
 */
function sha1_kt(t)
{
  return (t &lt; 20) ?  1518500249 : (t &lt; 40) ?  1859775393 :
         (t &lt; 60) ? -1894007588 : -899497514;
}

/*
 * Calculate the HMAC-SHA1 of a key and some data
 */
function core_hmac_sha1(key, data)
{
  var bkey = str2binb(key);
  if(bkey.length &gt; 16) bkey = core_sha1(bkey, key.length * chrsz);

  var ipad = Array(16), opad = Array(16);
  for(var i = 0; i &lt; 16; i++)
  {
    ipad[i] = bkey[i] ^ 0x36363636;
    opad[i] = bkey[i] ^ 0x5C5C5C5C;
  }

  var hash = core_sha1(ipad.concat(str2binb(data)), 512 + data.length * chrsz);
  return core_sha1(opad.concat(hash), 512 + 160);
}

/*
 * Add integers, wrapping at 2^32. This uses 16-bit operations internally
 * to work around bugs in some JS interpreters.
 */
function safe_add(x, y)
{
  var lsw = (x &amp; 0xFFFF) + (y &amp; 0xFFFF);
  var msw = (x &gt;&gt; 16) + (y &gt;&gt; 16) + (lsw &gt;&gt; 16);
  return (msw &lt;&lt; 16) | (lsw &amp; 0xFFFF);
}

/*
 * Bitwise rotate a 32-bit number to the left.
 */
function rol(num, cnt)
{
  return (num &lt;&lt; cnt) | (num &gt;&gt;&gt; (32 - cnt));
}

/*
 * Convert an 8-bit or 16-bit string to an array of big-endian words
 * In 8-bit function, characters &gt;255 have their hi-byte silently ignored.
 */
function str2binb(str)
{
  var bin = Array();
  var mask = (1 &lt;&lt; chrsz) - 1;
  for(var i = 0; i &lt; str.length * chrsz; i += chrsz)
    bin[i&gt;&gt;5] |= (str.charCodeAt(i / chrsz) &amp; mask) &lt;&lt; (32 - chrsz - i%32);
  return bin;
}

/*
 * Convert an array of big-endian words to a string
 */
function binb2str(bin)
{
  var str = &quot;&quot;;
  var mask = (1 &lt;&lt; chrsz) - 1;
  for(var i = 0; i &lt; bin.length * 32; i += chrsz)
    str += String.fromCharCode((bin[i&gt;&gt;5] &gt;&gt;&gt; (32 - chrsz - i%32)) &amp; mask);
  return str;
}

/*
 * Convert an array of big-endian words to a hex string.
 */
function binb2hex(binarray)
{
  var hex_tab = hexcase ? &quot;0123456789ABCDEF&quot; : &quot;0123456789abcdef&quot;;
  var str = &quot;&quot;;
  for(var i = 0; i &lt; binarray.length * 4; i++)
  {
    str += hex_tab.charAt((binarray[i&gt;&gt;2] &gt;&gt; ((3 - i%4)*8+4)) &amp; 0xF) +
           hex_tab.charAt((binarray[i&gt;&gt;2] &gt;&gt; ((3 - i%4)*8  )) &amp; 0xF);
  }
  return str;
}

/*
 * Convert an array of big-endian words to a base-64 string
 */
function binb2b64(binarray)
{
  var tab = &quot;ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/&quot;;
  var str = &quot;&quot;;
  for(var i = 0; i &lt; binarray.length * 4; i += 3)
  {
    var triplet = (((binarray[i   &gt;&gt; 2] &gt;&gt; 8 * (3 -  i   %4)) &amp; 0xFF) &lt;&lt; 16)
                | (((binarray[i+1 &gt;&gt; 2] &gt;&gt; 8 * (3 - (i+1)%4)) &amp; 0xFF) &lt;&lt; 8 )
                |  ((binarray[i+2 &gt;&gt; 2] &gt;&gt; 8 * (3 - (i+2)%4)) &amp; 0xFF);
    for(var j = 0; j &lt; 4; j++)
    {
      if(i * 8 + j * 6 &gt; binarray.length * 32) str += b64pad;
      else str += tab.charAt((triplet &gt;&gt; 6*(3-j)) &amp; 0x3F);
    }
  }
  return str;
}

/*
 * Copyright 2008 Netflix, Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/* Here&apos;s some JavaScript software for implementing OAuth.

   This isn&apos;t as useful as you might hope.  OAuth is based around
   allowing tools and websites to talk to each other.  However,
   JavaScript running in web browsers is hampered by security
   restrictions that prevent code running on one website from
   accessing data stored or served on another.

   Before you start hacking, make sure you understand the limitations
   posed by cross-domain XMLHttpRequest.

   On the bright side, some platforms use JavaScript as their
   language, but enable the programmer to access other web sites.
   Examples include Google Gadgets, and Microsoft Vista Sidebar.
   For those platforms, this library should come in handy.
*/

// The HMAC-SHA1 signature method calls b64_hmac_sha1, defined by
// http://pajhome.org.uk/crypt/md5/sha1.js

/* An OAuth message is represented as an object like this:
   {method: &quot;GET&quot;, action: &quot;http://server.com/path&quot;, parameters: ...}

   The parameters may be either a map {name: value, name2: value2}
   or an Array of name-value pairs [[name, value], [name2, value2]].
   The latter representation is more powerful: it supports parameters
   in a specific sequence, or several parameters with the same name;
   for example [[&quot;a&quot;, 1], [&quot;b&quot;, 2], [&quot;a&quot;, 3]].

   Parameter names and values are NOT percent-encoded in an object.
   They must be encoded before transmission and decoded after reception.
   For example, this message object:
   {method: &quot;GET&quot;, action: &quot;http://server/path&quot;, parameters: {p: &quot;x y&quot;}}
   ... can be transmitted as an HTTP request that begins:
   GET /path?p=x%20y HTTP/1.0
   (This isn&apos;t a valid OAuth request, since it lacks a signature etc.)
   Note that the object &quot;x y&quot; is transmitted as x%20y.  To encode
   parameters, you can call OAuth.addToURL, OAuth.formEncode or
   OAuth.getAuthorization.

   This message object model harmonizes with the browser object model for
   input elements of an form, whose value property isn&apos;t percent encoded.
   The browser encodes each value before transmitting it. For example,
   see consumer.setInputs in example/consumer.js.
 */

/* This script needs to know what time it is. By default, it uses the local
   clock (new Date), which is apt to be inaccurate in browsers. To do
   better, you can load this script from a URL whose query string contains
   an oauth_timestamp parameter, whose value is a current Unix timestamp.
   For example, when generating the enclosing document using PHP:

   &lt;script src=&quot;oauth.js?oauth_timestamp=&lt;?=time()?&gt;&quot; ...

   Another option is to call OAuth.correctTimestamp with a Unix timestamp.
 */

var OAuth; if (OAuth == null) OAuth = {};

OAuth.setProperties = function setProperties(into, from) {
    if (into != null &amp;&amp; from != null) {
        for (var key in from) {
            into[key] = from[key];
        }
    }
    return into;
}

OAuth.setProperties(OAuth, // utility functions
{
    percentEncode: function percentEncode(s) {
        if (s == null) {
            return &quot;&quot;;
        }
        if (s instanceof Array) {
            var e = &quot;&quot;;
            for (var i = 0; i &lt; s.length; ++s) {
                if (e != &quot;&quot;) e += &apos;&amp;&apos;;
                e += OAuth.percentEncode(s[i]);
            }
            return e;
        }
        s = encodeURIComponent(s);
        // Now replace the values which encodeURIComponent doesn&apos;t do
        // encodeURIComponent ignores: - _ . ! ~ * &apos; ( )
        // OAuth dictates the only ones you can ignore are: - _ . ~
        // Source: http://developer.mozilla.org/en/docs/Core_JavaScript_1.5_Reference:Global_Functions:encodeURIComponent
        s = s.replace(/\!/g, &quot;%21&quot;);
        s = s.replace(/\*/g, &quot;%2A&quot;);
        s = s.replace(/\&apos;/g, &quot;%27&quot;);
        s = s.replace(/\(/g, &quot;%28&quot;);
        s = s.replace(/\)/g, &quot;%29&quot;);
        return s;
    }
,
    decodePercent: function decodePercent(s) {
        if (s != null) {
            // Handle application/x-www-form-urlencoded, which is defined by
            // http://www.w3.org/TR/html4/interact/forms.html#h-17.13.4.1
            s = s.replace(/\+/g, &quot; &quot;);
        }
        return decodeURIComponent(s);
    }
,
    /** Convert the given parameters to an Array of name-value pairs. */
    getParameterList: function getParameterList(parameters) {
        if (parameters == null) {
            return [];
        }
        if (typeof parameters != &quot;object&quot;) {
            return OAuth.decodeForm(parameters + &quot;&quot;);
        }
        if (parameters instanceof Array) {
            return parameters;
        }
        var list = [];
        for (var p in parameters) {
            list.push([p, parameters[p]]);
        }
        return list;
    }
,
    /** Convert the given parameters to a map from name to value. */
    getParameterMap: function getParameterMap(parameters) {
        if (parameters == null) {
            return {};
        }
        if (typeof parameters != &quot;object&quot;) {
            return OAuth.getParameterMap(OAuth.decodeForm(parameters + &quot;&quot;));
        }
        if (parameters instanceof Array) {
            var map = {};
            for (var p = 0; p &lt; parameters.length; ++p) {
                var key = parameters[p][0];
                if (map[key] === undefined) { // first value wins
                    map[key] = parameters[p][1];
                }
            }
            return map;
        }
        return parameters;
    }
,
    getParameter: function getParameter(parameters, name) {
        if (parameters instanceof Array) {
            for (var p = 0; p &lt; parameters.length; ++p) {
                if (parameters[p][0] == name) {
                    return parameters[p][1]; // first value wins
                }
            }
        } else {
            return OAuth.getParameterMap(parameters)[name];
        }
        return null;
    }
,
    formEncode: function formEncode(parameters) {
        var form = &quot;&quot;;
        var list = OAuth.getParameterList(parameters);
        for (var p = 0; p &lt; list.length; ++p) {
            var value = list[p][1];
            if (value == null) value = &quot;&quot;;
            if (form != &quot;&quot;) form += &apos;&amp;&apos;;
            form += OAuth.percentEncode(list[p][0])
              +&apos;=&apos;+ OAuth.percentEncode(value);
        }
        return form;
    }
,
    decodeForm: function decodeForm(form) {
        var list = [];
        var nvps = form.split(&apos;&amp;&apos;);
        for (var n = 0; n &lt; nvps.length; ++n) {
            var nvp = nvps[n];
            if (nvp == &quot;&quot;) {
                continue;
            }
            var equals = nvp.indexOf(&apos;=&apos;);
            var name;
            var value;
            if (equals &lt; 0) {
                name = OAuth.decodePercent(nvp);
                value = null;
            } else {
                name = OAuth.decodePercent(nvp.substring(0, equals));
                value = OAuth.decodePercent(nvp.substring(equals + 1));
            }
            list.push([name, value]);
        }
        return list;
    }
,
    setParameter: function setParameter(message, name, value) {
        var parameters = message.parameters;
        if (parameters instanceof Array) {
            for (var p = 0; p &lt; parameters.length; ++p) {
                if (parameters[p][0] == name) {
                    if (value === undefined) {
                        parameters.splice(p, 1);
                    } else {
                        parameters[p][1] = value;
                        value = undefined;
                    }
                }
            }
            if (value !== undefined) {
                parameters.push([name, value]);
            }
        } else {
            parameters = OAuth.getParameterMap(parameters);
            parameters[name] = value;
            message.parameters = parameters;
        }
    }
,
    setParameters: function setParameters(message, parameters) {
        var list = OAuth.getParameterList(parameters);
        for (var i = 0; i &lt; list.length; ++i) {
            OAuth.setParameter(message, list[i][0], list[i][1]);
        }
    }
,
    /** Fill in parameters to help construct a request message.
        This function doesn&apos;t fill in every parameter.
        The accessor object should be like:
        {consumerKey:&apos;foo&apos;, consumerSecret:&apos;bar&apos;, accessorSecret:&apos;nurn&apos;, token:&apos;krelm&apos;, tokenSecret:&apos;blah&apos;}
        The accessorSecret property is optional.
     */
    completeRequest: function completeRequest(message, accessor) {
        if (message.method == null) {
            message.method = &quot;GET&quot;;
        }
        var map = OAuth.getParameterMap(message.parameters);
        if (map.oauth_consumer_key == null) {
            OAuth.setParameter(message, &quot;oauth_consumer_key&quot;, accessor.consumerKey || &quot;&quot;);
        }
        if (map.oauth_token == null &amp;&amp; accessor.token != null) {
            OAuth.setParameter(message, &quot;oauth_token&quot;, accessor.token);
        }
        if (map.oauth_version == null) {
            OAuth.setParameter(message, &quot;oauth_version&quot;, &quot;1.0&quot;);
        }
        if (map.oauth_timestamp == null) {
            OAuth.setParameter(message, &quot;oauth_timestamp&quot;, OAuth.timestamp());
        }
        if (map.oauth_nonce == null) {
            OAuth.setParameter(message, &quot;oauth_nonce&quot;, OAuth.nonce(6));
        }
        OAuth.SignatureMethod.sign(message, accessor);
    }
,
    setTimestampAndNonce: function setTimestampAndNonce(message) {
        OAuth.setParameter(message, &quot;oauth_timestamp&quot;, OAuth.timestamp());
        OAuth.setParameter(message, &quot;oauth_nonce&quot;, OAuth.nonce(6));
    }
,
    addToURL: function addToURL(url, parameters) {
        newURL = url;
        if (parameters != null) {
            var toAdd = OAuth.formEncode(parameters);
            if (toAdd.length &gt; 0) {
                var q = url.indexOf(&apos;?&apos;);
                if (q &lt; 0) newURL += &apos;?&apos;;
                else       newURL += &apos;&amp;&apos;;
                newURL += toAdd;
            }
        }
        return newURL;
    }
,
    /** Construct the value of the Authorization header for an HTTP request. */
    getAuthorizationHeader: function getAuthorizationHeader(realm, parameters) {
        var header = &apos;OAuth realm=&quot;&apos; + OAuth.percentEncode(realm) + &apos;&quot;&apos;;
        var list = OAuth.getParameterList(parameters);
        for (var p = 0; p &lt; list.length; ++p) {
            var parameter = list[p];
            var name = parameter[0];
            if (name.indexOf(&quot;oauth_&quot;) == 0) {
                header += &apos;,&apos; + OAuth.percentEncode(name) + &apos;=&quot;&apos; + OAuth.percentEncode(parameter[1]) + &apos;&quot;&apos;;
            }
        }
        return header;
    }
,
    /** Correct the time using a parameter from the URL from which the last script was loaded. */
    correctTimestampFromSrc: function correctTimestampFromSrc(parameterName) {
        parameterName = parameterName || &quot;oauth_timestamp&quot;;
        var scripts = document.getElementsByTagName(&apos;script&apos;);
        if (scripts == null || !scripts.length) return;
        var src = scripts[scripts.length-1].src;
        if (!src) return;
        var q = src.indexOf(&quot;?&quot;);
        if (q &lt; 0) return;
        parameters = OAuth.getParameterMap(OAuth.decodeForm(src.substring(q+1)));
        var t = parameters[parameterName];
        if (t == null) return;
        OAuth.correctTimestamp(t);
    }
,
    /** Generate timestamps starting with the given value. */
    correctTimestamp: function correctTimestamp(timestamp) {
        OAuth.timeCorrectionMsec = (timestamp * 1000) - (new Date()).getTime();
    }
,
    /** The difference between the correct time and my clock. */
    timeCorrectionMsec: 0
,
    timestamp: function timestamp() {
        var t = (new Date()).getTime() + OAuth.timeCorrectionMsec;
        return Math.floor(t / 1000);
    }
,
    nonce: function nonce(length) {
        var chars = OAuth.nonce.CHARS;
        var result = &quot;&quot;;
        for (var i = 0; i &lt; length; ++i) {
            var rnum = Math.floor(Math.random() * chars.length);
            result += chars.substring(rnum, rnum+1);
        }
        return result;
    }
});

OAuth.nonce.CHARS = &quot;0123456789ABCDEFGHIJKLMNOPQRSTUVWXTZabcdefghiklmnopqrstuvwxyz&quot;;

/** Define a constructor function,
    without causing trouble to anyone who was using it as a namespace.
    That is, if parent[name] already existed and had properties,
    copy those properties into the new constructor.
 */
OAuth.declareClass = function declareClass(parent, name, newConstructor) {
    var previous = parent[name];
    parent[name] = newConstructor;
    if (newConstructor != null &amp;&amp; previous != null) {
        for (var key in previous) {
            if (key != &quot;prototype&quot;) {
                newConstructor[key] = previous[key];
            }
        }
    }
    return newConstructor;
}

/** An abstract algorithm for signing messages. */
OAuth.declareClass(OAuth, &quot;SignatureMethod&quot;, function OAuthSignatureMethod(){});

OAuth.setProperties(OAuth.SignatureMethod.prototype, // instance members
{
    /** Add a signature to the message. */
    sign: function sign(message) {
        var baseString = OAuth.SignatureMethod.getBaseString(message);
        var signature = this.getSignature(baseString);
        OAuth.setParameter(message, &quot;oauth_signature&quot;, signature);
        return signature; // just in case someone&apos;s interested
    }
,
    /** Set the key string for signing. */
    initialize: function initialize(name, accessor) {
        var consumerSecret;
        if (accessor.accessorSecret != null
            &amp;&amp; name.length &gt; 9
            &amp;&amp; name.substring(name.length-9) == &quot;-Accessor&quot;)
        {
            consumerSecret = accessor.accessorSecret;
        } else {
            consumerSecret = accessor.consumerSecret;
        }
        this.key = OAuth.percentEncode(consumerSecret)
             +&quot;&amp;&quot;+ OAuth.percentEncode(accessor.tokenSecret);
    }
});

/* SignatureMethod expects an accessor object to be like this:
   {tokenSecret: &quot;lakjsdflkj...&quot;, consumerSecret: &quot;QOUEWRI..&quot;, accessorSecret: &quot;xcmvzc...&quot;}
   The accessorSecret property is optional.
 */
// Class members:
OAuth.setProperties(OAuth.SignatureMethod, // class members
{
    sign: function sign(message, accessor) {
        var name = OAuth.getParameterMap(message.parameters).oauth_signature_method;
        if (name == null || name == &quot;&quot;) {
            name = &quot;HMAC-SHA1&quot;;
            OAuth.setParameter(message, &quot;oauth_signature_method&quot;, name);
        }
        OAuth.SignatureMethod.newMethod(name, accessor).sign(message);
    }
,
    /** Instantiate a SignatureMethod for the given method name. */
    newMethod: function newMethod(name, accessor) {
        var impl = OAuth.SignatureMethod.REGISTERED[name];
        if (impl != null) {
            var method = new impl();
            method.initialize(name, accessor);
            return method;
        }
        var err = new Error(&quot;signature_method_rejected&quot;);
        var acceptable = &quot;&quot;;
        for (var r in OAuth.SignatureMethod.REGISTERED) {
            if (acceptable != &quot;&quot;) acceptable += &apos;&amp;&apos;;
            acceptable += OAuth.percentEncode(r);
        }
        err.oauth_acceptable_signature_methods = acceptable;
        throw err;
    }
,
    /** A map from signature method name to constructor. */
    REGISTERED : {}
,
    /** Subsequently, the given constructor will be used for the named methods.
        The constructor will be called with no parameters.
        The resulting object should usually implement getSignature(baseString).
        You can easily define such a constructor by calling makeSubclass, below.
     */
    registerMethodClass: function registerMethodClass(names, classConstructor) {
        for (var n = 0; n &lt; names.length; ++n) {
            OAuth.SignatureMethod.REGISTERED[names[n]] = classConstructor;
        }
    }
,
    /** Create a subclass of OAuth.SignatureMethod, with the given getSignature function. */
    makeSubclass: function makeSubclass(getSignatureFunction) {
        var superClass = OAuth.SignatureMethod;
        var subClass = function() {
            superClass.call(this);
        };
        subClass.prototype = new superClass();
        // Delete instance variables from prototype:
        // delete subclass.prototype... There aren&apos;t any.
        subClass.prototype.getSignature = getSignatureFunction;
        subClass.prototype.constructor = subClass;
        return subClass;
    }
,
    getBaseString: function getBaseString(message) {
        var URL = message.action;
        var q = URL.indexOf(&apos;?&apos;);
        var parameters;
        if (q &lt; 0) {
            parameters = message.parameters;
        } else {
            // Combine the URL query string with the other parameters:
            parameters = OAuth.decodeForm(URL.substring(q + 1));
            var toAdd = OAuth.getParameterList(message.parameters);
            for (var a = 0; a &lt; toAdd.length; ++a) {
                parameters.push(toAdd[a]);
            }
        }
        return OAuth.percentEncode(message.method.toUpperCase())
         +&apos;&amp;&apos;+ OAuth.percentEncode(OAuth.SignatureMethod.normalizeUrl(URL))
         +&apos;&amp;&apos;+ OAuth.percentEncode(OAuth.SignatureMethod.normalizeParameters(parameters));
    }
,
    normalizeUrl: function normalizeUrl(url) {
        var uri = OAuth.SignatureMethod.parseUri(url);
        var scheme = uri.protocol.toLowerCase();
        var authority = uri.authority.toLowerCase();
        var dropPort = (scheme == &quot;http&quot; &amp;&amp; uri.port == 80)
                    || (scheme == &quot;https&quot; &amp;&amp; uri.port == 443);
        if (dropPort) {
            // find the last : in the authority
            var index = authority.lastIndexOf(&quot;:&quot;);
            if (index &gt;= 0) {
                authority = authority.substring(0, index);
            }
        }
        var path = uri.path;
        if (!path) {
            path = &quot;/&quot;; // conforms to RFC 2616 section 3.2.2
        }
        // we know that there is no query and no fragment here.
        return scheme + &quot;://&quot; + authority + path;
    }
,
    parseUri: function parseUri (str) {
        /* This function was adapted from parseUri 1.2.1
           http://stevenlevithan.com/demo/parseuri/js/assets/parseuri.js
         */
        var o = {key: [&quot;source&quot;,&quot;protocol&quot;,&quot;authority&quot;,&quot;userInfo&quot;,&quot;user&quot;,&quot;password&quot;,&quot;host&quot;,&quot;port&quot;,&quot;relative&quot;,&quot;path&quot;,&quot;directory&quot;,&quot;file&quot;,&quot;query&quot;,&quot;anchor&quot;],
                 parser: {strict: /^(?:([^:\/?#]+):)?(?:\/\/((?:(([^:@\/]*):?([^:@\/]*))?@)?([^:\/?#]*)(?::(\d*))?))?((((?:[^?#\/]*\/)*)([^?#]*))(?:\?([^#]*))?(?:#(.*))?)/ }};
        var m = o.parser.strict.exec(str);
        var uri = {};
        var i = 14;
        while (i--) uri[o.key[i]] = m[i] || &quot;&quot;;
        return uri;
    }
,
    normalizeParameters: function normalizeParameters(parameters) {
        if (parameters == null) {
            return &quot;&quot;;
        }
        var list = OAuth.getParameterList(parameters);
        var sortable = [];
        for (var p = 0; p &lt; list.length; ++p) {
            var nvp = list[p];
            if (nvp[0] != &quot;oauth_signature&quot;) {
                sortable.push([ OAuth.percentEncode(nvp[0])
                              + &quot; &quot; // because it comes before any character that can appear in a percentEncoded string.
                              + OAuth.percentEncode(nvp[1])
                              , nvp]);
            }
        }
        sortable.sort(function(a,b) {
                          if (a[0] &lt; b[0]) return  -1;
                          if (a[0] &gt; b[0]) return 1;
                          return 0;
                      });
        var sorted = [];
        for (var s = 0; s &lt; sortable.length; ++s) {
            sorted.push(sortable[s][1]);
        }
        return OAuth.formEncode(sorted);
    }
});

OAuth.SignatureMethod.registerMethodClass([&quot;PLAINTEXT&quot;, &quot;PLAINTEXT-Accessor&quot;],
    OAuth.SignatureMethod.makeSubclass(
        function getSignature(baseString) {
            return this.key;
        }
    ));

OAuth.SignatureMethod.registerMethodClass([&quot;HMAC-SHA1&quot;, &quot;HMAC-SHA1-Accessor&quot;],
    OAuth.SignatureMethod.makeSubclass(
        function getSignature(baseString) {
            b64pad = &apos;=&apos;;
            var signature = b64_hmac_sha1(this.key, baseString);
            return signature;
        }
    ));

try {
    OAuth.correctTimestampFromSrc();
} catch(e) {
}


//--------------------------------------------------

var consumerKey = &quot;${consumer_key}&quot;;
var consumerSecret = &quot;&quot;;
var params = [];
var query = [];
query.push(&apos;access_token&apos; + &apos;=&apos; + &apos;${access_token}&apos;);
query.push(&apos;id_token&apos; + &apos;=&apos; + &apos;${id_token}&apos;);
var url =  &quot;${protocol}://${misp_url}/marvelous/people/@me/@self&quot;;

if (query.length) {
    url += &apos;?&apos; + query.join(&apos;&amp;&apos;);
}

var message = {
    method: &apos;put&apos;,
    parameters: params, 
    action: url
};

log.info(url);
log.info(consumerSecret);

var accessor = {
    consumerKey: consumerKey,
    consumerSecret: consumerSecret,
    token:  &apos;${access_token}&apos;,
    tokenSecret: &apos;${id_token}&apos;
};

OAuth.completeRequest(message, accessor);
vars.put(&apos;put_auth_header&apos;, OAuth.getAuthorizationHeader(&apos;&apos;, params).replace(&apos;OAuth realm=&quot;&quot;,&apos;, &apos; OAuth &apos;));
</stringProp>
            <stringProp name="scriptLanguage">javascript</stringProp>
          </BSFPreProcessor>
          <hashTree/>
          <HeaderManager guiclass="HeaderPanel" testclass="HeaderManager" testname="HTTP ヘッダマネージャ" enabled="true">
            <collectionProp name="HeaderManager.headers">
              <elementProp name="" elementType="Header">
                <stringProp name="Header.name">Authorization</stringProp>
                <stringProp name="Header.value">${put_auth_header}</stringProp>
              </elementProp>
              <elementProp name="" elementType="Header">
                <stringProp name="Header.name">content-type</stringProp>
                <stringProp name="Header.value">application/json; charset=utf8</stringProp>
              </elementProp>
              <elementProp name="" elementType="Header">
                <stringProp name="Header.name">Connection</stringProp>
                <stringProp name="Header.value">close</stringProp>
              </elementProp>
              <elementProp name="" elementType="Header">
                <stringProp name="Header.name">Accept-encoding</stringProp>
                <stringProp name="Header.value">gzip, deflate</stringProp>
              </elementProp>
            </collectionProp>
          </HeaderManager>
          <hashTree/>
          <BSFAssertion guiclass="TestBeanGUI" testclass="BSFAssertion" testname="レスポンスコード401" enabled="true">
            <stringProp name="filename"></stringProp>
            <stringProp name="parameters"></stringProp>
            <stringProp name="script">if (prev.getResponseCode() == &quot;401&quot;) {
	AssertionResult.setFailure(false);
	prev.setSuccessful(true);
} else {
	AssertionResult.setFailure(true);
}</stringProp>
            <stringProp name="scriptLanguage">javascript</stringProp>
          </BSFAssertion>
          <hashTree/>
        </hashTree>
        <HTTPSamplerProxy guiclass="HttpTestSampleGui" testclass="HTTPSamplerProxy" testname="Implicit.ユーザ更新エラー(ヘッダなし)" enabled="true">
          <boolProp name="HTTPSampler.postBodyRaw">true</boolProp>
          <elementProp name="HTTPsampler.Arguments" elementType="Arguments">
            <collectionProp name="Arguments.arguments">
              <elementProp name="" elementType="HTTPArgument">
                <boolProp name="HTTPArgument.always_encode">false</boolProp>
                <stringProp name="Argument.value">{&#xd;
  &quot;entry&quot;: [&#xd;
    {&#xd;
      &quot;apps&quot;: [&#xd;
        {&#xd;
          &quot;value&quot;: {&#xd;
            &quot;appId&quot;: &quot;00000&quot;,&#xd;
            &quot;userId&quot;: &quot;proxy_test_3&quot;&#xd;
          }&#xd;
        }&#xd;
      ]&#xd;
    }&#xd;
  ]&#xd;
}</stringProp>
                <stringProp name="Argument.metadata">=</stringProp>
              </elementProp>
            </collectionProp>
          </elementProp>
          <stringProp name="HTTPSampler.domain"></stringProp>
          <stringProp name="HTTPSampler.port"></stringProp>
          <stringProp name="HTTPSampler.connect_timeout"></stringProp>
          <stringProp name="HTTPSampler.response_timeout"></stringProp>
          <stringProp name="HTTPSampler.protocol"></stringProp>
          <stringProp name="HTTPSampler.contentEncoding"></stringProp>
          <stringProp name="HTTPSampler.path">/marvelous/people/@me/@self?access_token=${access_token}&amp;id_token=${id_token}</stringProp>
          <stringProp name="HTTPSampler.method">PUT</stringProp>
          <boolProp name="HTTPSampler.follow_redirects">true</boolProp>
          <boolProp name="HTTPSampler.auto_redirects">false</boolProp>
          <boolProp name="HTTPSampler.use_keepalive">true</boolProp>
          <boolProp name="HTTPSampler.DO_MULTIPART_POST">false</boolProp>
          <boolProp name="HTTPSampler.monitor">false</boolProp>
          <stringProp name="HTTPSampler.embedded_url_re"></stringProp>
        </HTTPSamplerProxy>
        <hashTree>
          <BSFAssertion guiclass="TestBeanGUI" testclass="BSFAssertion" testname="レスポンスコード400" enabled="true">
            <stringProp name="filename"></stringProp>
            <stringProp name="parameters"></stringProp>
            <stringProp name="script">if (prev.getResponseCode() == &quot;400&quot;) {
	AssertionResult.setFailure(false);
	prev.setSuccessful(true);
} else {
	AssertionResult.setFailure(true);
}</stringProp>
            <stringProp name="scriptLanguage">javascript</stringProp>
          </BSFAssertion>
          <hashTree/>
        </hashTree>
        <HTTPSamplerProxy guiclass="HttpTestSampleGui" testclass="HTTPSamplerProxy" testname="Implicit.ユーザ取得エラー(ヘッダなし)" enabled="true">
          <elementProp name="HTTPsampler.Arguments" elementType="Arguments" guiclass="HTTPArgumentsPanel" testclass="Arguments" enabled="true">
            <collectionProp name="Arguments.arguments">
              <elementProp name="access_token" elementType="HTTPArgument">
                <boolProp name="HTTPArgument.always_encode">false</boolProp>
                <stringProp name="Argument.name">access_token</stringProp>
                <stringProp name="Argument.value">${access_token}</stringProp>
                <stringProp name="Argument.metadata">=</stringProp>
                <boolProp name="HTTPArgument.use_equals">true</boolProp>
              </elementProp>
              <elementProp name="id_token" elementType="HTTPArgument">
                <boolProp name="HTTPArgument.always_encode">false</boolProp>
                <stringProp name="Argument.name">id_token</stringProp>
                <stringProp name="Argument.value">${id_token}</stringProp>
                <stringProp name="Argument.metadata">=</stringProp>
                <boolProp name="HTTPArgument.use_equals">true</boolProp>
              </elementProp>
            </collectionProp>
          </elementProp>
          <stringProp name="HTTPSampler.domain"></stringProp>
          <stringProp name="HTTPSampler.port"></stringProp>
          <stringProp name="HTTPSampler.connect_timeout"></stringProp>
          <stringProp name="HTTPSampler.response_timeout"></stringProp>
          <stringProp name="HTTPSampler.protocol"></stringProp>
          <stringProp name="HTTPSampler.contentEncoding"></stringProp>
          <stringProp name="HTTPSampler.path">/marvelous/people/@me/@self</stringProp>
          <stringProp name="HTTPSampler.method">GET</stringProp>
          <boolProp name="HTTPSampler.follow_redirects">true</boolProp>
          <boolProp name="HTTPSampler.auto_redirects">false</boolProp>
          <boolProp name="HTTPSampler.use_keepalive">true</boolProp>
          <boolProp name="HTTPSampler.DO_MULTIPART_POST">false</boolProp>
          <boolProp name="HTTPSampler.monitor">false</boolProp>
          <stringProp name="HTTPSampler.embedded_url_re"></stringProp>
          <stringProp name="TestPlan.comments">Detected the start of a redirect chain</stringProp>
        </HTTPSamplerProxy>
        <hashTree>
          <BSFAssertion guiclass="TestBeanGUI" testclass="BSFAssertion" testname="レスポンスコード400" enabled="true">
            <stringProp name="filename"></stringProp>
            <stringProp name="parameters"></stringProp>
            <stringProp name="script">if (prev.getResponseCode() == &quot;400&quot;) {
	AssertionResult.setFailure(false);
	prev.setSuccessful(true);
} else {
	AssertionResult.setFailure(true);
}</stringProp>
            <stringProp name="scriptLanguage">javascript</stringProp>
          </BSFAssertion>
          <hashTree/>
        </hashTree>
        <HTTPSamplerProxy guiclass="HttpTestSampleGui" testclass="HTTPSamplerProxy" testname="Implicit.ユーザ取得" enabled="true">
          <elementProp name="HTTPsampler.Arguments" elementType="Arguments" guiclass="HTTPArgumentsPanel" testclass="Arguments" enabled="true">
            <collectionProp name="Arguments.arguments">
              <elementProp name="access_token" elementType="HTTPArgument">
                <boolProp name="HTTPArgument.always_encode">false</boolProp>
                <stringProp name="Argument.value">${access_token}</stringProp>
                <stringProp name="Argument.metadata">=</stringProp>
                <boolProp name="HTTPArgument.use_equals">true</boolProp>
                <stringProp name="Argument.name">access_token</stringProp>
              </elementProp>
              <elementProp name="id_token" elementType="HTTPArgument">
                <boolProp name="HTTPArgument.always_encode">false</boolProp>
                <stringProp name="Argument.value">${id_token}</stringProp>
                <stringProp name="Argument.metadata">=</stringProp>
                <boolProp name="HTTPArgument.use_equals">true</boolProp>
                <stringProp name="Argument.name">id_token</stringProp>
              </elementProp>
            </collectionProp>
          </elementProp>
          <stringProp name="HTTPSampler.domain"></stringProp>
          <stringProp name="HTTPSampler.port"></stringProp>
          <stringProp name="HTTPSampler.connect_timeout"></stringProp>
          <stringProp name="HTTPSampler.response_timeout"></stringProp>
          <stringProp name="HTTPSampler.protocol"></stringProp>
          <stringProp name="HTTPSampler.contentEncoding"></stringProp>
          <stringProp name="HTTPSampler.path">/marvelous/people/@me/@self</stringProp>
          <stringProp name="HTTPSampler.method">GET</stringProp>
          <boolProp name="HTTPSampler.follow_redirects">true</boolProp>
          <boolProp name="HTTPSampler.auto_redirects">false</boolProp>
          <boolProp name="HTTPSampler.use_keepalive">true</boolProp>
          <boolProp name="HTTPSampler.DO_MULTIPART_POST">false</boolProp>
          <boolProp name="HTTPSampler.monitor">false</boolProp>
          <stringProp name="HTTPSampler.embedded_url_re"></stringProp>
        </HTTPSamplerProxy>
        <hashTree>
          <BSFPreProcessor guiclass="TestBeanGUI" testclass="BSFPreProcessor" testname="BSF PreProcessor" enabled="true">
            <stringProp name="filename"></stringProp>
            <stringProp name="parameters"></stringProp>
            <stringProp name="script">/*
 * A JavaScript implementation of the Secure Hash Algorithm, SHA-1, as defined
 * in FIPS PUB 180-1
 * Version 2.1a Copyright Paul Johnston 2000 - 2002.
 * Other contributors: Greg Holt, Andrew Kepert, Ydnar, Lostinet
 * Distributed under the BSD License
 * See http://pajhome.org.uk/crypt/md5 for details.
 */

/*
 * Configurable variables. You may need to tweak these to be compatible with
 * the server-side, but the defaults work in most cases.
 */
var hexcase = 0;  /* hex output format. 0 - lowercase; 1 - uppercase        */
var b64pad  = &quot;&quot;; /* base-64 pad character. &quot;=&quot; for strict RFC compliance   */
var chrsz   = 8;  /* bits per input character. 8 - ASCII; 16 - Unicode      */

/*
 * These are the functions you&apos;ll usually want to call
 * They take string arguments and return either hex or base-64 encoded strings
 */
function hex_sha1(s){return binb2hex(core_sha1(str2binb(s),s.length * chrsz));}
function b64_sha1(s){return binb2b64(core_sha1(str2binb(s),s.length * chrsz));}
function str_sha1(s){return binb2str(core_sha1(str2binb(s),s.length * chrsz));}
function hex_hmac_sha1(key, data){ return binb2hex(core_hmac_sha1(key, data));}
function b64_hmac_sha1(key, data){ return binb2b64(core_hmac_sha1(key, data));}
function str_hmac_sha1(key, data){ return binb2str(core_hmac_sha1(key, data));}

/*
 * Perform a simple self-test to see if the VM is working
 */
function sha1_vm_test()
{
  return hex_sha1(&quot;abc&quot;) == &quot;a9993e364706816aba3e25717850c26c9cd0d89d&quot;;
}

/*
 * Calculate the SHA-1 of an array of big-endian words, and a bit length
 */
function core_sha1(x, len)
{
  /* append padding */
  x[len &gt;&gt; 5] |= 0x80 &lt;&lt; (24 - len % 32);
  x[((len + 64 &gt;&gt; 9) &lt;&lt; 4) + 15] = len;

  var w = Array(80);
  var a =  1732584193;
  var b = -271733879;
  var c = -1732584194;
  var d =  271733878;
  var e = -1009589776;

  for(var i = 0; i &lt; x.length; i += 16)
  {
    var olda = a;
    var oldb = b;
    var oldc = c;
    var oldd = d;
    var olde = e;

    for(var j = 0; j &lt; 80; j++)
    {
      if(j &lt; 16) w[j] = x[i + j];
      else w[j] = rol(w[j-3] ^ w[j-8] ^ w[j-14] ^ w[j-16], 1);
      var t = safe_add(safe_add(rol(a, 5), sha1_ft(j, b, c, d)),
                       safe_add(safe_add(e, w[j]), sha1_kt(j)));
      e = d;
      d = c;
      c = rol(b, 30);
      b = a;
      a = t;
    }

    a = safe_add(a, olda);
    b = safe_add(b, oldb);
    c = safe_add(c, oldc);
    d = safe_add(d, oldd);
    e = safe_add(e, olde);
  }
  return Array(a, b, c, d, e);

}

/*
 * Perform the appropriate triplet combination function for the current
 * iteration
 */
function sha1_ft(t, b, c, d)
{
  if(t &lt; 20) return (b &amp; c) | ((~b) &amp; d);
  if(t &lt; 40) return b ^ c ^ d;
  if(t &lt; 60) return (b &amp; c) | (b &amp; d) | (c &amp; d);
  return b ^ c ^ d;
}

/*
 * Determine the appropriate additive constant for the current iteration
 */
function sha1_kt(t)
{
  return (t &lt; 20) ?  1518500249 : (t &lt; 40) ?  1859775393 :
         (t &lt; 60) ? -1894007588 : -899497514;
}

/*
 * Calculate the HMAC-SHA1 of a key and some data
 */
function core_hmac_sha1(key, data)
{
  var bkey = str2binb(key);
  if(bkey.length &gt; 16) bkey = core_sha1(bkey, key.length * chrsz);

  var ipad = Array(16), opad = Array(16);
  for(var i = 0; i &lt; 16; i++)
  {
    ipad[i] = bkey[i] ^ 0x36363636;
    opad[i] = bkey[i] ^ 0x5C5C5C5C;
  }

  var hash = core_sha1(ipad.concat(str2binb(data)), 512 + data.length * chrsz);
  return core_sha1(opad.concat(hash), 512 + 160);
}

/*
 * Add integers, wrapping at 2^32. This uses 16-bit operations internally
 * to work around bugs in some JS interpreters.
 */
function safe_add(x, y)
{
  var lsw = (x &amp; 0xFFFF) + (y &amp; 0xFFFF);
  var msw = (x &gt;&gt; 16) + (y &gt;&gt; 16) + (lsw &gt;&gt; 16);
  return (msw &lt;&lt; 16) | (lsw &amp; 0xFFFF);
}

/*
 * Bitwise rotate a 32-bit number to the left.
 */
function rol(num, cnt)
{
  return (num &lt;&lt; cnt) | (num &gt;&gt;&gt; (32 - cnt));
}

/*
 * Convert an 8-bit or 16-bit string to an array of big-endian words
 * In 8-bit function, characters &gt;255 have their hi-byte silently ignored.
 */
function str2binb(str)
{
  var bin = Array();
  var mask = (1 &lt;&lt; chrsz) - 1;
  for(var i = 0; i &lt; str.length * chrsz; i += chrsz)
    bin[i&gt;&gt;5] |= (str.charCodeAt(i / chrsz) &amp; mask) &lt;&lt; (32 - chrsz - i%32);
  return bin;
}

/*
 * Convert an array of big-endian words to a string
 */
function binb2str(bin)
{
  var str = &quot;&quot;;
  var mask = (1 &lt;&lt; chrsz) - 1;
  for(var i = 0; i &lt; bin.length * 32; i += chrsz)
    str += String.fromCharCode((bin[i&gt;&gt;5] &gt;&gt;&gt; (32 - chrsz - i%32)) &amp; mask);
  return str;
}

/*
 * Convert an array of big-endian words to a hex string.
 */
function binb2hex(binarray)
{
  var hex_tab = hexcase ? &quot;0123456789ABCDEF&quot; : &quot;0123456789abcdef&quot;;
  var str = &quot;&quot;;
  for(var i = 0; i &lt; binarray.length * 4; i++)
  {
    str += hex_tab.charAt((binarray[i&gt;&gt;2] &gt;&gt; ((3 - i%4)*8+4)) &amp; 0xF) +
           hex_tab.charAt((binarray[i&gt;&gt;2] &gt;&gt; ((3 - i%4)*8  )) &amp; 0xF);
  }
  return str;
}

/*
 * Convert an array of big-endian words to a base-64 string
 */
function binb2b64(binarray)
{
  var tab = &quot;ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/&quot;;
  var str = &quot;&quot;;
  for(var i = 0; i &lt; binarray.length * 4; i += 3)
  {
    var triplet = (((binarray[i   &gt;&gt; 2] &gt;&gt; 8 * (3 -  i   %4)) &amp; 0xFF) &lt;&lt; 16)
                | (((binarray[i+1 &gt;&gt; 2] &gt;&gt; 8 * (3 - (i+1)%4)) &amp; 0xFF) &lt;&lt; 8 )
                |  ((binarray[i+2 &gt;&gt; 2] &gt;&gt; 8 * (3 - (i+2)%4)) &amp; 0xFF);
    for(var j = 0; j &lt; 4; j++)
    {
      if(i * 8 + j * 6 &gt; binarray.length * 32) str += b64pad;
      else str += tab.charAt((triplet &gt;&gt; 6*(3-j)) &amp; 0x3F);
    }
  }
  return str;
}

/*
 * Copyright 2008 Netflix, Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/* Here&apos;s some JavaScript software for implementing OAuth.

   This isn&apos;t as useful as you might hope.  OAuth is based around
   allowing tools and websites to talk to each other.  However,
   JavaScript running in web browsers is hampered by security
   restrictions that prevent code running on one website from
   accessing data stored or served on another.

   Before you start hacking, make sure you understand the limitations
   posed by cross-domain XMLHttpRequest.

   On the bright side, some platforms use JavaScript as their
   language, but enable the programmer to access other web sites.
   Examples include Google Gadgets, and Microsoft Vista Sidebar.
   For those platforms, this library should come in handy.
*/

// The HMAC-SHA1 signature method calls b64_hmac_sha1, defined by
// http://pajhome.org.uk/crypt/md5/sha1.js

/* An OAuth message is represented as an object like this:
   {method: &quot;GET&quot;, action: &quot;http://server.com/path&quot;, parameters: ...}

   The parameters may be either a map {name: value, name2: value2}
   or an Array of name-value pairs [[name, value], [name2, value2]].
   The latter representation is more powerful: it supports parameters
   in a specific sequence, or several parameters with the same name;
   for example [[&quot;a&quot;, 1], [&quot;b&quot;, 2], [&quot;a&quot;, 3]].

   Parameter names and values are NOT percent-encoded in an object.
   They must be encoded before transmission and decoded after reception.
   For example, this message object:
   {method: &quot;GET&quot;, action: &quot;http://server/path&quot;, parameters: {p: &quot;x y&quot;}}
   ... can be transmitted as an HTTP request that begins:
   GET /path?p=x%20y HTTP/1.0
   (This isn&apos;t a valid OAuth request, since it lacks a signature etc.)
   Note that the object &quot;x y&quot; is transmitted as x%20y.  To encode
   parameters, you can call OAuth.addToURL, OAuth.formEncode or
   OAuth.getAuthorization.

   This message object model harmonizes with the browser object model for
   input elements of an form, whose value property isn&apos;t percent encoded.
   The browser encodes each value before transmitting it. For example,
   see consumer.setInputs in example/consumer.js.
 */

/* This script needs to know what time it is. By default, it uses the local
   clock (new Date), which is apt to be inaccurate in browsers. To do
   better, you can load this script from a URL whose query string contains
   an oauth_timestamp parameter, whose value is a current Unix timestamp.
   For example, when generating the enclosing document using PHP:

   &lt;script src=&quot;oauth.js?oauth_timestamp=&lt;?=time()?&gt;&quot; ...

   Another option is to call OAuth.correctTimestamp with a Unix timestamp.
 */

var OAuth; if (OAuth == null) OAuth = {};

OAuth.setProperties = function setProperties(into, from) {
    if (into != null &amp;&amp; from != null) {
        for (var key in from) {
            into[key] = from[key];
        }
    }
    return into;
}

OAuth.setProperties(OAuth, // utility functions
{
    percentEncode: function percentEncode(s) {
        if (s == null) {
            return &quot;&quot;;
        }
        if (s instanceof Array) {
            var e = &quot;&quot;;
            for (var i = 0; i &lt; s.length; ++s) {
                if (e != &quot;&quot;) e += &apos;&amp;&apos;;
                e += OAuth.percentEncode(s[i]);
            }
            return e;
        }
        s = encodeURIComponent(s);
        // Now replace the values which encodeURIComponent doesn&apos;t do
        // encodeURIComponent ignores: - _ . ! ~ * &apos; ( )
        // OAuth dictates the only ones you can ignore are: - _ . ~
        // Source: http://developer.mozilla.org/en/docs/Core_JavaScript_1.5_Reference:Global_Functions:encodeURIComponent
        s = s.replace(/\!/g, &quot;%21&quot;);
        s = s.replace(/\*/g, &quot;%2A&quot;);
        s = s.replace(/\&apos;/g, &quot;%27&quot;);
        s = s.replace(/\(/g, &quot;%28&quot;);
        s = s.replace(/\)/g, &quot;%29&quot;);
        return s;
    }
,
    decodePercent: function decodePercent(s) {
        if (s != null) {
            // Handle application/x-www-form-urlencoded, which is defined by
            // http://www.w3.org/TR/html4/interact/forms.html#h-17.13.4.1
            s = s.replace(/\+/g, &quot; &quot;);
        }
        return decodeURIComponent(s);
    }
,
    /** Convert the given parameters to an Array of name-value pairs. */
    getParameterList: function getParameterList(parameters) {
        if (parameters == null) {
            return [];
        }
        if (typeof parameters != &quot;object&quot;) {
            return OAuth.decodeForm(parameters + &quot;&quot;);
        }
        if (parameters instanceof Array) {
            return parameters;
        }
        var list = [];
        for (var p in parameters) {
            list.push([p, parameters[p]]);
        }
        return list;
    }
,
    /** Convert the given parameters to a map from name to value. */
    getParameterMap: function getParameterMap(parameters) {
        if (parameters == null) {
            return {};
        }
        if (typeof parameters != &quot;object&quot;) {
            return OAuth.getParameterMap(OAuth.decodeForm(parameters + &quot;&quot;));
        }
        if (parameters instanceof Array) {
            var map = {};
            for (var p = 0; p &lt; parameters.length; ++p) {
                var key = parameters[p][0];
                if (map[key] === undefined) { // first value wins
                    map[key] = parameters[p][1];
                }
            }
            return map;
        }
        return parameters;
    }
,
    getParameter: function getParameter(parameters, name) {
        if (parameters instanceof Array) {
            for (var p = 0; p &lt; parameters.length; ++p) {
                if (parameters[p][0] == name) {
                    return parameters[p][1]; // first value wins
                }
            }
        } else {
            return OAuth.getParameterMap(parameters)[name];
        }
        return null;
    }
,
    formEncode: function formEncode(parameters) {
        var form = &quot;&quot;;
        var list = OAuth.getParameterList(parameters);
        for (var p = 0; p &lt; list.length; ++p) {
            var value = list[p][1];
            if (value == null) value = &quot;&quot;;
            if (form != &quot;&quot;) form += &apos;&amp;&apos;;
            form += OAuth.percentEncode(list[p][0])
              +&apos;=&apos;+ OAuth.percentEncode(value);
        }
        return form;
    }
,
    decodeForm: function decodeForm(form) {
        var list = [];
        var nvps = form.split(&apos;&amp;&apos;);
        for (var n = 0; n &lt; nvps.length; ++n) {
            var nvp = nvps[n];
            if (nvp == &quot;&quot;) {
                continue;
            }
            var equals = nvp.indexOf(&apos;=&apos;);
            var name;
            var value;
            if (equals &lt; 0) {
                name = OAuth.decodePercent(nvp);
                value = null;
            } else {
                name = OAuth.decodePercent(nvp.substring(0, equals));
                value = OAuth.decodePercent(nvp.substring(equals + 1));
            }
            list.push([name, value]);
        }
        return list;
    }
,
    setParameter: function setParameter(message, name, value) {
        var parameters = message.parameters;
        if (parameters instanceof Array) {
            for (var p = 0; p &lt; parameters.length; ++p) {
                if (parameters[p][0] == name) {
                    if (value === undefined) {
                        parameters.splice(p, 1);
                    } else {
                        parameters[p][1] = value;
                        value = undefined;
                    }
                }
            }
            if (value !== undefined) {
                parameters.push([name, value]);
            }
        } else {
            parameters = OAuth.getParameterMap(parameters);
            parameters[name] = value;
            message.parameters = parameters;
        }
    }
,
    setParameters: function setParameters(message, parameters) {
        var list = OAuth.getParameterList(parameters);
        for (var i = 0; i &lt; list.length; ++i) {
            OAuth.setParameter(message, list[i][0], list[i][1]);
        }
    }
,
    /** Fill in parameters to help construct a request message.
        This function doesn&apos;t fill in every parameter.
        The accessor object should be like:
        {consumerKey:&apos;foo&apos;, consumerSecret:&apos;bar&apos;, accessorSecret:&apos;nurn&apos;, token:&apos;krelm&apos;, tokenSecret:&apos;blah&apos;}
        The accessorSecret property is optional.
     */
    completeRequest: function completeRequest(message, accessor) {
        if (message.method == null) {
            message.method = &quot;GET&quot;;
        }
        var map = OAuth.getParameterMap(message.parameters);
        if (map.oauth_consumer_key == null) {
            OAuth.setParameter(message, &quot;oauth_consumer_key&quot;, accessor.consumerKey || &quot;&quot;);
        }
        if (map.oauth_token == null &amp;&amp; accessor.token != null) {
            OAuth.setParameter(message, &quot;oauth_token&quot;, accessor.token);
        }
        if (map.oauth_version == null) {
            OAuth.setParameter(message, &quot;oauth_version&quot;, &quot;1.0&quot;);
        }
        if (map.oauth_timestamp == null) {
            OAuth.setParameter(message, &quot;oauth_timestamp&quot;, OAuth.timestamp());
        }
        if (map.oauth_nonce == null) {
            OAuth.setParameter(message, &quot;oauth_nonce&quot;, OAuth.nonce(6));
        }
        OAuth.SignatureMethod.sign(message, accessor);
    }
,
    setTimestampAndNonce: function setTimestampAndNonce(message) {
        OAuth.setParameter(message, &quot;oauth_timestamp&quot;, OAuth.timestamp());
        OAuth.setParameter(message, &quot;oauth_nonce&quot;, OAuth.nonce(6));
    }
,
    addToURL: function addToURL(url, parameters) {
        newURL = url;
        if (parameters != null) {
            var toAdd = OAuth.formEncode(parameters);
            if (toAdd.length &gt; 0) {
                var q = url.indexOf(&apos;?&apos;);
                if (q &lt; 0) newURL += &apos;?&apos;;
                else       newURL += &apos;&amp;&apos;;
                newURL += toAdd;
            }
        }
        return newURL;
    }
,
    /** Construct the value of the Authorization header for an HTTP request. */
    getAuthorizationHeader: function getAuthorizationHeader(realm, parameters) {
        var header = &apos;OAuth realm=&quot;&apos; + OAuth.percentEncode(realm) + &apos;&quot;&apos;;
        var list = OAuth.getParameterList(parameters);
        for (var p = 0; p &lt; list.length; ++p) {
            var parameter = list[p];
            var name = parameter[0];
            if (name.indexOf(&quot;oauth_&quot;) == 0) {
                header += &apos;,&apos; + OAuth.percentEncode(name) + &apos;=&quot;&apos; + OAuth.percentEncode(parameter[1]) + &apos;&quot;&apos;;
            }
        }
        return header;
    }
,
    /** Correct the time using a parameter from the URL from which the last script was loaded. */
    correctTimestampFromSrc: function correctTimestampFromSrc(parameterName) {
        parameterName = parameterName || &quot;oauth_timestamp&quot;;
        var scripts = document.getElementsByTagName(&apos;script&apos;);
        if (scripts == null || !scripts.length) return;
        var src = scripts[scripts.length-1].src;
        if (!src) return;
        var q = src.indexOf(&quot;?&quot;);
        if (q &lt; 0) return;
        parameters = OAuth.getParameterMap(OAuth.decodeForm(src.substring(q+1)));
        var t = parameters[parameterName];
        if (t == null) return;
        OAuth.correctTimestamp(t);
    }
,
    /** Generate timestamps starting with the given value. */
    correctTimestamp: function correctTimestamp(timestamp) {
        OAuth.timeCorrectionMsec = (timestamp * 1000) - (new Date()).getTime();
    }
,
    /** The difference between the correct time and my clock. */
    timeCorrectionMsec: 0
,
    timestamp: function timestamp() {
        var t = (new Date()).getTime() + OAuth.timeCorrectionMsec;
        return Math.floor(t / 1000);
    }
,
    nonce: function nonce(length) {
        var chars = OAuth.nonce.CHARS;
        var result = &quot;&quot;;
        for (var i = 0; i &lt; length; ++i) {
            var rnum = Math.floor(Math.random() * chars.length);
            result += chars.substring(rnum, rnum+1);
        }
        return result;
    }
});

OAuth.nonce.CHARS = &quot;0123456789ABCDEFGHIJKLMNOPQRSTUVWXTZabcdefghiklmnopqrstuvwxyz&quot;;

/** Define a constructor function,
    without causing trouble to anyone who was using it as a namespace.
    That is, if parent[name] already existed and had properties,
    copy those properties into the new constructor.
 */
OAuth.declareClass = function declareClass(parent, name, newConstructor) {
    var previous = parent[name];
    parent[name] = newConstructor;
    if (newConstructor != null &amp;&amp; previous != null) {
        for (var key in previous) {
            if (key != &quot;prototype&quot;) {
                newConstructor[key] = previous[key];
            }
        }
    }
    return newConstructor;
}

/** An abstract algorithm for signing messages. */
OAuth.declareClass(OAuth, &quot;SignatureMethod&quot;, function OAuthSignatureMethod(){});

OAuth.setProperties(OAuth.SignatureMethod.prototype, // instance members
{
    /** Add a signature to the message. */
    sign: function sign(message) {
        var baseString = OAuth.SignatureMethod.getBaseString(message);
        var signature = this.getSignature(baseString);
        OAuth.setParameter(message, &quot;oauth_signature&quot;, signature);
        return signature; // just in case someone&apos;s interested
    }
,
    /** Set the key string for signing. */
    initialize: function initialize(name, accessor) {
        var consumerSecret;
        if (accessor.accessorSecret != null
            &amp;&amp; name.length &gt; 9
            &amp;&amp; name.substring(name.length-9) == &quot;-Accessor&quot;)
        {
            consumerSecret = accessor.accessorSecret;
        } else {
            consumerSecret = accessor.consumerSecret;
        }
        this.key = OAuth.percentEncode(consumerSecret)
             +&quot;&amp;&quot;+ OAuth.percentEncode(accessor.tokenSecret);
    }
});

/* SignatureMethod expects an accessor object to be like this:
   {tokenSecret: &quot;lakjsdflkj...&quot;, consumerSecret: &quot;QOUEWRI..&quot;, accessorSecret: &quot;xcmvzc...&quot;}
   The accessorSecret property is optional.
 */
// Class members:
OAuth.setProperties(OAuth.SignatureMethod, // class members
{
    sign: function sign(message, accessor) {
        var name = OAuth.getParameterMap(message.parameters).oauth_signature_method;
        if (name == null || name == &quot;&quot;) {
            name = &quot;HMAC-SHA1&quot;;
            OAuth.setParameter(message, &quot;oauth_signature_method&quot;, name);
        }
        OAuth.SignatureMethod.newMethod(name, accessor).sign(message);
    }
,
    /** Instantiate a SignatureMethod for the given method name. */
    newMethod: function newMethod(name, accessor) {
        var impl = OAuth.SignatureMethod.REGISTERED[name];
        if (impl != null) {
            var method = new impl();
            method.initialize(name, accessor);
            return method;
        }
        var err = new Error(&quot;signature_method_rejected&quot;);
        var acceptable = &quot;&quot;;
        for (var r in OAuth.SignatureMethod.REGISTERED) {
            if (acceptable != &quot;&quot;) acceptable += &apos;&amp;&apos;;
            acceptable += OAuth.percentEncode(r);
        }
        err.oauth_acceptable_signature_methods = acceptable;
        throw err;
    }
,
    /** A map from signature method name to constructor. */
    REGISTERED : {}
,
    /** Subsequently, the given constructor will be used for the named methods.
        The constructor will be called with no parameters.
        The resulting object should usually implement getSignature(baseString).
        You can easily define such a constructor by calling makeSubclass, below.
     */
    registerMethodClass: function registerMethodClass(names, classConstructor) {
        for (var n = 0; n &lt; names.length; ++n) {
            OAuth.SignatureMethod.REGISTERED[names[n]] = classConstructor;
        }
    }
,
    /** Create a subclass of OAuth.SignatureMethod, with the given getSignature function. */
    makeSubclass: function makeSubclass(getSignatureFunction) {
        var superClass = OAuth.SignatureMethod;
        var subClass = function() {
            superClass.call(this);
        };
        subClass.prototype = new superClass();
        // Delete instance variables from prototype:
        // delete subclass.prototype... There aren&apos;t any.
        subClass.prototype.getSignature = getSignatureFunction;
        subClass.prototype.constructor = subClass;
        return subClass;
    }
,
    getBaseString: function getBaseString(message) {
        var URL = message.action;
        var q = URL.indexOf(&apos;?&apos;);
        var parameters;
        if (q &lt; 0) {
            parameters = message.parameters;
        } else {
            // Combine the URL query string with the other parameters:
            parameters = OAuth.decodeForm(URL.substring(q + 1));
            var toAdd = OAuth.getParameterList(message.parameters);
            for (var a = 0; a &lt; toAdd.length; ++a) {
                parameters.push(toAdd[a]);
            }
        }
        return OAuth.percentEncode(message.method.toUpperCase())
         +&apos;&amp;&apos;+ OAuth.percentEncode(OAuth.SignatureMethod.normalizeUrl(URL))
         +&apos;&amp;&apos;+ OAuth.percentEncode(OAuth.SignatureMethod.normalizeParameters(parameters));
    }
,
    normalizeUrl: function normalizeUrl(url) {
        var uri = OAuth.SignatureMethod.parseUri(url);
        var scheme = uri.protocol.toLowerCase();
        var authority = uri.authority.toLowerCase();
        var dropPort = (scheme == &quot;http&quot; &amp;&amp; uri.port == 80)
                    || (scheme == &quot;https&quot; &amp;&amp; uri.port == 443);
        if (dropPort) {
            // find the last : in the authority
            var index = authority.lastIndexOf(&quot;:&quot;);
            if (index &gt;= 0) {
                authority = authority.substring(0, index);
            }
        }
        var path = uri.path;
        if (!path) {
            path = &quot;/&quot;; // conforms to RFC 2616 section 3.2.2
        }
        // we know that there is no query and no fragment here.
        return scheme + &quot;://&quot; + authority + path;
    }
,
    parseUri: function parseUri (str) {
        /* This function was adapted from parseUri 1.2.1
           http://stevenlevithan.com/demo/parseuri/js/assets/parseuri.js
         */
        var o = {key: [&quot;source&quot;,&quot;protocol&quot;,&quot;authority&quot;,&quot;userInfo&quot;,&quot;user&quot;,&quot;password&quot;,&quot;host&quot;,&quot;port&quot;,&quot;relative&quot;,&quot;path&quot;,&quot;directory&quot;,&quot;file&quot;,&quot;query&quot;,&quot;anchor&quot;],
                 parser: {strict: /^(?:([^:\/?#]+):)?(?:\/\/((?:(([^:@\/]*):?([^:@\/]*))?@)?([^:\/?#]*)(?::(\d*))?))?((((?:[^?#\/]*\/)*)([^?#]*))(?:\?([^#]*))?(?:#(.*))?)/ }};
        var m = o.parser.strict.exec(str);
        var uri = {};
        var i = 14;
        while (i--) uri[o.key[i]] = m[i] || &quot;&quot;;
        return uri;
    }
,
    normalizeParameters: function normalizeParameters(parameters) {
        if (parameters == null) {
            return &quot;&quot;;
        }
        var list = OAuth.getParameterList(parameters);
        var sortable = [];
        for (var p = 0; p &lt; list.length; ++p) {
            var nvp = list[p];
            if (nvp[0] != &quot;oauth_signature&quot;) {
                sortable.push([ OAuth.percentEncode(nvp[0])
                              + &quot; &quot; // because it comes before any character that can appear in a percentEncoded string.
                              + OAuth.percentEncode(nvp[1])
                              , nvp]);
            }
        }
        sortable.sort(function(a,b) {
                          if (a[0] &lt; b[0]) return  -1;
                          if (a[0] &gt; b[0]) return 1;
                          return 0;
                      });
        var sorted = [];
        for (var s = 0; s &lt; sortable.length; ++s) {
            sorted.push(sortable[s][1]);
        }
        return OAuth.formEncode(sorted);
    }
});

OAuth.SignatureMethod.registerMethodClass([&quot;PLAINTEXT&quot;, &quot;PLAINTEXT-Accessor&quot;],
    OAuth.SignatureMethod.makeSubclass(
        function getSignature(baseString) {
            return this.key;
        }
    ));

OAuth.SignatureMethod.registerMethodClass([&quot;HMAC-SHA1&quot;, &quot;HMAC-SHA1-Accessor&quot;],
    OAuth.SignatureMethod.makeSubclass(
        function getSignature(baseString) {
            b64pad = &apos;=&apos;;
            var signature = b64_hmac_sha1(this.key, baseString);
            return signature;
        }
    ));

try {
    OAuth.correctTimestampFromSrc();
} catch(e) {
}


//--------------------------------------------------

var consumerKey = &quot;${consumer_key}&quot;;
var consumerSecret = &quot;${consumer_secret}&quot;;
var params = [];
var query = [];
query.push(&apos;access_token&apos; + &apos;=&apos; + &apos;${access_token}&apos;);
query.push(&apos;id_token&apos; + &apos;=&apos; + &apos;${id_token}&apos;);
var url =  &quot;${protocol}://${misp_url}/marvelous/people/@me/@self&quot;;

if (query.length) {
    url += &apos;?&apos; + query.join(&apos;&amp;&apos;);
}

var message = {
    method: &apos;get&apos;,
    parameters: params, 
    action: url
};

log.info(url);
log.info(consumerSecret);

var accessor = {
    consumerKey: consumerKey,
    consumerSecret: consumerSecret,
    token:  &apos;${access_token}&apos;,
    tokenSecret: &apos;${id_token}&apos;
};

OAuth.completeRequest(message, accessor);
vars.put(&apos;put_auth_header&apos;, OAuth.getAuthorizationHeader(&apos;&apos;, params).replace(&apos;OAuth realm=&quot;&quot;,&apos;, &apos; OAuth &apos;));
</stringProp>
            <stringProp name="scriptLanguage">javascript</stringProp>
          </BSFPreProcessor>
          <hashTree/>
          <HeaderManager guiclass="HeaderPanel" testclass="HeaderManager" testname="HTTP ヘッダマネージャ" enabled="true">
            <collectionProp name="HeaderManager.headers">
              <elementProp name="" elementType="Header">
                <stringProp name="Header.name">Authorization</stringProp>
                <stringProp name="Header.value">${put_auth_header}</stringProp>
              </elementProp>
              <elementProp name="" elementType="Header">
                <stringProp name="Header.name">content-type</stringProp>
                <stringProp name="Header.value">application/x-www-form-urlencoded</stringProp>
              </elementProp>
              <elementProp name="" elementType="Header">
                <stringProp name="Header.name">Connection</stringProp>
                <stringProp name="Header.value">close</stringProp>
              </elementProp>
              <elementProp name="" elementType="Header">
                <stringProp name="Header.name">Accept-encoding</stringProp>
                <stringProp name="Header.value">gzip, deflate</stringProp>
              </elementProp>
            </collectionProp>
          </HeaderManager>
          <hashTree/>
          <ResponseAssertion guiclass="AssertionGui" testclass="ResponseAssertion" testname="アサーション" enabled="true">
            <collectionProp name="Asserion.test_strings">
              <stringProp name="2033562336">&quot;username&quot;:&quot;proxy_user_3&quot;</stringProp>
              <stringProp name="-70863191">&quot;userId&quot;:&quot;proxy_test_3&quot;</stringProp>
              <stringProp name="-1301137854">&quot;appId&quot;:&quot;00000&quot;</stringProp>
            </collectionProp>
            <stringProp name="Assertion.test_field">Assertion.response_data</stringProp>
            <boolProp name="Assertion.assume_success">false</boolProp>
            <intProp name="Assertion.test_type">2</intProp>
            <stringProp name="TestPlan.comments">確認項目
mispRp_2と同じ値を取得できていること</stringProp>
          </ResponseAssertion>
          <hashTree/>
        </hashTree>
        <HTTPSamplerProxy guiclass="HttpTestSampleGui" testclass="HTTPSamplerProxy" testname="Implicit.ユーザ取得エラー(秘密鍵が空)" enabled="true">
          <elementProp name="HTTPsampler.Arguments" elementType="Arguments" guiclass="HTTPArgumentsPanel" testclass="Arguments" enabled="true">
            <collectionProp name="Arguments.arguments">
              <elementProp name="access_token" elementType="HTTPArgument">
                <boolProp name="HTTPArgument.always_encode">false</boolProp>
                <stringProp name="Argument.value">${access_token}</stringProp>
                <stringProp name="Argument.metadata">=</stringProp>
                <boolProp name="HTTPArgument.use_equals">true</boolProp>
                <stringProp name="Argument.name">access_token</stringProp>
              </elementProp>
              <elementProp name="id_token" elementType="HTTPArgument">
                <boolProp name="HTTPArgument.always_encode">false</boolProp>
                <stringProp name="Argument.value">${id_token}</stringProp>
                <stringProp name="Argument.metadata">=</stringProp>
                <boolProp name="HTTPArgument.use_equals">true</boolProp>
                <stringProp name="Argument.name">id_token</stringProp>
              </elementProp>
            </collectionProp>
          </elementProp>
          <stringProp name="HTTPSampler.domain"></stringProp>
          <stringProp name="HTTPSampler.port"></stringProp>
          <stringProp name="HTTPSampler.connect_timeout"></stringProp>
          <stringProp name="HTTPSampler.response_timeout"></stringProp>
          <stringProp name="HTTPSampler.protocol"></stringProp>
          <stringProp name="HTTPSampler.contentEncoding"></stringProp>
          <stringProp name="HTTPSampler.path">/marvelous/people/@me/@self</stringProp>
          <stringProp name="HTTPSampler.method">GET</stringProp>
          <boolProp name="HTTPSampler.follow_redirects">true</boolProp>
          <boolProp name="HTTPSampler.auto_redirects">false</boolProp>
          <boolProp name="HTTPSampler.use_keepalive">true</boolProp>
          <boolProp name="HTTPSampler.DO_MULTIPART_POST">false</boolProp>
          <boolProp name="HTTPSampler.monitor">false</boolProp>
          <stringProp name="HTTPSampler.embedded_url_re"></stringProp>
        </HTTPSamplerProxy>
        <hashTree>
          <BSFPreProcessor guiclass="TestBeanGUI" testclass="BSFPreProcessor" testname="BSF PreProcessor" enabled="true">
            <stringProp name="filename"></stringProp>
            <stringProp name="parameters"></stringProp>
            <stringProp name="script">/*
 * A JavaScript implementation of the Secure Hash Algorithm, SHA-1, as defined
 * in FIPS PUB 180-1
 * Version 2.1a Copyright Paul Johnston 2000 - 2002.
 * Other contributors: Greg Holt, Andrew Kepert, Ydnar, Lostinet
 * Distributed under the BSD License
 * See http://pajhome.org.uk/crypt/md5 for details.
 */

/*
 * Configurable variables. You may need to tweak these to be compatible with
 * the server-side, but the defaults work in most cases.
 */
var hexcase = 0;  /* hex output format. 0 - lowercase; 1 - uppercase        */
var b64pad  = &quot;&quot;; /* base-64 pad character. &quot;=&quot; for strict RFC compliance   */
var chrsz   = 8;  /* bits per input character. 8 - ASCII; 16 - Unicode      */

/*
 * These are the functions you&apos;ll usually want to call
 * They take string arguments and return either hex or base-64 encoded strings
 */
function hex_sha1(s){return binb2hex(core_sha1(str2binb(s),s.length * chrsz));}
function b64_sha1(s){return binb2b64(core_sha1(str2binb(s),s.length * chrsz));}
function str_sha1(s){return binb2str(core_sha1(str2binb(s),s.length * chrsz));}
function hex_hmac_sha1(key, data){ return binb2hex(core_hmac_sha1(key, data));}
function b64_hmac_sha1(key, data){ return binb2b64(core_hmac_sha1(key, data));}
function str_hmac_sha1(key, data){ return binb2str(core_hmac_sha1(key, data));}

/*
 * Perform a simple self-test to see if the VM is working
 */
function sha1_vm_test()
{
  return hex_sha1(&quot;abc&quot;) == &quot;a9993e364706816aba3e25717850c26c9cd0d89d&quot;;
}

/*
 * Calculate the SHA-1 of an array of big-endian words, and a bit length
 */
function core_sha1(x, len)
{
  /* append padding */
  x[len &gt;&gt; 5] |= 0x80 &lt;&lt; (24 - len % 32);
  x[((len + 64 &gt;&gt; 9) &lt;&lt; 4) + 15] = len;

  var w = Array(80);
  var a =  1732584193;
  var b = -271733879;
  var c = -1732584194;
  var d =  271733878;
  var e = -1009589776;

  for(var i = 0; i &lt; x.length; i += 16)
  {
    var olda = a;
    var oldb = b;
    var oldc = c;
    var oldd = d;
    var olde = e;

    for(var j = 0; j &lt; 80; j++)
    {
      if(j &lt; 16) w[j] = x[i + j];
      else w[j] = rol(w[j-3] ^ w[j-8] ^ w[j-14] ^ w[j-16], 1);
      var t = safe_add(safe_add(rol(a, 5), sha1_ft(j, b, c, d)),
                       safe_add(safe_add(e, w[j]), sha1_kt(j)));
      e = d;
      d = c;
      c = rol(b, 30);
      b = a;
      a = t;
    }

    a = safe_add(a, olda);
    b = safe_add(b, oldb);
    c = safe_add(c, oldc);
    d = safe_add(d, oldd);
    e = safe_add(e, olde);
  }
  return Array(a, b, c, d, e);

}

/*
 * Perform the appropriate triplet combination function for the current
 * iteration
 */
function sha1_ft(t, b, c, d)
{
  if(t &lt; 20) return (b &amp; c) | ((~b) &amp; d);
  if(t &lt; 40) return b ^ c ^ d;
  if(t &lt; 60) return (b &amp; c) | (b &amp; d) | (c &amp; d);
  return b ^ c ^ d;
}

/*
 * Determine the appropriate additive constant for the current iteration
 */
function sha1_kt(t)
{
  return (t &lt; 20) ?  1518500249 : (t &lt; 40) ?  1859775393 :
         (t &lt; 60) ? -1894007588 : -899497514;
}

/*
 * Calculate the HMAC-SHA1 of a key and some data
 */
function core_hmac_sha1(key, data)
{
  var bkey = str2binb(key);
  if(bkey.length &gt; 16) bkey = core_sha1(bkey, key.length * chrsz);

  var ipad = Array(16), opad = Array(16);
  for(var i = 0; i &lt; 16; i++)
  {
    ipad[i] = bkey[i] ^ 0x36363636;
    opad[i] = bkey[i] ^ 0x5C5C5C5C;
  }

  var hash = core_sha1(ipad.concat(str2binb(data)), 512 + data.length * chrsz);
  return core_sha1(opad.concat(hash), 512 + 160);
}

/*
 * Add integers, wrapping at 2^32. This uses 16-bit operations internally
 * to work around bugs in some JS interpreters.
 */
function safe_add(x, y)
{
  var lsw = (x &amp; 0xFFFF) + (y &amp; 0xFFFF);
  var msw = (x &gt;&gt; 16) + (y &gt;&gt; 16) + (lsw &gt;&gt; 16);
  return (msw &lt;&lt; 16) | (lsw &amp; 0xFFFF);
}

/*
 * Bitwise rotate a 32-bit number to the left.
 */
function rol(num, cnt)
{
  return (num &lt;&lt; cnt) | (num &gt;&gt;&gt; (32 - cnt));
}

/*
 * Convert an 8-bit or 16-bit string to an array of big-endian words
 * In 8-bit function, characters &gt;255 have their hi-byte silently ignored.
 */
function str2binb(str)
{
  var bin = Array();
  var mask = (1 &lt;&lt; chrsz) - 1;
  for(var i = 0; i &lt; str.length * chrsz; i += chrsz)
    bin[i&gt;&gt;5] |= (str.charCodeAt(i / chrsz) &amp; mask) &lt;&lt; (32 - chrsz - i%32);
  return bin;
}

/*
 * Convert an array of big-endian words to a string
 */
function binb2str(bin)
{
  var str = &quot;&quot;;
  var mask = (1 &lt;&lt; chrsz) - 1;
  for(var i = 0; i &lt; bin.length * 32; i += chrsz)
    str += String.fromCharCode((bin[i&gt;&gt;5] &gt;&gt;&gt; (32 - chrsz - i%32)) &amp; mask);
  return str;
}

/*
 * Convert an array of big-endian words to a hex string.
 */
function binb2hex(binarray)
{
  var hex_tab = hexcase ? &quot;0123456789ABCDEF&quot; : &quot;0123456789abcdef&quot;;
  var str = &quot;&quot;;
  for(var i = 0; i &lt; binarray.length * 4; i++)
  {
    str += hex_tab.charAt((binarray[i&gt;&gt;2] &gt;&gt; ((3 - i%4)*8+4)) &amp; 0xF) +
           hex_tab.charAt((binarray[i&gt;&gt;2] &gt;&gt; ((3 - i%4)*8  )) &amp; 0xF);
  }
  return str;
}

/*
 * Convert an array of big-endian words to a base-64 string
 */
function binb2b64(binarray)
{
  var tab = &quot;ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/&quot;;
  var str = &quot;&quot;;
  for(var i = 0; i &lt; binarray.length * 4; i += 3)
  {
    var triplet = (((binarray[i   &gt;&gt; 2] &gt;&gt; 8 * (3 -  i   %4)) &amp; 0xFF) &lt;&lt; 16)
                | (((binarray[i+1 &gt;&gt; 2] &gt;&gt; 8 * (3 - (i+1)%4)) &amp; 0xFF) &lt;&lt; 8 )
                |  ((binarray[i+2 &gt;&gt; 2] &gt;&gt; 8 * (3 - (i+2)%4)) &amp; 0xFF);
    for(var j = 0; j &lt; 4; j++)
    {
      if(i * 8 + j * 6 &gt; binarray.length * 32) str += b64pad;
      else str += tab.charAt((triplet &gt;&gt; 6*(3-j)) &amp; 0x3F);
    }
  }
  return str;
}

/*
 * Copyright 2008 Netflix, Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/* Here&apos;s some JavaScript software for implementing OAuth.

   This isn&apos;t as useful as you might hope.  OAuth is based around
   allowing tools and websites to talk to each other.  However,
   JavaScript running in web browsers is hampered by security
   restrictions that prevent code running on one website from
   accessing data stored or served on another.

   Before you start hacking, make sure you understand the limitations
   posed by cross-domain XMLHttpRequest.

   On the bright side, some platforms use JavaScript as their
   language, but enable the programmer to access other web sites.
   Examples include Google Gadgets, and Microsoft Vista Sidebar.
   For those platforms, this library should come in handy.
*/

// The HMAC-SHA1 signature method calls b64_hmac_sha1, defined by
// http://pajhome.org.uk/crypt/md5/sha1.js

/* An OAuth message is represented as an object like this:
   {method: &quot;GET&quot;, action: &quot;http://server.com/path&quot;, parameters: ...}

   The parameters may be either a map {name: value, name2: value2}
   or an Array of name-value pairs [[name, value], [name2, value2]].
   The latter representation is more powerful: it supports parameters
   in a specific sequence, or several parameters with the same name;
   for example [[&quot;a&quot;, 1], [&quot;b&quot;, 2], [&quot;a&quot;, 3]].

   Parameter names and values are NOT percent-encoded in an object.
   They must be encoded before transmission and decoded after reception.
   For example, this message object:
   {method: &quot;GET&quot;, action: &quot;http://server/path&quot;, parameters: {p: &quot;x y&quot;}}
   ... can be transmitted as an HTTP request that begins:
   GET /path?p=x%20y HTTP/1.0
   (This isn&apos;t a valid OAuth request, since it lacks a signature etc.)
   Note that the object &quot;x y&quot; is transmitted as x%20y.  To encode
   parameters, you can call OAuth.addToURL, OAuth.formEncode or
   OAuth.getAuthorization.

   This message object model harmonizes with the browser object model for
   input elements of an form, whose value property isn&apos;t percent encoded.
   The browser encodes each value before transmitting it. For example,
   see consumer.setInputs in example/consumer.js.
 */

/* This script needs to know what time it is. By default, it uses the local
   clock (new Date), which is apt to be inaccurate in browsers. To do
   better, you can load this script from a URL whose query string contains
   an oauth_timestamp parameter, whose value is a current Unix timestamp.
   For example, when generating the enclosing document using PHP:

   &lt;script src=&quot;oauth.js?oauth_timestamp=&lt;?=time()?&gt;&quot; ...

   Another option is to call OAuth.correctTimestamp with a Unix timestamp.
 */

var OAuth; if (OAuth == null) OAuth = {};

OAuth.setProperties = function setProperties(into, from) {
    if (into != null &amp;&amp; from != null) {
        for (var key in from) {
            into[key] = from[key];
        }
    }
    return into;
}

OAuth.setProperties(OAuth, // utility functions
{
    percentEncode: function percentEncode(s) {
        if (s == null) {
            return &quot;&quot;;
        }
        if (s instanceof Array) {
            var e = &quot;&quot;;
            for (var i = 0; i &lt; s.length; ++s) {
                if (e != &quot;&quot;) e += &apos;&amp;&apos;;
                e += OAuth.percentEncode(s[i]);
            }
            return e;
        }
        s = encodeURIComponent(s);
        // Now replace the values which encodeURIComponent doesn&apos;t do
        // encodeURIComponent ignores: - _ . ! ~ * &apos; ( )
        // OAuth dictates the only ones you can ignore are: - _ . ~
        // Source: http://developer.mozilla.org/en/docs/Core_JavaScript_1.5_Reference:Global_Functions:encodeURIComponent
        s = s.replace(/\!/g, &quot;%21&quot;);
        s = s.replace(/\*/g, &quot;%2A&quot;);
        s = s.replace(/\&apos;/g, &quot;%27&quot;);
        s = s.replace(/\(/g, &quot;%28&quot;);
        s = s.replace(/\)/g, &quot;%29&quot;);
        return s;
    }
,
    decodePercent: function decodePercent(s) {
        if (s != null) {
            // Handle application/x-www-form-urlencoded, which is defined by
            // http://www.w3.org/TR/html4/interact/forms.html#h-17.13.4.1
            s = s.replace(/\+/g, &quot; &quot;);
        }
        return decodeURIComponent(s);
    }
,
    /** Convert the given parameters to an Array of name-value pairs. */
    getParameterList: function getParameterList(parameters) {
        if (parameters == null) {
            return [];
        }
        if (typeof parameters != &quot;object&quot;) {
            return OAuth.decodeForm(parameters + &quot;&quot;);
        }
        if (parameters instanceof Array) {
            return parameters;
        }
        var list = [];
        for (var p in parameters) {
            list.push([p, parameters[p]]);
        }
        return list;
    }
,
    /** Convert the given parameters to a map from name to value. */
    getParameterMap: function getParameterMap(parameters) {
        if (parameters == null) {
            return {};
        }
        if (typeof parameters != &quot;object&quot;) {
            return OAuth.getParameterMap(OAuth.decodeForm(parameters + &quot;&quot;));
        }
        if (parameters instanceof Array) {
            var map = {};
            for (var p = 0; p &lt; parameters.length; ++p) {
                var key = parameters[p][0];
                if (map[key] === undefined) { // first value wins
                    map[key] = parameters[p][1];
                }
            }
            return map;
        }
        return parameters;
    }
,
    getParameter: function getParameter(parameters, name) {
        if (parameters instanceof Array) {
            for (var p = 0; p &lt; parameters.length; ++p) {
                if (parameters[p][0] == name) {
                    return parameters[p][1]; // first value wins
                }
            }
        } else {
            return OAuth.getParameterMap(parameters)[name];
        }
        return null;
    }
,
    formEncode: function formEncode(parameters) {
        var form = &quot;&quot;;
        var list = OAuth.getParameterList(parameters);
        for (var p = 0; p &lt; list.length; ++p) {
            var value = list[p][1];
            if (value == null) value = &quot;&quot;;
            if (form != &quot;&quot;) form += &apos;&amp;&apos;;
            form += OAuth.percentEncode(list[p][0])
              +&apos;=&apos;+ OAuth.percentEncode(value);
        }
        return form;
    }
,
    decodeForm: function decodeForm(form) {
        var list = [];
        var nvps = form.split(&apos;&amp;&apos;);
        for (var n = 0; n &lt; nvps.length; ++n) {
            var nvp = nvps[n];
            if (nvp == &quot;&quot;) {
                continue;
            }
            var equals = nvp.indexOf(&apos;=&apos;);
            var name;
            var value;
            if (equals &lt; 0) {
                name = OAuth.decodePercent(nvp);
                value = null;
            } else {
                name = OAuth.decodePercent(nvp.substring(0, equals));
                value = OAuth.decodePercent(nvp.substring(equals + 1));
            }
            list.push([name, value]);
        }
        return list;
    }
,
    setParameter: function setParameter(message, name, value) {
        var parameters = message.parameters;
        if (parameters instanceof Array) {
            for (var p = 0; p &lt; parameters.length; ++p) {
                if (parameters[p][0] == name) {
                    if (value === undefined) {
                        parameters.splice(p, 1);
                    } else {
                        parameters[p][1] = value;
                        value = undefined;
                    }
                }
            }
            if (value !== undefined) {
                parameters.push([name, value]);
            }
        } else {
            parameters = OAuth.getParameterMap(parameters);
            parameters[name] = value;
            message.parameters = parameters;
        }
    }
,
    setParameters: function setParameters(message, parameters) {
        var list = OAuth.getParameterList(parameters);
        for (var i = 0; i &lt; list.length; ++i) {
            OAuth.setParameter(message, list[i][0], list[i][1]);
        }
    }
,
    /** Fill in parameters to help construct a request message.
        This function doesn&apos;t fill in every parameter.
        The accessor object should be like:
        {consumerKey:&apos;foo&apos;, consumerSecret:&apos;bar&apos;, accessorSecret:&apos;nurn&apos;, token:&apos;krelm&apos;, tokenSecret:&apos;blah&apos;}
        The accessorSecret property is optional.
     */
    completeRequest: function completeRequest(message, accessor) {
        if (message.method == null) {
            message.method = &quot;GET&quot;;
        }
        var map = OAuth.getParameterMap(message.parameters);
        if (map.oauth_consumer_key == null) {
            OAuth.setParameter(message, &quot;oauth_consumer_key&quot;, accessor.consumerKey || &quot;&quot;);
        }
        if (map.oauth_token == null &amp;&amp; accessor.token != null) {
            OAuth.setParameter(message, &quot;oauth_token&quot;, accessor.token);
        }
        if (map.oauth_version == null) {
            OAuth.setParameter(message, &quot;oauth_version&quot;, &quot;1.0&quot;);
        }
        if (map.oauth_timestamp == null) {
            OAuth.setParameter(message, &quot;oauth_timestamp&quot;, OAuth.timestamp());
        }
        if (map.oauth_nonce == null) {
            OAuth.setParameter(message, &quot;oauth_nonce&quot;, OAuth.nonce(6));
        }
        OAuth.SignatureMethod.sign(message, accessor);
    }
,
    setTimestampAndNonce: function setTimestampAndNonce(message) {
        OAuth.setParameter(message, &quot;oauth_timestamp&quot;, OAuth.timestamp());
        OAuth.setParameter(message, &quot;oauth_nonce&quot;, OAuth.nonce(6));
    }
,
    addToURL: function addToURL(url, parameters) {
        newURL = url;
        if (parameters != null) {
            var toAdd = OAuth.formEncode(parameters);
            if (toAdd.length &gt; 0) {
                var q = url.indexOf(&apos;?&apos;);
                if (q &lt; 0) newURL += &apos;?&apos;;
                else       newURL += &apos;&amp;&apos;;
                newURL += toAdd;
            }
        }
        return newURL;
    }
,
    /** Construct the value of the Authorization header for an HTTP request. */
    getAuthorizationHeader: function getAuthorizationHeader(realm, parameters) {
        var header = &apos;OAuth realm=&quot;&apos; + OAuth.percentEncode(realm) + &apos;&quot;&apos;;
        var list = OAuth.getParameterList(parameters);
        for (var p = 0; p &lt; list.length; ++p) {
            var parameter = list[p];
            var name = parameter[0];
            if (name.indexOf(&quot;oauth_&quot;) == 0) {
                header += &apos;,&apos; + OAuth.percentEncode(name) + &apos;=&quot;&apos; + OAuth.percentEncode(parameter[1]) + &apos;&quot;&apos;;
            }
        }
        return header;
    }
,
    /** Correct the time using a parameter from the URL from which the last script was loaded. */
    correctTimestampFromSrc: function correctTimestampFromSrc(parameterName) {
        parameterName = parameterName || &quot;oauth_timestamp&quot;;
        var scripts = document.getElementsByTagName(&apos;script&apos;);
        if (scripts == null || !scripts.length) return;
        var src = scripts[scripts.length-1].src;
        if (!src) return;
        var q = src.indexOf(&quot;?&quot;);
        if (q &lt; 0) return;
        parameters = OAuth.getParameterMap(OAuth.decodeForm(src.substring(q+1)));
        var t = parameters[parameterName];
        if (t == null) return;
        OAuth.correctTimestamp(t);
    }
,
    /** Generate timestamps starting with the given value. */
    correctTimestamp: function correctTimestamp(timestamp) {
        OAuth.timeCorrectionMsec = (timestamp * 1000) - (new Date()).getTime();
    }
,
    /** The difference between the correct time and my clock. */
    timeCorrectionMsec: 0
,
    timestamp: function timestamp() {
        var t = (new Date()).getTime() + OAuth.timeCorrectionMsec;
        return Math.floor(t / 1000);
    }
,
    nonce: function nonce(length) {
        var chars = OAuth.nonce.CHARS;
        var result = &quot;&quot;;
        for (var i = 0; i &lt; length; ++i) {
            var rnum = Math.floor(Math.random() * chars.length);
            result += chars.substring(rnum, rnum+1);
        }
        return result;
    }
});

OAuth.nonce.CHARS = &quot;0123456789ABCDEFGHIJKLMNOPQRSTUVWXTZabcdefghiklmnopqrstuvwxyz&quot;;

/** Define a constructor function,
    without causing trouble to anyone who was using it as a namespace.
    That is, if parent[name] already existed and had properties,
    copy those properties into the new constructor.
 */
OAuth.declareClass = function declareClass(parent, name, newConstructor) {
    var previous = parent[name];
    parent[name] = newConstructor;
    if (newConstructor != null &amp;&amp; previous != null) {
        for (var key in previous) {
            if (key != &quot;prototype&quot;) {
                newConstructor[key] = previous[key];
            }
        }
    }
    return newConstructor;
}

/** An abstract algorithm for signing messages. */
OAuth.declareClass(OAuth, &quot;SignatureMethod&quot;, function OAuthSignatureMethod(){});

OAuth.setProperties(OAuth.SignatureMethod.prototype, // instance members
{
    /** Add a signature to the message. */
    sign: function sign(message) {
        var baseString = OAuth.SignatureMethod.getBaseString(message);
        var signature = this.getSignature(baseString);
        OAuth.setParameter(message, &quot;oauth_signature&quot;, signature);
        return signature; // just in case someone&apos;s interested
    }
,
    /** Set the key string for signing. */
    initialize: function initialize(name, accessor) {
        var consumerSecret;
        if (accessor.accessorSecret != null
            &amp;&amp; name.length &gt; 9
            &amp;&amp; name.substring(name.length-9) == &quot;-Accessor&quot;)
        {
            consumerSecret = accessor.accessorSecret;
        } else {
            consumerSecret = accessor.consumerSecret;
        }
        this.key = OAuth.percentEncode(consumerSecret)
             +&quot;&amp;&quot;+ OAuth.percentEncode(accessor.tokenSecret);
    }
});

/* SignatureMethod expects an accessor object to be like this:
   {tokenSecret: &quot;lakjsdflkj...&quot;, consumerSecret: &quot;QOUEWRI..&quot;, accessorSecret: &quot;xcmvzc...&quot;}
   The accessorSecret property is optional.
 */
// Class members:
OAuth.setProperties(OAuth.SignatureMethod, // class members
{
    sign: function sign(message, accessor) {
        var name = OAuth.getParameterMap(message.parameters).oauth_signature_method;
        if (name == null || name == &quot;&quot;) {
            name = &quot;HMAC-SHA1&quot;;
            OAuth.setParameter(message, &quot;oauth_signature_method&quot;, name);
        }
        OAuth.SignatureMethod.newMethod(name, accessor).sign(message);
    }
,
    /** Instantiate a SignatureMethod for the given method name. */
    newMethod: function newMethod(name, accessor) {
        var impl = OAuth.SignatureMethod.REGISTERED[name];
        if (impl != null) {
            var method = new impl();
            method.initialize(name, accessor);
            return method;
        }
        var err = new Error(&quot;signature_method_rejected&quot;);
        var acceptable = &quot;&quot;;
        for (var r in OAuth.SignatureMethod.REGISTERED) {
            if (acceptable != &quot;&quot;) acceptable += &apos;&amp;&apos;;
            acceptable += OAuth.percentEncode(r);
        }
        err.oauth_acceptable_signature_methods = acceptable;
        throw err;
    }
,
    /** A map from signature method name to constructor. */
    REGISTERED : {}
,
    /** Subsequently, the given constructor will be used for the named methods.
        The constructor will be called with no parameters.
        The resulting object should usually implement getSignature(baseString).
        You can easily define such a constructor by calling makeSubclass, below.
     */
    registerMethodClass: function registerMethodClass(names, classConstructor) {
        for (var n = 0; n &lt; names.length; ++n) {
            OAuth.SignatureMethod.REGISTERED[names[n]] = classConstructor;
        }
    }
,
    /** Create a subclass of OAuth.SignatureMethod, with the given getSignature function. */
    makeSubclass: function makeSubclass(getSignatureFunction) {
        var superClass = OAuth.SignatureMethod;
        var subClass = function() {
            superClass.call(this);
        };
        subClass.prototype = new superClass();
        // Delete instance variables from prototype:
        // delete subclass.prototype... There aren&apos;t any.
        subClass.prototype.getSignature = getSignatureFunction;
        subClass.prototype.constructor = subClass;
        return subClass;
    }
,
    getBaseString: function getBaseString(message) {
        var URL = message.action;
        var q = URL.indexOf(&apos;?&apos;);
        var parameters;
        if (q &lt; 0) {
            parameters = message.parameters;
        } else {
            // Combine the URL query string with the other parameters:
            parameters = OAuth.decodeForm(URL.substring(q + 1));
            var toAdd = OAuth.getParameterList(message.parameters);
            for (var a = 0; a &lt; toAdd.length; ++a) {
                parameters.push(toAdd[a]);
            }
        }
        return OAuth.percentEncode(message.method.toUpperCase())
         +&apos;&amp;&apos;+ OAuth.percentEncode(OAuth.SignatureMethod.normalizeUrl(URL))
         +&apos;&amp;&apos;+ OAuth.percentEncode(OAuth.SignatureMethod.normalizeParameters(parameters));
    }
,
    normalizeUrl: function normalizeUrl(url) {
        var uri = OAuth.SignatureMethod.parseUri(url);
        var scheme = uri.protocol.toLowerCase();
        var authority = uri.authority.toLowerCase();
        var dropPort = (scheme == &quot;http&quot; &amp;&amp; uri.port == 80)
                    || (scheme == &quot;https&quot; &amp;&amp; uri.port == 443);
        if (dropPort) {
            // find the last : in the authority
            var index = authority.lastIndexOf(&quot;:&quot;);
            if (index &gt;= 0) {
                authority = authority.substring(0, index);
            }
        }
        var path = uri.path;
        if (!path) {
            path = &quot;/&quot;; // conforms to RFC 2616 section 3.2.2
        }
        // we know that there is no query and no fragment here.
        return scheme + &quot;://&quot; + authority + path;
    }
,
    parseUri: function parseUri (str) {
        /* This function was adapted from parseUri 1.2.1
           http://stevenlevithan.com/demo/parseuri/js/assets/parseuri.js
         */
        var o = {key: [&quot;source&quot;,&quot;protocol&quot;,&quot;authority&quot;,&quot;userInfo&quot;,&quot;user&quot;,&quot;password&quot;,&quot;host&quot;,&quot;port&quot;,&quot;relative&quot;,&quot;path&quot;,&quot;directory&quot;,&quot;file&quot;,&quot;query&quot;,&quot;anchor&quot;],
                 parser: {strict: /^(?:([^:\/?#]+):)?(?:\/\/((?:(([^:@\/]*):?([^:@\/]*))?@)?([^:\/?#]*)(?::(\d*))?))?((((?:[^?#\/]*\/)*)([^?#]*))(?:\?([^#]*))?(?:#(.*))?)/ }};
        var m = o.parser.strict.exec(str);
        var uri = {};
        var i = 14;
        while (i--) uri[o.key[i]] = m[i] || &quot;&quot;;
        return uri;
    }
,
    normalizeParameters: function normalizeParameters(parameters) {
        if (parameters == null) {
            return &quot;&quot;;
        }
        var list = OAuth.getParameterList(parameters);
        var sortable = [];
        for (var p = 0; p &lt; list.length; ++p) {
            var nvp = list[p];
            if (nvp[0] != &quot;oauth_signature&quot;) {
                sortable.push([ OAuth.percentEncode(nvp[0])
                              + &quot; &quot; // because it comes before any character that can appear in a percentEncoded string.
                              + OAuth.percentEncode(nvp[1])
                              , nvp]);
            }
        }
        sortable.sort(function(a,b) {
                          if (a[0] &lt; b[0]) return  -1;
                          if (a[0] &gt; b[0]) return 1;
                          return 0;
                      });
        var sorted = [];
        for (var s = 0; s &lt; sortable.length; ++s) {
            sorted.push(sortable[s][1]);
        }
        return OAuth.formEncode(sorted);
    }
});

OAuth.SignatureMethod.registerMethodClass([&quot;PLAINTEXT&quot;, &quot;PLAINTEXT-Accessor&quot;],
    OAuth.SignatureMethod.makeSubclass(
        function getSignature(baseString) {
            return this.key;
        }
    ));

OAuth.SignatureMethod.registerMethodClass([&quot;HMAC-SHA1&quot;, &quot;HMAC-SHA1-Accessor&quot;],
    OAuth.SignatureMethod.makeSubclass(
        function getSignature(baseString) {
            b64pad = &apos;=&apos;;
            var signature = b64_hmac_sha1(this.key, baseString);
            return signature;
        }
    ));

try {
    OAuth.correctTimestampFromSrc();
} catch(e) {
}


//--------------------------------------------------

var consumerKey = &quot;${consumer_key}&quot;;
var consumerSecret = &quot;&quot;;
var params = [];
var query = [];
query.push(&apos;access_token&apos; + &apos;=&apos; + &apos;${access_token}&apos;);
query.push(&apos;id_token&apos; + &apos;=&apos; + &apos;${id_token}&apos;);
var url =  &quot;${protocol}://${misp_url}/marvelous/people/@me/@self&quot;;

if (query.length) {
    url += &apos;?&apos; + query.join(&apos;&amp;&apos;);
}

var message = {
    method: &apos;get&apos;,
    parameters: params, 
    action: url
};

log.info(url);
log.info(consumerSecret);

var accessor = {
    consumerKey: consumerKey,
    consumerSecret: consumerSecret,
    token:  &apos;${access_token}&apos;,
    tokenSecret: &apos;${id_token}&apos;
};

OAuth.completeRequest(message, accessor);
vars.put(&apos;put_auth_header&apos;, OAuth.getAuthorizationHeader(&apos;&apos;, params).replace(&apos;OAuth realm=&quot;&quot;,&apos;, &apos; OAuth &apos;));
</stringProp>
            <stringProp name="scriptLanguage">javascript</stringProp>
          </BSFPreProcessor>
          <hashTree/>
          <HeaderManager guiclass="HeaderPanel" testclass="HeaderManager" testname="HTTP ヘッダマネージャ" enabled="true">
            <collectionProp name="HeaderManager.headers">
              <elementProp name="" elementType="Header">
                <stringProp name="Header.name">Authorization</stringProp>
                <stringProp name="Header.value">${put_auth_header}</stringProp>
              </elementProp>
              <elementProp name="" elementType="Header">
                <stringProp name="Header.name">content-type</stringProp>
                <stringProp name="Header.value">application/x-www-form-urlencoded</stringProp>
              </elementProp>
              <elementProp name="" elementType="Header">
                <stringProp name="Header.name">Connection</stringProp>
                <stringProp name="Header.value">close</stringProp>
              </elementProp>
              <elementProp name="" elementType="Header">
                <stringProp name="Header.name">Accept-encoding</stringProp>
                <stringProp name="Header.value">gzip, deflate</stringProp>
              </elementProp>
            </collectionProp>
          </HeaderManager>
          <hashTree/>
          <BSFAssertion guiclass="TestBeanGUI" testclass="BSFAssertion" testname="レスポンスコード401" enabled="true">
            <stringProp name="filename"></stringProp>
            <stringProp name="parameters"></stringProp>
            <stringProp name="script">if (prev.getResponseCode() == &quot;401&quot;) {
	AssertionResult.setFailure(false);
	prev.setSuccessful(true);
} else {
	AssertionResult.setFailure(true);
}</stringProp>
            <stringProp name="scriptLanguage">javascript</stringProp>
          </BSFAssertion>
          <hashTree/>
        </hashTree>
        <HTTPSamplerProxy guiclass="HttpTestSampleGui" testclass="HTTPSamplerProxy" testname="Implicit.ユーザ更新エラー(トークンなし)" enabled="true">
          <boolProp name="HTTPSampler.postBodyRaw">true</boolProp>
          <elementProp name="HTTPsampler.Arguments" elementType="Arguments">
            <collectionProp name="Arguments.arguments">
              <elementProp name="" elementType="HTTPArgument">
                <boolProp name="HTTPArgument.always_encode">false</boolProp>
                <stringProp name="Argument.value">{&#xd;
  &quot;entry&quot;: [&#xd;
    {&#xd;
      &quot;apps&quot;: [&#xd;
        {&#xd;
          &quot;value&quot;: {&#xd;
            &quot;appId&quot;: &quot;00000&quot;,&#xd;
            &quot;userId&quot;: &quot;proxy_test_3&quot;,&#xd;
            &quot;username&quot;: &quot;trustedproxy_3&quot;,&#xd;
            &quot;password&quot;: &quot;I_have_a_dream&quot;&#xd;
          }&#xd;
        }&#xd;
      ]&#xd;
    }&#xd;
  ]&#xd;
}</stringProp>
                <stringProp name="Argument.metadata">=</stringProp>
              </elementProp>
            </collectionProp>
          </elementProp>
          <stringProp name="HTTPSampler.domain"></stringProp>
          <stringProp name="HTTPSampler.port"></stringProp>
          <stringProp name="HTTPSampler.connect_timeout"></stringProp>
          <stringProp name="HTTPSampler.response_timeout"></stringProp>
          <stringProp name="HTTPSampler.protocol"></stringProp>
          <stringProp name="HTTPSampler.contentEncoding"></stringProp>
          <stringProp name="HTTPSampler.path">/marvelous/people/@me/@self</stringProp>
          <stringProp name="HTTPSampler.method">PUT</stringProp>
          <boolProp name="HTTPSampler.follow_redirects">true</boolProp>
          <boolProp name="HTTPSampler.auto_redirects">false</boolProp>
          <boolProp name="HTTPSampler.use_keepalive">true</boolProp>
          <boolProp name="HTTPSampler.DO_MULTIPART_POST">false</boolProp>
          <boolProp name="HTTPSampler.monitor">false</boolProp>
          <stringProp name="HTTPSampler.embedded_url_re"></stringProp>
        </HTTPSamplerProxy>
        <hashTree>
          <BSFPreProcessor guiclass="TestBeanGUI" testclass="BSFPreProcessor" testname="BSF PreProcessor" enabled="true">
            <stringProp name="filename"></stringProp>
            <stringProp name="parameters"></stringProp>
            <stringProp name="script">/*
 * A JavaScript implementation of the Secure Hash Algorithm, SHA-1, as defined
 * in FIPS PUB 180-1
 * Version 2.1a Copyright Paul Johnston 2000 - 2002.
 * Other contributors: Greg Holt, Andrew Kepert, Ydnar, Lostinet
 * Distributed under the BSD License
 * See http://pajhome.org.uk/crypt/md5 for details.
 */

/*
 * Configurable variables. You may need to tweak these to be compatible with
 * the server-side, but the defaults work in most cases.
 */
var hexcase = 0;  /* hex output format. 0 - lowercase; 1 - uppercase        */
var b64pad  = &quot;&quot;; /* base-64 pad character. &quot;=&quot; for strict RFC compliance   */
var chrsz   = 8;  /* bits per input character. 8 - ASCII; 16 - Unicode      */

/*
 * These are the functions you&apos;ll usually want to call
 * They take string arguments and return either hex or base-64 encoded strings
 */
function hex_sha1(s){return binb2hex(core_sha1(str2binb(s),s.length * chrsz));}
function b64_sha1(s){return binb2b64(core_sha1(str2binb(s),s.length * chrsz));}
function str_sha1(s){return binb2str(core_sha1(str2binb(s),s.length * chrsz));}
function hex_hmac_sha1(key, data){ return binb2hex(core_hmac_sha1(key, data));}
function b64_hmac_sha1(key, data){ return binb2b64(core_hmac_sha1(key, data));}
function str_hmac_sha1(key, data){ return binb2str(core_hmac_sha1(key, data));}

/*
 * Perform a simple self-test to see if the VM is working
 */
function sha1_vm_test()
{
  return hex_sha1(&quot;abc&quot;) == &quot;a9993e364706816aba3e25717850c26c9cd0d89d&quot;;
}

/*
 * Calculate the SHA-1 of an array of big-endian words, and a bit length
 */
function core_sha1(x, len)
{
  /* append padding */
  x[len &gt;&gt; 5] |= 0x80 &lt;&lt; (24 - len % 32);
  x[((len + 64 &gt;&gt; 9) &lt;&lt; 4) + 15] = len;

  var w = Array(80);
  var a =  1732584193;
  var b = -271733879;
  var c = -1732584194;
  var d =  271733878;
  var e = -1009589776;

  for(var i = 0; i &lt; x.length; i += 16)
  {
    var olda = a;
    var oldb = b;
    var oldc = c;
    var oldd = d;
    var olde = e;

    for(var j = 0; j &lt; 80; j++)
    {
      if(j &lt; 16) w[j] = x[i + j];
      else w[j] = rol(w[j-3] ^ w[j-8] ^ w[j-14] ^ w[j-16], 1);
      var t = safe_add(safe_add(rol(a, 5), sha1_ft(j, b, c, d)),
                       safe_add(safe_add(e, w[j]), sha1_kt(j)));
      e = d;
      d = c;
      c = rol(b, 30);
      b = a;
      a = t;
    }

    a = safe_add(a, olda);
    b = safe_add(b, oldb);
    c = safe_add(c, oldc);
    d = safe_add(d, oldd);
    e = safe_add(e, olde);
  }
  return Array(a, b, c, d, e);

}

/*
 * Perform the appropriate triplet combination function for the current
 * iteration
 */
function sha1_ft(t, b, c, d)
{
  if(t &lt; 20) return (b &amp; c) | ((~b) &amp; d);
  if(t &lt; 40) return b ^ c ^ d;
  if(t &lt; 60) return (b &amp; c) | (b &amp; d) | (c &amp; d);
  return b ^ c ^ d;
}

/*
 * Determine the appropriate additive constant for the current iteration
 */
function sha1_kt(t)
{
  return (t &lt; 20) ?  1518500249 : (t &lt; 40) ?  1859775393 :
         (t &lt; 60) ? -1894007588 : -899497514;
}

/*
 * Calculate the HMAC-SHA1 of a key and some data
 */
function core_hmac_sha1(key, data)
{
  var bkey = str2binb(key);
  if(bkey.length &gt; 16) bkey = core_sha1(bkey, key.length * chrsz);

  var ipad = Array(16), opad = Array(16);
  for(var i = 0; i &lt; 16; i++)
  {
    ipad[i] = bkey[i] ^ 0x36363636;
    opad[i] = bkey[i] ^ 0x5C5C5C5C;
  }

  var hash = core_sha1(ipad.concat(str2binb(data)), 512 + data.length * chrsz);
  return core_sha1(opad.concat(hash), 512 + 160);
}

/*
 * Add integers, wrapping at 2^32. This uses 16-bit operations internally
 * to work around bugs in some JS interpreters.
 */
function safe_add(x, y)
{
  var lsw = (x &amp; 0xFFFF) + (y &amp; 0xFFFF);
  var msw = (x &gt;&gt; 16) + (y &gt;&gt; 16) + (lsw &gt;&gt; 16);
  return (msw &lt;&lt; 16) | (lsw &amp; 0xFFFF);
}

/*
 * Bitwise rotate a 32-bit number to the left.
 */
function rol(num, cnt)
{
  return (num &lt;&lt; cnt) | (num &gt;&gt;&gt; (32 - cnt));
}

/*
 * Convert an 8-bit or 16-bit string to an array of big-endian words
 * In 8-bit function, characters &gt;255 have their hi-byte silently ignored.
 */
function str2binb(str)
{
  var bin = Array();
  var mask = (1 &lt;&lt; chrsz) - 1;
  for(var i = 0; i &lt; str.length * chrsz; i += chrsz)
    bin[i&gt;&gt;5] |= (str.charCodeAt(i / chrsz) &amp; mask) &lt;&lt; (32 - chrsz - i%32);
  return bin;
}

/*
 * Convert an array of big-endian words to a string
 */
function binb2str(bin)
{
  var str = &quot;&quot;;
  var mask = (1 &lt;&lt; chrsz) - 1;
  for(var i = 0; i &lt; bin.length * 32; i += chrsz)
    str += String.fromCharCode((bin[i&gt;&gt;5] &gt;&gt;&gt; (32 - chrsz - i%32)) &amp; mask);
  return str;
}

/*
 * Convert an array of big-endian words to a hex string.
 */
function binb2hex(binarray)
{
  var hex_tab = hexcase ? &quot;0123456789ABCDEF&quot; : &quot;0123456789abcdef&quot;;
  var str = &quot;&quot;;
  for(var i = 0; i &lt; binarray.length * 4; i++)
  {
    str += hex_tab.charAt((binarray[i&gt;&gt;2] &gt;&gt; ((3 - i%4)*8+4)) &amp; 0xF) +
           hex_tab.charAt((binarray[i&gt;&gt;2] &gt;&gt; ((3 - i%4)*8  )) &amp; 0xF);
  }
  return str;
}

/*
 * Convert an array of big-endian words to a base-64 string
 */
function binb2b64(binarray)
{
  var tab = &quot;ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/&quot;;
  var str = &quot;&quot;;
  for(var i = 0; i &lt; binarray.length * 4; i += 3)
  {
    var triplet = (((binarray[i   &gt;&gt; 2] &gt;&gt; 8 * (3 -  i   %4)) &amp; 0xFF) &lt;&lt; 16)
                | (((binarray[i+1 &gt;&gt; 2] &gt;&gt; 8 * (3 - (i+1)%4)) &amp; 0xFF) &lt;&lt; 8 )
                |  ((binarray[i+2 &gt;&gt; 2] &gt;&gt; 8 * (3 - (i+2)%4)) &amp; 0xFF);
    for(var j = 0; j &lt; 4; j++)
    {
      if(i * 8 + j * 6 &gt; binarray.length * 32) str += b64pad;
      else str += tab.charAt((triplet &gt;&gt; 6*(3-j)) &amp; 0x3F);
    }
  }
  return str;
}

/*
 * Copyright 2008 Netflix, Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/* Here&apos;s some JavaScript software for implementing OAuth.

   This isn&apos;t as useful as you might hope.  OAuth is based around
   allowing tools and websites to talk to each other.  However,
   JavaScript running in web browsers is hampered by security
   restrictions that prevent code running on one website from
   accessing data stored or served on another.

   Before you start hacking, make sure you understand the limitations
   posed by cross-domain XMLHttpRequest.

   On the bright side, some platforms use JavaScript as their
   language, but enable the programmer to access other web sites.
   Examples include Google Gadgets, and Microsoft Vista Sidebar.
   For those platforms, this library should come in handy.
*/

// The HMAC-SHA1 signature method calls b64_hmac_sha1, defined by
// http://pajhome.org.uk/crypt/md5/sha1.js

/* An OAuth message is represented as an object like this:
   {method: &quot;GET&quot;, action: &quot;http://server.com/path&quot;, parameters: ...}

   The parameters may be either a map {name: value, name2: value2}
   or an Array of name-value pairs [[name, value], [name2, value2]].
   The latter representation is more powerful: it supports parameters
   in a specific sequence, or several parameters with the same name;
   for example [[&quot;a&quot;, 1], [&quot;b&quot;, 2], [&quot;a&quot;, 3]].

   Parameter names and values are NOT percent-encoded in an object.
   They must be encoded before transmission and decoded after reception.
   For example, this message object:
   {method: &quot;GET&quot;, action: &quot;http://server/path&quot;, parameters: {p: &quot;x y&quot;}}
   ... can be transmitted as an HTTP request that begins:
   GET /path?p=x%20y HTTP/1.0
   (This isn&apos;t a valid OAuth request, since it lacks a signature etc.)
   Note that the object &quot;x y&quot; is transmitted as x%20y.  To encode
   parameters, you can call OAuth.addToURL, OAuth.formEncode or
   OAuth.getAuthorization.

   This message object model harmonizes with the browser object model for
   input elements of an form, whose value property isn&apos;t percent encoded.
   The browser encodes each value before transmitting it. For example,
   see consumer.setInputs in example/consumer.js.
 */

/* This script needs to know what time it is. By default, it uses the local
   clock (new Date), which is apt to be inaccurate in browsers. To do
   better, you can load this script from a URL whose query string contains
   an oauth_timestamp parameter, whose value is a current Unix timestamp.
   For example, when generating the enclosing document using PHP:

   &lt;script src=&quot;oauth.js?oauth_timestamp=&lt;?=time()?&gt;&quot; ...

   Another option is to call OAuth.correctTimestamp with a Unix timestamp.
 */

var OAuth; if (OAuth == null) OAuth = {};

OAuth.setProperties = function setProperties(into, from) {
    if (into != null &amp;&amp; from != null) {
        for (var key in from) {
            into[key] = from[key];
        }
    }
    return into;
}

OAuth.setProperties(OAuth, // utility functions
{
    percentEncode: function percentEncode(s) {
        if (s == null) {
            return &quot;&quot;;
        }
        if (s instanceof Array) {
            var e = &quot;&quot;;
            for (var i = 0; i &lt; s.length; ++s) {
                if (e != &quot;&quot;) e += &apos;&amp;&apos;;
                e += OAuth.percentEncode(s[i]);
            }
            return e;
        }
        s = encodeURIComponent(s);
        // Now replace the values which encodeURIComponent doesn&apos;t do
        // encodeURIComponent ignores: - _ . ! ~ * &apos; ( )
        // OAuth dictates the only ones you can ignore are: - _ . ~
        // Source: http://developer.mozilla.org/en/docs/Core_JavaScript_1.5_Reference:Global_Functions:encodeURIComponent
        s = s.replace(/\!/g, &quot;%21&quot;);
        s = s.replace(/\*/g, &quot;%2A&quot;);
        s = s.replace(/\&apos;/g, &quot;%27&quot;);
        s = s.replace(/\(/g, &quot;%28&quot;);
        s = s.replace(/\)/g, &quot;%29&quot;);
        return s;
    }
,
    decodePercent: function decodePercent(s) {
        if (s != null) {
            // Handle application/x-www-form-urlencoded, which is defined by
            // http://www.w3.org/TR/html4/interact/forms.html#h-17.13.4.1
            s = s.replace(/\+/g, &quot; &quot;);
        }
        return decodeURIComponent(s);
    }
,
    /** Convert the given parameters to an Array of name-value pairs. */
    getParameterList: function getParameterList(parameters) {
        if (parameters == null) {
            return [];
        }
        if (typeof parameters != &quot;object&quot;) {
            return OAuth.decodeForm(parameters + &quot;&quot;);
        }
        if (parameters instanceof Array) {
            return parameters;
        }
        var list = [];
        for (var p in parameters) {
            list.push([p, parameters[p]]);
        }
        return list;
    }
,
    /** Convert the given parameters to a map from name to value. */
    getParameterMap: function getParameterMap(parameters) {
        if (parameters == null) {
            return {};
        }
        if (typeof parameters != &quot;object&quot;) {
            return OAuth.getParameterMap(OAuth.decodeForm(parameters + &quot;&quot;));
        }
        if (parameters instanceof Array) {
            var map = {};
            for (var p = 0; p &lt; parameters.length; ++p) {
                var key = parameters[p][0];
                if (map[key] === undefined) { // first value wins
                    map[key] = parameters[p][1];
                }
            }
            return map;
        }
        return parameters;
    }
,
    getParameter: function getParameter(parameters, name) {
        if (parameters instanceof Array) {
            for (var p = 0; p &lt; parameters.length; ++p) {
                if (parameters[p][0] == name) {
                    return parameters[p][1]; // first value wins
                }
            }
        } else {
            return OAuth.getParameterMap(parameters)[name];
        }
        return null;
    }
,
    formEncode: function formEncode(parameters) {
        var form = &quot;&quot;;
        var list = OAuth.getParameterList(parameters);
        for (var p = 0; p &lt; list.length; ++p) {
            var value = list[p][1];
            if (value == null) value = &quot;&quot;;
            if (form != &quot;&quot;) form += &apos;&amp;&apos;;
            form += OAuth.percentEncode(list[p][0])
              +&apos;=&apos;+ OAuth.percentEncode(value);
        }
        return form;
    }
,
    decodeForm: function decodeForm(form) {
        var list = [];
        var nvps = form.split(&apos;&amp;&apos;);
        for (var n = 0; n &lt; nvps.length; ++n) {
            var nvp = nvps[n];
            if (nvp == &quot;&quot;) {
                continue;
            }
            var equals = nvp.indexOf(&apos;=&apos;);
            var name;
            var value;
            if (equals &lt; 0) {
                name = OAuth.decodePercent(nvp);
                value = null;
            } else {
                name = OAuth.decodePercent(nvp.substring(0, equals));
                value = OAuth.decodePercent(nvp.substring(equals + 1));
            }
            list.push([name, value]);
        }
        return list;
    }
,
    setParameter: function setParameter(message, name, value) {
        var parameters = message.parameters;
        if (parameters instanceof Array) {
            for (var p = 0; p &lt; parameters.length; ++p) {
                if (parameters[p][0] == name) {
                    if (value === undefined) {
                        parameters.splice(p, 1);
                    } else {
                        parameters[p][1] = value;
                        value = undefined;
                    }
                }
            }
            if (value !== undefined) {
                parameters.push([name, value]);
            }
        } else {
            parameters = OAuth.getParameterMap(parameters);
            parameters[name] = value;
            message.parameters = parameters;
        }
    }
,
    setParameters: function setParameters(message, parameters) {
        var list = OAuth.getParameterList(parameters);
        for (var i = 0; i &lt; list.length; ++i) {
            OAuth.setParameter(message, list[i][0], list[i][1]);
        }
    }
,
    /** Fill in parameters to help construct a request message.
        This function doesn&apos;t fill in every parameter.
        The accessor object should be like:
        {consumerKey:&apos;foo&apos;, consumerSecret:&apos;bar&apos;, accessorSecret:&apos;nurn&apos;, token:&apos;krelm&apos;, tokenSecret:&apos;blah&apos;}
        The accessorSecret property is optional.
     */
    completeRequest: function completeRequest(message, accessor) {
        if (message.method == null) {
            message.method = &quot;GET&quot;;
        }
        var map = OAuth.getParameterMap(message.parameters);
        if (map.oauth_consumer_key == null) {
            OAuth.setParameter(message, &quot;oauth_consumer_key&quot;, accessor.consumerKey || &quot;&quot;);
        }
        if (map.oauth_token == null &amp;&amp; accessor.token != null) {
            OAuth.setParameter(message, &quot;oauth_token&quot;, accessor.token);
        }
        if (map.oauth_version == null) {
            OAuth.setParameter(message, &quot;oauth_version&quot;, &quot;1.0&quot;);
        }
        if (map.oauth_timestamp == null) {
            OAuth.setParameter(message, &quot;oauth_timestamp&quot;, OAuth.timestamp());
        }
        if (map.oauth_nonce == null) {
            OAuth.setParameter(message, &quot;oauth_nonce&quot;, OAuth.nonce(6));
        }
        OAuth.SignatureMethod.sign(message, accessor);
    }
,
    setTimestampAndNonce: function setTimestampAndNonce(message) {
        OAuth.setParameter(message, &quot;oauth_timestamp&quot;, OAuth.timestamp());
        OAuth.setParameter(message, &quot;oauth_nonce&quot;, OAuth.nonce(6));
    }
,
    addToURL: function addToURL(url, parameters) {
        newURL = url;
        if (parameters != null) {
            var toAdd = OAuth.formEncode(parameters);
            if (toAdd.length &gt; 0) {
                var q = url.indexOf(&apos;?&apos;);
                if (q &lt; 0) newURL += &apos;?&apos;;
                else       newURL += &apos;&amp;&apos;;
                newURL += toAdd;
            }
        }
        return newURL;
    }
,
    /** Construct the value of the Authorization header for an HTTP request. */
    getAuthorizationHeader: function getAuthorizationHeader(realm, parameters) {
        var header = &apos;OAuth realm=&quot;&apos; + OAuth.percentEncode(realm) + &apos;&quot;&apos;;
        var list = OAuth.getParameterList(parameters);
        for (var p = 0; p &lt; list.length; ++p) {
            var parameter = list[p];
            var name = parameter[0];
            if (name.indexOf(&quot;oauth_&quot;) == 0) {
                header += &apos;,&apos; + OAuth.percentEncode(name) + &apos;=&quot;&apos; + OAuth.percentEncode(parameter[1]) + &apos;&quot;&apos;;
            }
        }
        return header;
    }
,
    /** Correct the time using a parameter from the URL from which the last script was loaded. */
    correctTimestampFromSrc: function correctTimestampFromSrc(parameterName) {
        parameterName = parameterName || &quot;oauth_timestamp&quot;;
        var scripts = document.getElementsByTagName(&apos;script&apos;);
        if (scripts == null || !scripts.length) return;
        var src = scripts[scripts.length-1].src;
        if (!src) return;
        var q = src.indexOf(&quot;?&quot;);
        if (q &lt; 0) return;
        parameters = OAuth.getParameterMap(OAuth.decodeForm(src.substring(q+1)));
        var t = parameters[parameterName];
        if (t == null) return;
        OAuth.correctTimestamp(t);
    }
,
    /** Generate timestamps starting with the given value. */
    correctTimestamp: function correctTimestamp(timestamp) {
        OAuth.timeCorrectionMsec = (timestamp * 1000) - (new Date()).getTime();
    }
,
    /** The difference between the correct time and my clock. */
    timeCorrectionMsec: 0
,
    timestamp: function timestamp() {
        var t = (new Date()).getTime() + OAuth.timeCorrectionMsec;
        return Math.floor(t / 1000);
    }
,
    nonce: function nonce(length) {
        var chars = OAuth.nonce.CHARS;
        var result = &quot;&quot;;
        for (var i = 0; i &lt; length; ++i) {
            var rnum = Math.floor(Math.random() * chars.length);
            result += chars.substring(rnum, rnum+1);
        }
        return result;
    }
});

OAuth.nonce.CHARS = &quot;0123456789ABCDEFGHIJKLMNOPQRSTUVWXTZabcdefghiklmnopqrstuvwxyz&quot;;

/** Define a constructor function,
    without causing trouble to anyone who was using it as a namespace.
    That is, if parent[name] already existed and had properties,
    copy those properties into the new constructor.
 */
OAuth.declareClass = function declareClass(parent, name, newConstructor) {
    var previous = parent[name];
    parent[name] = newConstructor;
    if (newConstructor != null &amp;&amp; previous != null) {
        for (var key in previous) {
            if (key != &quot;prototype&quot;) {
                newConstructor[key] = previous[key];
            }
        }
    }
    return newConstructor;
}

/** An abstract algorithm for signing messages. */
OAuth.declareClass(OAuth, &quot;SignatureMethod&quot;, function OAuthSignatureMethod(){});

OAuth.setProperties(OAuth.SignatureMethod.prototype, // instance members
{
    /** Add a signature to the message. */
    sign: function sign(message) {
        var baseString = OAuth.SignatureMethod.getBaseString(message);
        var signature = this.getSignature(baseString);
        OAuth.setParameter(message, &quot;oauth_signature&quot;, signature);
        return signature; // just in case someone&apos;s interested
    }
,
    /** Set the key string for signing. */
    initialize: function initialize(name, accessor) {
        var consumerSecret;
        if (accessor.accessorSecret != null
            &amp;&amp; name.length &gt; 9
            &amp;&amp; name.substring(name.length-9) == &quot;-Accessor&quot;)
        {
            consumerSecret = accessor.accessorSecret;
        } else {
            consumerSecret = accessor.consumerSecret;
        }
        this.key = OAuth.percentEncode(consumerSecret)
             +&quot;&amp;&quot;+ OAuth.percentEncode(accessor.tokenSecret);
    }
});

/* SignatureMethod expects an accessor object to be like this:
   {tokenSecret: &quot;lakjsdflkj...&quot;, consumerSecret: &quot;QOUEWRI..&quot;, accessorSecret: &quot;xcmvzc...&quot;}
   The accessorSecret property is optional.
 */
// Class members:
OAuth.setProperties(OAuth.SignatureMethod, // class members
{
    sign: function sign(message, accessor) {
        var name = OAuth.getParameterMap(message.parameters).oauth_signature_method;
        if (name == null || name == &quot;&quot;) {
            name = &quot;HMAC-SHA1&quot;;
            OAuth.setParameter(message, &quot;oauth_signature_method&quot;, name);
        }
        OAuth.SignatureMethod.newMethod(name, accessor).sign(message);
    }
,
    /** Instantiate a SignatureMethod for the given method name. */
    newMethod: function newMethod(name, accessor) {
        var impl = OAuth.SignatureMethod.REGISTERED[name];
        if (impl != null) {
            var method = new impl();
            method.initialize(name, accessor);
            return method;
        }
        var err = new Error(&quot;signature_method_rejected&quot;);
        var acceptable = &quot;&quot;;
        for (var r in OAuth.SignatureMethod.REGISTERED) {
            if (acceptable != &quot;&quot;) acceptable += &apos;&amp;&apos;;
            acceptable += OAuth.percentEncode(r);
        }
        err.oauth_acceptable_signature_methods = acceptable;
        throw err;
    }
,
    /** A map from signature method name to constructor. */
    REGISTERED : {}
,
    /** Subsequently, the given constructor will be used for the named methods.
        The constructor will be called with no parameters.
        The resulting object should usually implement getSignature(baseString).
        You can easily define such a constructor by calling makeSubclass, below.
     */
    registerMethodClass: function registerMethodClass(names, classConstructor) {
        for (var n = 0; n &lt; names.length; ++n) {
            OAuth.SignatureMethod.REGISTERED[names[n]] = classConstructor;
        }
    }
,
    /** Create a subclass of OAuth.SignatureMethod, with the given getSignature function. */
    makeSubclass: function makeSubclass(getSignatureFunction) {
        var superClass = OAuth.SignatureMethod;
        var subClass = function() {
            superClass.call(this);
        };
        subClass.prototype = new superClass();
        // Delete instance variables from prototype:
        // delete subclass.prototype... There aren&apos;t any.
        subClass.prototype.getSignature = getSignatureFunction;
        subClass.prototype.constructor = subClass;
        return subClass;
    }
,
    getBaseString: function getBaseString(message) {
        var URL = message.action;
        var q = URL.indexOf(&apos;?&apos;);
        var parameters;
        if (q &lt; 0) {
            parameters = message.parameters;
        } else {
            // Combine the URL query string with the other parameters:
            parameters = OAuth.decodeForm(URL.substring(q + 1));
            var toAdd = OAuth.getParameterList(message.parameters);
            for (var a = 0; a &lt; toAdd.length; ++a) {
                parameters.push(toAdd[a]);
            }
        }
        return OAuth.percentEncode(message.method.toUpperCase())
         +&apos;&amp;&apos;+ OAuth.percentEncode(OAuth.SignatureMethod.normalizeUrl(URL))
         +&apos;&amp;&apos;+ OAuth.percentEncode(OAuth.SignatureMethod.normalizeParameters(parameters));
    }
,
    normalizeUrl: function normalizeUrl(url) {
        var uri = OAuth.SignatureMethod.parseUri(url);
        var scheme = uri.protocol.toLowerCase();
        var authority = uri.authority.toLowerCase();
        var dropPort = (scheme == &quot;http&quot; &amp;&amp; uri.port == 80)
                    || (scheme == &quot;https&quot; &amp;&amp; uri.port == 443);
        if (dropPort) {
            // find the last : in the authority
            var index = authority.lastIndexOf(&quot;:&quot;);
            if (index &gt;= 0) {
                authority = authority.substring(0, index);
            }
        }
        var path = uri.path;
        if (!path) {
            path = &quot;/&quot;; // conforms to RFC 2616 section 3.2.2
        }
        // we know that there is no query and no fragment here.
        return scheme + &quot;://&quot; + authority + path;
    }
,
    parseUri: function parseUri (str) {
        /* This function was adapted from parseUri 1.2.1
           http://stevenlevithan.com/demo/parseuri/js/assets/parseuri.js
         */
        var o = {key: [&quot;source&quot;,&quot;protocol&quot;,&quot;authority&quot;,&quot;userInfo&quot;,&quot;user&quot;,&quot;password&quot;,&quot;host&quot;,&quot;port&quot;,&quot;relative&quot;,&quot;path&quot;,&quot;directory&quot;,&quot;file&quot;,&quot;query&quot;,&quot;anchor&quot;],
                 parser: {strict: /^(?:([^:\/?#]+):)?(?:\/\/((?:(([^:@\/]*):?([^:@\/]*))?@)?([^:\/?#]*)(?::(\d*))?))?((((?:[^?#\/]*\/)*)([^?#]*))(?:\?([^#]*))?(?:#(.*))?)/ }};
        var m = o.parser.strict.exec(str);
        var uri = {};
        var i = 14;
        while (i--) uri[o.key[i]] = m[i] || &quot;&quot;;
        return uri;
    }
,
    normalizeParameters: function normalizeParameters(parameters) {
        if (parameters == null) {
            return &quot;&quot;;
        }
        var list = OAuth.getParameterList(parameters);
        var sortable = [];
        for (var p = 0; p &lt; list.length; ++p) {
            var nvp = list[p];
            if (nvp[0] != &quot;oauth_signature&quot;) {
                sortable.push([ OAuth.percentEncode(nvp[0])
                              + &quot; &quot; // because it comes before any character that can appear in a percentEncoded string.
                              + OAuth.percentEncode(nvp[1])
                              , nvp]);
            }
        }
        sortable.sort(function(a,b) {
                          if (a[0] &lt; b[0]) return  -1;
                          if (a[0] &gt; b[0]) return 1;
                          return 0;
                      });
        var sorted = [];
        for (var s = 0; s &lt; sortable.length; ++s) {
            sorted.push(sortable[s][1]);
        }
        return OAuth.formEncode(sorted);
    }
});

OAuth.SignatureMethod.registerMethodClass([&quot;PLAINTEXT&quot;, &quot;PLAINTEXT-Accessor&quot;],
    OAuth.SignatureMethod.makeSubclass(
        function getSignature(baseString) {
            return this.key;
        }
    ));

OAuth.SignatureMethod.registerMethodClass([&quot;HMAC-SHA1&quot;, &quot;HMAC-SHA1-Accessor&quot;],
    OAuth.SignatureMethod.makeSubclass(
        function getSignature(baseString) {
            b64pad = &apos;=&apos;;
            var signature = b64_hmac_sha1(this.key, baseString);
            return signature;
        }
    ));

try {
    OAuth.correctTimestampFromSrc();
} catch(e) {
}


//--------------------------------------------------

var consumerKey = &quot;${consumer_key}&quot;;
var consumerSecret = &quot;${consumer_secret}&quot;;
var params = [];
var query = [];
var url =  &quot;${protocol}://${misp_url}/marvelous/people/@me/@self&quot;;

if (query.length) {
    url += &apos;?&apos; + query.join(&apos;&amp;&apos;);
}

var message = {
    method: &apos;put&apos;,
    parameters: params, 
    action: url
};

log.info(url);
log.info(consumerSecret);

var accessor = {
    consumerKey: consumerKey,
    consumerSecret: consumerSecret,
    token:  &apos;&apos;,
    tokenSecret: &apos;&apos;
};

OAuth.completeRequest(message, accessor);
vars.put(&apos;put_auth_header&apos;, OAuth.getAuthorizationHeader(&apos;&apos;, params).replace(&apos;OAuth realm=&quot;&quot;,&apos;, &apos; OAuth &apos;));
</stringProp>
            <stringProp name="scriptLanguage">javascript</stringProp>
          </BSFPreProcessor>
          <hashTree/>
          <HeaderManager guiclass="HeaderPanel" testclass="HeaderManager" testname="HTTP ヘッダマネージャ" enabled="true">
            <collectionProp name="HeaderManager.headers">
              <elementProp name="" elementType="Header">
                <stringProp name="Header.name">Authorization</stringProp>
                <stringProp name="Header.value">${put_auth_header}</stringProp>
              </elementProp>
              <elementProp name="" elementType="Header">
                <stringProp name="Header.name">content-type</stringProp>
                <stringProp name="Header.value">application/json; charset=utf8</stringProp>
              </elementProp>
              <elementProp name="" elementType="Header">
                <stringProp name="Header.name">Connection</stringProp>
                <stringProp name="Header.value">close</stringProp>
              </elementProp>
              <elementProp name="" elementType="Header">
                <stringProp name="Header.name">Accept-encoding</stringProp>
                <stringProp name="Header.value">gzip, deflate</stringProp>
              </elementProp>
            </collectionProp>
          </HeaderManager>
          <hashTree/>
          <BSFAssertion guiclass="TestBeanGUI" testclass="BSFAssertion" testname="レスポンスコード400" enabled="true">
            <stringProp name="filename"></stringProp>
            <stringProp name="parameters"></stringProp>
            <stringProp name="script">if (prev.getResponseCode() == &quot;400&quot;) {
	AssertionResult.setFailure(false);
	prev.setSuccessful(true);
} else {
	AssertionResult.setFailure(true);
}</stringProp>
            <stringProp name="scriptLanguage">javascript</stringProp>
          </BSFAssertion>
          <hashTree/>
        </hashTree>
        <HTTPSamplerProxy guiclass="HttpTestSampleGui" testclass="HTTPSamplerProxy" testname="Implicit.ユーザ更新エラー(アクセストークンなし)" enabled="true">
          <boolProp name="HTTPSampler.postBodyRaw">true</boolProp>
          <elementProp name="HTTPsampler.Arguments" elementType="Arguments">
            <collectionProp name="Arguments.arguments">
              <elementProp name="" elementType="HTTPArgument">
                <boolProp name="HTTPArgument.always_encode">false</boolProp>
                <stringProp name="Argument.value">{&#xd;
  &quot;entry&quot;: [&#xd;
    {&#xd;
      &quot;apps&quot;: [&#xd;
        {&#xd;
          &quot;value&quot;: {&#xd;
            &quot;appId&quot;: &quot;00000&quot;,&#xd;
            &quot;userId&quot;: &quot;proxy_test_3&quot;,&#xd;
            &quot;username&quot;: &quot;trustedproxy_3&quot;,&#xd;
            &quot;password&quot;: &quot;I_have_a_dream&quot;&#xd;
          }&#xd;
        }&#xd;
      ]&#xd;
    }&#xd;
  ]&#xd;
}</stringProp>
                <stringProp name="Argument.metadata">=</stringProp>
              </elementProp>
            </collectionProp>
          </elementProp>
          <stringProp name="HTTPSampler.domain"></stringProp>
          <stringProp name="HTTPSampler.port"></stringProp>
          <stringProp name="HTTPSampler.connect_timeout"></stringProp>
          <stringProp name="HTTPSampler.response_timeout"></stringProp>
          <stringProp name="HTTPSampler.protocol"></stringProp>
          <stringProp name="HTTPSampler.contentEncoding"></stringProp>
          <stringProp name="HTTPSampler.path">/marvelous/people/@me/@self?id_token=${id_token}</stringProp>
          <stringProp name="HTTPSampler.method">PUT</stringProp>
          <boolProp name="HTTPSampler.follow_redirects">true</boolProp>
          <boolProp name="HTTPSampler.auto_redirects">false</boolProp>
          <boolProp name="HTTPSampler.use_keepalive">true</boolProp>
          <boolProp name="HTTPSampler.DO_MULTIPART_POST">false</boolProp>
          <boolProp name="HTTPSampler.monitor">false</boolProp>
          <stringProp name="HTTPSampler.embedded_url_re"></stringProp>
        </HTTPSamplerProxy>
        <hashTree>
          <BSFPreProcessor guiclass="TestBeanGUI" testclass="BSFPreProcessor" testname="BSF PreProcessor" enabled="true">
            <stringProp name="filename"></stringProp>
            <stringProp name="parameters"></stringProp>
            <stringProp name="script">/*
 * A JavaScript implementation of the Secure Hash Algorithm, SHA-1, as defined
 * in FIPS PUB 180-1
 * Version 2.1a Copyright Paul Johnston 2000 - 2002.
 * Other contributors: Greg Holt, Andrew Kepert, Ydnar, Lostinet
 * Distributed under the BSD License
 * See http://pajhome.org.uk/crypt/md5 for details.
 */

/*
 * Configurable variables. You may need to tweak these to be compatible with
 * the server-side, but the defaults work in most cases.
 */
var hexcase = 0;  /* hex output format. 0 - lowercase; 1 - uppercase        */
var b64pad  = &quot;&quot;; /* base-64 pad character. &quot;=&quot; for strict RFC compliance   */
var chrsz   = 8;  /* bits per input character. 8 - ASCII; 16 - Unicode      */

/*
 * These are the functions you&apos;ll usually want to call
 * They take string arguments and return either hex or base-64 encoded strings
 */
function hex_sha1(s){return binb2hex(core_sha1(str2binb(s),s.length * chrsz));}
function b64_sha1(s){return binb2b64(core_sha1(str2binb(s),s.length * chrsz));}
function str_sha1(s){return binb2str(core_sha1(str2binb(s),s.length * chrsz));}
function hex_hmac_sha1(key, data){ return binb2hex(core_hmac_sha1(key, data));}
function b64_hmac_sha1(key, data){ return binb2b64(core_hmac_sha1(key, data));}
function str_hmac_sha1(key, data){ return binb2str(core_hmac_sha1(key, data));}

/*
 * Perform a simple self-test to see if the VM is working
 */
function sha1_vm_test()
{
  return hex_sha1(&quot;abc&quot;) == &quot;a9993e364706816aba3e25717850c26c9cd0d89d&quot;;
}

/*
 * Calculate the SHA-1 of an array of big-endian words, and a bit length
 */
function core_sha1(x, len)
{
  /* append padding */
  x[len &gt;&gt; 5] |= 0x80 &lt;&lt; (24 - len % 32);
  x[((len + 64 &gt;&gt; 9) &lt;&lt; 4) + 15] = len;

  var w = Array(80);
  var a =  1732584193;
  var b = -271733879;
  var c = -1732584194;
  var d =  271733878;
  var e = -1009589776;

  for(var i = 0; i &lt; x.length; i += 16)
  {
    var olda = a;
    var oldb = b;
    var oldc = c;
    var oldd = d;
    var olde = e;

    for(var j = 0; j &lt; 80; j++)
    {
      if(j &lt; 16) w[j] = x[i + j];
      else w[j] = rol(w[j-3] ^ w[j-8] ^ w[j-14] ^ w[j-16], 1);
      var t = safe_add(safe_add(rol(a, 5), sha1_ft(j, b, c, d)),
                       safe_add(safe_add(e, w[j]), sha1_kt(j)));
      e = d;
      d = c;
      c = rol(b, 30);
      b = a;
      a = t;
    }

    a = safe_add(a, olda);
    b = safe_add(b, oldb);
    c = safe_add(c, oldc);
    d = safe_add(d, oldd);
    e = safe_add(e, olde);
  }
  return Array(a, b, c, d, e);

}

/*
 * Perform the appropriate triplet combination function for the current
 * iteration
 */
function sha1_ft(t, b, c, d)
{
  if(t &lt; 20) return (b &amp; c) | ((~b) &amp; d);
  if(t &lt; 40) return b ^ c ^ d;
  if(t &lt; 60) return (b &amp; c) | (b &amp; d) | (c &amp; d);
  return b ^ c ^ d;
}

/*
 * Determine the appropriate additive constant for the current iteration
 */
function sha1_kt(t)
{
  return (t &lt; 20) ?  1518500249 : (t &lt; 40) ?  1859775393 :
         (t &lt; 60) ? -1894007588 : -899497514;
}

/*
 * Calculate the HMAC-SHA1 of a key and some data
 */
function core_hmac_sha1(key, data)
{
  var bkey = str2binb(key);
  if(bkey.length &gt; 16) bkey = core_sha1(bkey, key.length * chrsz);

  var ipad = Array(16), opad = Array(16);
  for(var i = 0; i &lt; 16; i++)
  {
    ipad[i] = bkey[i] ^ 0x36363636;
    opad[i] = bkey[i] ^ 0x5C5C5C5C;
  }

  var hash = core_sha1(ipad.concat(str2binb(data)), 512 + data.length * chrsz);
  return core_sha1(opad.concat(hash), 512 + 160);
}

/*
 * Add integers, wrapping at 2^32. This uses 16-bit operations internally
 * to work around bugs in some JS interpreters.
 */
function safe_add(x, y)
{
  var lsw = (x &amp; 0xFFFF) + (y &amp; 0xFFFF);
  var msw = (x &gt;&gt; 16) + (y &gt;&gt; 16) + (lsw &gt;&gt; 16);
  return (msw &lt;&lt; 16) | (lsw &amp; 0xFFFF);
}

/*
 * Bitwise rotate a 32-bit number to the left.
 */
function rol(num, cnt)
{
  return (num &lt;&lt; cnt) | (num &gt;&gt;&gt; (32 - cnt));
}

/*
 * Convert an 8-bit or 16-bit string to an array of big-endian words
 * In 8-bit function, characters &gt;255 have their hi-byte silently ignored.
 */
function str2binb(str)
{
  var bin = Array();
  var mask = (1 &lt;&lt; chrsz) - 1;
  for(var i = 0; i &lt; str.length * chrsz; i += chrsz)
    bin[i&gt;&gt;5] |= (str.charCodeAt(i / chrsz) &amp; mask) &lt;&lt; (32 - chrsz - i%32);
  return bin;
}

/*
 * Convert an array of big-endian words to a string
 */
function binb2str(bin)
{
  var str = &quot;&quot;;
  var mask = (1 &lt;&lt; chrsz) - 1;
  for(var i = 0; i &lt; bin.length * 32; i += chrsz)
    str += String.fromCharCode((bin[i&gt;&gt;5] &gt;&gt;&gt; (32 - chrsz - i%32)) &amp; mask);
  return str;
}

/*
 * Convert an array of big-endian words to a hex string.
 */
function binb2hex(binarray)
{
  var hex_tab = hexcase ? &quot;0123456789ABCDEF&quot; : &quot;0123456789abcdef&quot;;
  var str = &quot;&quot;;
  for(var i = 0; i &lt; binarray.length * 4; i++)
  {
    str += hex_tab.charAt((binarray[i&gt;&gt;2] &gt;&gt; ((3 - i%4)*8+4)) &amp; 0xF) +
           hex_tab.charAt((binarray[i&gt;&gt;2] &gt;&gt; ((3 - i%4)*8  )) &amp; 0xF);
  }
  return str;
}

/*
 * Convert an array of big-endian words to a base-64 string
 */
function binb2b64(binarray)
{
  var tab = &quot;ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/&quot;;
  var str = &quot;&quot;;
  for(var i = 0; i &lt; binarray.length * 4; i += 3)
  {
    var triplet = (((binarray[i   &gt;&gt; 2] &gt;&gt; 8 * (3 -  i   %4)) &amp; 0xFF) &lt;&lt; 16)
                | (((binarray[i+1 &gt;&gt; 2] &gt;&gt; 8 * (3 - (i+1)%4)) &amp; 0xFF) &lt;&lt; 8 )
                |  ((binarray[i+2 &gt;&gt; 2] &gt;&gt; 8 * (3 - (i+2)%4)) &amp; 0xFF);
    for(var j = 0; j &lt; 4; j++)
    {
      if(i * 8 + j * 6 &gt; binarray.length * 32) str += b64pad;
      else str += tab.charAt((triplet &gt;&gt; 6*(3-j)) &amp; 0x3F);
    }
  }
  return str;
}

/*
 * Copyright 2008 Netflix, Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/* Here&apos;s some JavaScript software for implementing OAuth.

   This isn&apos;t as useful as you might hope.  OAuth is based around
   allowing tools and websites to talk to each other.  However,
   JavaScript running in web browsers is hampered by security
   restrictions that prevent code running on one website from
   accessing data stored or served on another.

   Before you start hacking, make sure you understand the limitations
   posed by cross-domain XMLHttpRequest.

   On the bright side, some platforms use JavaScript as their
   language, but enable the programmer to access other web sites.
   Examples include Google Gadgets, and Microsoft Vista Sidebar.
   For those platforms, this library should come in handy.
*/

// The HMAC-SHA1 signature method calls b64_hmac_sha1, defined by
// http://pajhome.org.uk/crypt/md5/sha1.js

/* An OAuth message is represented as an object like this:
   {method: &quot;GET&quot;, action: &quot;http://server.com/path&quot;, parameters: ...}

   The parameters may be either a map {name: value, name2: value2}
   or an Array of name-value pairs [[name, value], [name2, value2]].
   The latter representation is more powerful: it supports parameters
   in a specific sequence, or several parameters with the same name;
   for example [[&quot;a&quot;, 1], [&quot;b&quot;, 2], [&quot;a&quot;, 3]].

   Parameter names and values are NOT percent-encoded in an object.
   They must be encoded before transmission and decoded after reception.
   For example, this message object:
   {method: &quot;GET&quot;, action: &quot;http://server/path&quot;, parameters: {p: &quot;x y&quot;}}
   ... can be transmitted as an HTTP request that begins:
   GET /path?p=x%20y HTTP/1.0
   (This isn&apos;t a valid OAuth request, since it lacks a signature etc.)
   Note that the object &quot;x y&quot; is transmitted as x%20y.  To encode
   parameters, you can call OAuth.addToURL, OAuth.formEncode or
   OAuth.getAuthorization.

   This message object model harmonizes with the browser object model for
   input elements of an form, whose value property isn&apos;t percent encoded.
   The browser encodes each value before transmitting it. For example,
   see consumer.setInputs in example/consumer.js.
 */

/* This script needs to know what time it is. By default, it uses the local
   clock (new Date), which is apt to be inaccurate in browsers. To do
   better, you can load this script from a URL whose query string contains
   an oauth_timestamp parameter, whose value is a current Unix timestamp.
   For example, when generating the enclosing document using PHP:

   &lt;script src=&quot;oauth.js?oauth_timestamp=&lt;?=time()?&gt;&quot; ...

   Another option is to call OAuth.correctTimestamp with a Unix timestamp.
 */

var OAuth; if (OAuth == null) OAuth = {};

OAuth.setProperties = function setProperties(into, from) {
    if (into != null &amp;&amp; from != null) {
        for (var key in from) {
            into[key] = from[key];
        }
    }
    return into;
}

OAuth.setProperties(OAuth, // utility functions
{
    percentEncode: function percentEncode(s) {
        if (s == null) {
            return &quot;&quot;;
        }
        if (s instanceof Array) {
            var e = &quot;&quot;;
            for (var i = 0; i &lt; s.length; ++s) {
                if (e != &quot;&quot;) e += &apos;&amp;&apos;;
                e += OAuth.percentEncode(s[i]);
            }
            return e;
        }
        s = encodeURIComponent(s);
        // Now replace the values which encodeURIComponent doesn&apos;t do
        // encodeURIComponent ignores: - _ . ! ~ * &apos; ( )
        // OAuth dictates the only ones you can ignore are: - _ . ~
        // Source: http://developer.mozilla.org/en/docs/Core_JavaScript_1.5_Reference:Global_Functions:encodeURIComponent
        s = s.replace(/\!/g, &quot;%21&quot;);
        s = s.replace(/\*/g, &quot;%2A&quot;);
        s = s.replace(/\&apos;/g, &quot;%27&quot;);
        s = s.replace(/\(/g, &quot;%28&quot;);
        s = s.replace(/\)/g, &quot;%29&quot;);
        return s;
    }
,
    decodePercent: function decodePercent(s) {
        if (s != null) {
            // Handle application/x-www-form-urlencoded, which is defined by
            // http://www.w3.org/TR/html4/interact/forms.html#h-17.13.4.1
            s = s.replace(/\+/g, &quot; &quot;);
        }
        return decodeURIComponent(s);
    }
,
    /** Convert the given parameters to an Array of name-value pairs. */
    getParameterList: function getParameterList(parameters) {
        if (parameters == null) {
            return [];
        }
        if (typeof parameters != &quot;object&quot;) {
            return OAuth.decodeForm(parameters + &quot;&quot;);
        }
        if (parameters instanceof Array) {
            return parameters;
        }
        var list = [];
        for (var p in parameters) {
            list.push([p, parameters[p]]);
        }
        return list;
    }
,
    /** Convert the given parameters to a map from name to value. */
    getParameterMap: function getParameterMap(parameters) {
        if (parameters == null) {
            return {};
        }
        if (typeof parameters != &quot;object&quot;) {
            return OAuth.getParameterMap(OAuth.decodeForm(parameters + &quot;&quot;));
        }
        if (parameters instanceof Array) {
            var map = {};
            for (var p = 0; p &lt; parameters.length; ++p) {
                var key = parameters[p][0];
                if (map[key] === undefined) { // first value wins
                    map[key] = parameters[p][1];
                }
            }
            return map;
        }
        return parameters;
    }
,
    getParameter: function getParameter(parameters, name) {
        if (parameters instanceof Array) {
            for (var p = 0; p &lt; parameters.length; ++p) {
                if (parameters[p][0] == name) {
                    return parameters[p][1]; // first value wins
                }
            }
        } else {
            return OAuth.getParameterMap(parameters)[name];
        }
        return null;
    }
,
    formEncode: function formEncode(parameters) {
        var form = &quot;&quot;;
        var list = OAuth.getParameterList(parameters);
        for (var p = 0; p &lt; list.length; ++p) {
            var value = list[p][1];
            if (value == null) value = &quot;&quot;;
            if (form != &quot;&quot;) form += &apos;&amp;&apos;;
            form += OAuth.percentEncode(list[p][0])
              +&apos;=&apos;+ OAuth.percentEncode(value);
        }
        return form;
    }
,
    decodeForm: function decodeForm(form) {
        var list = [];
        var nvps = form.split(&apos;&amp;&apos;);
        for (var n = 0; n &lt; nvps.length; ++n) {
            var nvp = nvps[n];
            if (nvp == &quot;&quot;) {
                continue;
            }
            var equals = nvp.indexOf(&apos;=&apos;);
            var name;
            var value;
            if (equals &lt; 0) {
                name = OAuth.decodePercent(nvp);
                value = null;
            } else {
                name = OAuth.decodePercent(nvp.substring(0, equals));
                value = OAuth.decodePercent(nvp.substring(equals + 1));
            }
            list.push([name, value]);
        }
        return list;
    }
,
    setParameter: function setParameter(message, name, value) {
        var parameters = message.parameters;
        if (parameters instanceof Array) {
            for (var p = 0; p &lt; parameters.length; ++p) {
                if (parameters[p][0] == name) {
                    if (value === undefined) {
                        parameters.splice(p, 1);
                    } else {
                        parameters[p][1] = value;
                        value = undefined;
                    }
                }
            }
            if (value !== undefined) {
                parameters.push([name, value]);
            }
        } else {
            parameters = OAuth.getParameterMap(parameters);
            parameters[name] = value;
            message.parameters = parameters;
        }
    }
,
    setParameters: function setParameters(message, parameters) {
        var list = OAuth.getParameterList(parameters);
        for (var i = 0; i &lt; list.length; ++i) {
            OAuth.setParameter(message, list[i][0], list[i][1]);
        }
    }
,
    /** Fill in parameters to help construct a request message.
        This function doesn&apos;t fill in every parameter.
        The accessor object should be like:
        {consumerKey:&apos;foo&apos;, consumerSecret:&apos;bar&apos;, accessorSecret:&apos;nurn&apos;, token:&apos;krelm&apos;, tokenSecret:&apos;blah&apos;}
        The accessorSecret property is optional.
     */
    completeRequest: function completeRequest(message, accessor) {
        if (message.method == null) {
            message.method = &quot;GET&quot;;
        }
        var map = OAuth.getParameterMap(message.parameters);
        if (map.oauth_consumer_key == null) {
            OAuth.setParameter(message, &quot;oauth_consumer_key&quot;, accessor.consumerKey || &quot;&quot;);
        }
        if (map.oauth_token == null &amp;&amp; accessor.token != null) {
            OAuth.setParameter(message, &quot;oauth_token&quot;, accessor.token);
        }
        if (map.oauth_version == null) {
            OAuth.setParameter(message, &quot;oauth_version&quot;, &quot;1.0&quot;);
        }
        if (map.oauth_timestamp == null) {
            OAuth.setParameter(message, &quot;oauth_timestamp&quot;, OAuth.timestamp());
        }
        if (map.oauth_nonce == null) {
            OAuth.setParameter(message, &quot;oauth_nonce&quot;, OAuth.nonce(6));
        }
        OAuth.SignatureMethod.sign(message, accessor);
    }
,
    setTimestampAndNonce: function setTimestampAndNonce(message) {
        OAuth.setParameter(message, &quot;oauth_timestamp&quot;, OAuth.timestamp());
        OAuth.setParameter(message, &quot;oauth_nonce&quot;, OAuth.nonce(6));
    }
,
    addToURL: function addToURL(url, parameters) {
        newURL = url;
        if (parameters != null) {
            var toAdd = OAuth.formEncode(parameters);
            if (toAdd.length &gt; 0) {
                var q = url.indexOf(&apos;?&apos;);
                if (q &lt; 0) newURL += &apos;?&apos;;
                else       newURL += &apos;&amp;&apos;;
                newURL += toAdd;
            }
        }
        return newURL;
    }
,
    /** Construct the value of the Authorization header for an HTTP request. */
    getAuthorizationHeader: function getAuthorizationHeader(realm, parameters) {
        var header = &apos;OAuth realm=&quot;&apos; + OAuth.percentEncode(realm) + &apos;&quot;&apos;;
        var list = OAuth.getParameterList(parameters);
        for (var p = 0; p &lt; list.length; ++p) {
            var parameter = list[p];
            var name = parameter[0];
            if (name.indexOf(&quot;oauth_&quot;) == 0) {
                header += &apos;,&apos; + OAuth.percentEncode(name) + &apos;=&quot;&apos; + OAuth.percentEncode(parameter[1]) + &apos;&quot;&apos;;
            }
        }
        return header;
    }
,
    /** Correct the time using a parameter from the URL from which the last script was loaded. */
    correctTimestampFromSrc: function correctTimestampFromSrc(parameterName) {
        parameterName = parameterName || &quot;oauth_timestamp&quot;;
        var scripts = document.getElementsByTagName(&apos;script&apos;);
        if (scripts == null || !scripts.length) return;
        var src = scripts[scripts.length-1].src;
        if (!src) return;
        var q = src.indexOf(&quot;?&quot;);
        if (q &lt; 0) return;
        parameters = OAuth.getParameterMap(OAuth.decodeForm(src.substring(q+1)));
        var t = parameters[parameterName];
        if (t == null) return;
        OAuth.correctTimestamp(t);
    }
,
    /** Generate timestamps starting with the given value. */
    correctTimestamp: function correctTimestamp(timestamp) {
        OAuth.timeCorrectionMsec = (timestamp * 1000) - (new Date()).getTime();
    }
,
    /** The difference between the correct time and my clock. */
    timeCorrectionMsec: 0
,
    timestamp: function timestamp() {
        var t = (new Date()).getTime() + OAuth.timeCorrectionMsec;
        return Math.floor(t / 1000);
    }
,
    nonce: function nonce(length) {
        var chars = OAuth.nonce.CHARS;
        var result = &quot;&quot;;
        for (var i = 0; i &lt; length; ++i) {
            var rnum = Math.floor(Math.random() * chars.length);
            result += chars.substring(rnum, rnum+1);
        }
        return result;
    }
});

OAuth.nonce.CHARS = &quot;0123456789ABCDEFGHIJKLMNOPQRSTUVWXTZabcdefghiklmnopqrstuvwxyz&quot;;

/** Define a constructor function,
    without causing trouble to anyone who was using it as a namespace.
    That is, if parent[name] already existed and had properties,
    copy those properties into the new constructor.
 */
OAuth.declareClass = function declareClass(parent, name, newConstructor) {
    var previous = parent[name];
    parent[name] = newConstructor;
    if (newConstructor != null &amp;&amp; previous != null) {
        for (var key in previous) {
            if (key != &quot;prototype&quot;) {
                newConstructor[key] = previous[key];
            }
        }
    }
    return newConstructor;
}

/** An abstract algorithm for signing messages. */
OAuth.declareClass(OAuth, &quot;SignatureMethod&quot;, function OAuthSignatureMethod(){});

OAuth.setProperties(OAuth.SignatureMethod.prototype, // instance members
{
    /** Add a signature to the message. */
    sign: function sign(message) {
        var baseString = OAuth.SignatureMethod.getBaseString(message);
        var signature = this.getSignature(baseString);
        OAuth.setParameter(message, &quot;oauth_signature&quot;, signature);
        return signature; // just in case someone&apos;s interested
    }
,
    /** Set the key string for signing. */
    initialize: function initialize(name, accessor) {
        var consumerSecret;
        if (accessor.accessorSecret != null
            &amp;&amp; name.length &gt; 9
            &amp;&amp; name.substring(name.length-9) == &quot;-Accessor&quot;)
        {
            consumerSecret = accessor.accessorSecret;
        } else {
            consumerSecret = accessor.consumerSecret;
        }
        this.key = OAuth.percentEncode(consumerSecret)
             +&quot;&amp;&quot;+ OAuth.percentEncode(accessor.tokenSecret);
    }
});

/* SignatureMethod expects an accessor object to be like this:
   {tokenSecret: &quot;lakjsdflkj...&quot;, consumerSecret: &quot;QOUEWRI..&quot;, accessorSecret: &quot;xcmvzc...&quot;}
   The accessorSecret property is optional.
 */
// Class members:
OAuth.setProperties(OAuth.SignatureMethod, // class members
{
    sign: function sign(message, accessor) {
        var name = OAuth.getParameterMap(message.parameters).oauth_signature_method;
        if (name == null || name == &quot;&quot;) {
            name = &quot;HMAC-SHA1&quot;;
            OAuth.setParameter(message, &quot;oauth_signature_method&quot;, name);
        }
        OAuth.SignatureMethod.newMethod(name, accessor).sign(message);
    }
,
    /** Instantiate a SignatureMethod for the given method name. */
    newMethod: function newMethod(name, accessor) {
        var impl = OAuth.SignatureMethod.REGISTERED[name];
        if (impl != null) {
            var method = new impl();
            method.initialize(name, accessor);
            return method;
        }
        var err = new Error(&quot;signature_method_rejected&quot;);
        var acceptable = &quot;&quot;;
        for (var r in OAuth.SignatureMethod.REGISTERED) {
            if (acceptable != &quot;&quot;) acceptable += &apos;&amp;&apos;;
            acceptable += OAuth.percentEncode(r);
        }
        err.oauth_acceptable_signature_methods = acceptable;
        throw err;
    }
,
    /** A map from signature method name to constructor. */
    REGISTERED : {}
,
    /** Subsequently, the given constructor will be used for the named methods.
        The constructor will be called with no parameters.
        The resulting object should usually implement getSignature(baseString).
        You can easily define such a constructor by calling makeSubclass, below.
     */
    registerMethodClass: function registerMethodClass(names, classConstructor) {
        for (var n = 0; n &lt; names.length; ++n) {
            OAuth.SignatureMethod.REGISTERED[names[n]] = classConstructor;
        }
    }
,
    /** Create a subclass of OAuth.SignatureMethod, with the given getSignature function. */
    makeSubclass: function makeSubclass(getSignatureFunction) {
        var superClass = OAuth.SignatureMethod;
        var subClass = function() {
            superClass.call(this);
        };
        subClass.prototype = new superClass();
        // Delete instance variables from prototype:
        // delete subclass.prototype... There aren&apos;t any.
        subClass.prototype.getSignature = getSignatureFunction;
        subClass.prototype.constructor = subClass;
        return subClass;
    }
,
    getBaseString: function getBaseString(message) {
        var URL = message.action;
        var q = URL.indexOf(&apos;?&apos;);
        var parameters;
        if (q &lt; 0) {
            parameters = message.parameters;
        } else {
            // Combine the URL query string with the other parameters:
            parameters = OAuth.decodeForm(URL.substring(q + 1));
            var toAdd = OAuth.getParameterList(message.parameters);
            for (var a = 0; a &lt; toAdd.length; ++a) {
                parameters.push(toAdd[a]);
            }
        }
        return OAuth.percentEncode(message.method.toUpperCase())
         +&apos;&amp;&apos;+ OAuth.percentEncode(OAuth.SignatureMethod.normalizeUrl(URL))
         +&apos;&amp;&apos;+ OAuth.percentEncode(OAuth.SignatureMethod.normalizeParameters(parameters));
    }
,
    normalizeUrl: function normalizeUrl(url) {
        var uri = OAuth.SignatureMethod.parseUri(url);
        var scheme = uri.protocol.toLowerCase();
        var authority = uri.authority.toLowerCase();
        var dropPort = (scheme == &quot;http&quot; &amp;&amp; uri.port == 80)
                    || (scheme == &quot;https&quot; &amp;&amp; uri.port == 443);
        if (dropPort) {
            // find the last : in the authority
            var index = authority.lastIndexOf(&quot;:&quot;);
            if (index &gt;= 0) {
                authority = authority.substring(0, index);
            }
        }
        var path = uri.path;
        if (!path) {
            path = &quot;/&quot;; // conforms to RFC 2616 section 3.2.2
        }
        // we know that there is no query and no fragment here.
        return scheme + &quot;://&quot; + authority + path;
    }
,
    parseUri: function parseUri (str) {
        /* This function was adapted from parseUri 1.2.1
           http://stevenlevithan.com/demo/parseuri/js/assets/parseuri.js
         */
        var o = {key: [&quot;source&quot;,&quot;protocol&quot;,&quot;authority&quot;,&quot;userInfo&quot;,&quot;user&quot;,&quot;password&quot;,&quot;host&quot;,&quot;port&quot;,&quot;relative&quot;,&quot;path&quot;,&quot;directory&quot;,&quot;file&quot;,&quot;query&quot;,&quot;anchor&quot;],
                 parser: {strict: /^(?:([^:\/?#]+):)?(?:\/\/((?:(([^:@\/]*):?([^:@\/]*))?@)?([^:\/?#]*)(?::(\d*))?))?((((?:[^?#\/]*\/)*)([^?#]*))(?:\?([^#]*))?(?:#(.*))?)/ }};
        var m = o.parser.strict.exec(str);
        var uri = {};
        var i = 14;
        while (i--) uri[o.key[i]] = m[i] || &quot;&quot;;
        return uri;
    }
,
    normalizeParameters: function normalizeParameters(parameters) {
        if (parameters == null) {
            return &quot;&quot;;
        }
        var list = OAuth.getParameterList(parameters);
        var sortable = [];
        for (var p = 0; p &lt; list.length; ++p) {
            var nvp = list[p];
            if (nvp[0] != &quot;oauth_signature&quot;) {
                sortable.push([ OAuth.percentEncode(nvp[0])
                              + &quot; &quot; // because it comes before any character that can appear in a percentEncoded string.
                              + OAuth.percentEncode(nvp[1])
                              , nvp]);
            }
        }
        sortable.sort(function(a,b) {
                          if (a[0] &lt; b[0]) return  -1;
                          if (a[0] &gt; b[0]) return 1;
                          return 0;
                      });
        var sorted = [];
        for (var s = 0; s &lt; sortable.length; ++s) {
            sorted.push(sortable[s][1]);
        }
        return OAuth.formEncode(sorted);
    }
});

OAuth.SignatureMethod.registerMethodClass([&quot;PLAINTEXT&quot;, &quot;PLAINTEXT-Accessor&quot;],
    OAuth.SignatureMethod.makeSubclass(
        function getSignature(baseString) {
            return this.key;
        }
    ));

OAuth.SignatureMethod.registerMethodClass([&quot;HMAC-SHA1&quot;, &quot;HMAC-SHA1-Accessor&quot;],
    OAuth.SignatureMethod.makeSubclass(
        function getSignature(baseString) {
            b64pad = &apos;=&apos;;
            var signature = b64_hmac_sha1(this.key, baseString);
            return signature;
        }
    ));

try {
    OAuth.correctTimestampFromSrc();
} catch(e) {
}


//--------------------------------------------------

var consumerKey = &quot;${consumer_key}&quot;;
var consumerSecret = &quot;${consumer_secret}&quot;;
var params = [];
var query = [];
query.push(&apos;access_token&apos; + &apos;=&apos; + &apos;&apos;);
query.push(&apos;id_token&apos; + &apos;=&apos; + &apos;${id_token}&apos;);
var url =  &quot;${protocol}://${misp_url}/marvelous/people/@me/@self&quot;;

if (query.length) {
    url += &apos;?&apos; + query.join(&apos;&amp;&apos;);
}

var message = {
    method: &apos;put&apos;,
    parameters: params, 
    action: url
};

log.info(url);
log.info(consumerSecret);

var accessor = {
    consumerKey: consumerKey,
    consumerSecret: consumerSecret,
    token:  &apos;&apos;,
    tokenSecret: &apos;${id_token}&apos;
};

OAuth.completeRequest(message, accessor);
vars.put(&apos;put_auth_header&apos;, OAuth.getAuthorizationHeader(&apos;&apos;, params).replace(&apos;OAuth realm=&quot;&quot;,&apos;, &apos; OAuth &apos;));
</stringProp>
            <stringProp name="scriptLanguage">javascript</stringProp>
          </BSFPreProcessor>
          <hashTree/>
          <HeaderManager guiclass="HeaderPanel" testclass="HeaderManager" testname="HTTP ヘッダマネージャ" enabled="true">
            <collectionProp name="HeaderManager.headers">
              <elementProp name="" elementType="Header">
                <stringProp name="Header.name">Authorization</stringProp>
                <stringProp name="Header.value">${put_auth_header}</stringProp>
              </elementProp>
              <elementProp name="" elementType="Header">
                <stringProp name="Header.name">content-type</stringProp>
                <stringProp name="Header.value">application/json; charset=utf8</stringProp>
              </elementProp>
              <elementProp name="" elementType="Header">
                <stringProp name="Header.name">Connection</stringProp>
                <stringProp name="Header.value">close</stringProp>
              </elementProp>
              <elementProp name="" elementType="Header">
                <stringProp name="Header.name">Accept-encoding</stringProp>
                <stringProp name="Header.value">gzip, deflate</stringProp>
              </elementProp>
            </collectionProp>
          </HeaderManager>
          <hashTree/>
          <BSFAssertion guiclass="TestBeanGUI" testclass="BSFAssertion" testname="レスポンスコード401" enabled="true">
            <stringProp name="filename"></stringProp>
            <stringProp name="parameters"></stringProp>
            <stringProp name="script">if (prev.getResponseCode() == &quot;401&quot;) {
	AssertionResult.setFailure(false);
	prev.setSuccessful(true);
} else {
	AssertionResult.setFailure(true);
	AssertionResult.setFailureMessage(prev.getResponseCode());
}</stringProp>
            <stringProp name="scriptLanguage">javascript</stringProp>
          </BSFAssertion>
          <hashTree/>
        </hashTree>
        <HTTPSamplerProxy guiclass="HttpTestSampleGui" testclass="HTTPSamplerProxy" testname="Implicit.ユーザ更新エラー(トークンエラー)" enabled="true">
          <boolProp name="HTTPSampler.postBodyRaw">true</boolProp>
          <elementProp name="HTTPsampler.Arguments" elementType="Arguments">
            <collectionProp name="Arguments.arguments">
              <elementProp name="" elementType="HTTPArgument">
                <boolProp name="HTTPArgument.always_encode">false</boolProp>
                <stringProp name="Argument.value">{&#xd;
  &quot;entry&quot;: [&#xd;
    {&#xd;
      &quot;apps&quot;: [&#xd;
        {&#xd;
          &quot;value&quot;: {&#xd;
            &quot;appId&quot;: &quot;00000&quot;,&#xd;
            &quot;userId&quot;: &quot;proxy_test_3&quot;,&#xd;
            &quot;username&quot;: &quot;trustedproxy_3&quot;,&#xd;
            &quot;password&quot;: &quot;I_have_a_dream&quot;&#xd;
          }&#xd;
        }&#xd;
      ]&#xd;
    }&#xd;
  ]&#xd;
}</stringProp>
                <stringProp name="Argument.metadata">=</stringProp>
              </elementProp>
            </collectionProp>
          </elementProp>
          <stringProp name="HTTPSampler.domain"></stringProp>
          <stringProp name="HTTPSampler.port"></stringProp>
          <stringProp name="HTTPSampler.connect_timeout"></stringProp>
          <stringProp name="HTTPSampler.response_timeout"></stringProp>
          <stringProp name="HTTPSampler.protocol"></stringProp>
          <stringProp name="HTTPSampler.contentEncoding"></stringProp>
          <stringProp name="HTTPSampler.path">/marvelous/people/@me/@self?access_token=kataiteeeeeeeeeeeeeeeeeee&amp;id_token=${id_token}</stringProp>
          <stringProp name="HTTPSampler.method">PUT</stringProp>
          <boolProp name="HTTPSampler.follow_redirects">true</boolProp>
          <boolProp name="HTTPSampler.auto_redirects">false</boolProp>
          <boolProp name="HTTPSampler.use_keepalive">true</boolProp>
          <boolProp name="HTTPSampler.DO_MULTIPART_POST">false</boolProp>
          <boolProp name="HTTPSampler.monitor">false</boolProp>
          <stringProp name="HTTPSampler.embedded_url_re"></stringProp>
        </HTTPSamplerProxy>
        <hashTree>
          <BSFPreProcessor guiclass="TestBeanGUI" testclass="BSFPreProcessor" testname="BSF PreProcessor" enabled="true">
            <stringProp name="filename"></stringProp>
            <stringProp name="parameters"></stringProp>
            <stringProp name="script">/*
 * A JavaScript implementation of the Secure Hash Algorithm, SHA-1, as defined
 * in FIPS PUB 180-1
 * Version 2.1a Copyright Paul Johnston 2000 - 2002.
 * Other contributors: Greg Holt, Andrew Kepert, Ydnar, Lostinet
 * Distributed under the BSD License
 * See http://pajhome.org.uk/crypt/md5 for details.
 */

/*
 * Configurable variables. You may need to tweak these to be compatible with
 * the server-side, but the defaults work in most cases.
 */
var hexcase = 0;  /* hex output format. 0 - lowercase; 1 - uppercase        */
var b64pad  = &quot;&quot;; /* base-64 pad character. &quot;=&quot; for strict RFC compliance   */
var chrsz   = 8;  /* bits per input character. 8 - ASCII; 16 - Unicode      */

/*
 * These are the functions you&apos;ll usually want to call
 * They take string arguments and return either hex or base-64 encoded strings
 */
function hex_sha1(s){return binb2hex(core_sha1(str2binb(s),s.length * chrsz));}
function b64_sha1(s){return binb2b64(core_sha1(str2binb(s),s.length * chrsz));}
function str_sha1(s){return binb2str(core_sha1(str2binb(s),s.length * chrsz));}
function hex_hmac_sha1(key, data){ return binb2hex(core_hmac_sha1(key, data));}
function b64_hmac_sha1(key, data){ return binb2b64(core_hmac_sha1(key, data));}
function str_hmac_sha1(key, data){ return binb2str(core_hmac_sha1(key, data));}

/*
 * Perform a simple self-test to see if the VM is working
 */
function sha1_vm_test()
{
  return hex_sha1(&quot;abc&quot;) == &quot;a9993e364706816aba3e25717850c26c9cd0d89d&quot;;
}

/*
 * Calculate the SHA-1 of an array of big-endian words, and a bit length
 */
function core_sha1(x, len)
{
  /* append padding */
  x[len &gt;&gt; 5] |= 0x80 &lt;&lt; (24 - len % 32);
  x[((len + 64 &gt;&gt; 9) &lt;&lt; 4) + 15] = len;

  var w = Array(80);
  var a =  1732584193;
  var b = -271733879;
  var c = -1732584194;
  var d =  271733878;
  var e = -1009589776;

  for(var i = 0; i &lt; x.length; i += 16)
  {
    var olda = a;
    var oldb = b;
    var oldc = c;
    var oldd = d;
    var olde = e;

    for(var j = 0; j &lt; 80; j++)
    {
      if(j &lt; 16) w[j] = x[i + j];
      else w[j] = rol(w[j-3] ^ w[j-8] ^ w[j-14] ^ w[j-16], 1);
      var t = safe_add(safe_add(rol(a, 5), sha1_ft(j, b, c, d)),
                       safe_add(safe_add(e, w[j]), sha1_kt(j)));
      e = d;
      d = c;
      c = rol(b, 30);
      b = a;
      a = t;
    }

    a = safe_add(a, olda);
    b = safe_add(b, oldb);
    c = safe_add(c, oldc);
    d = safe_add(d, oldd);
    e = safe_add(e, olde);
  }
  return Array(a, b, c, d, e);

}

/*
 * Perform the appropriate triplet combination function for the current
 * iteration
 */
function sha1_ft(t, b, c, d)
{
  if(t &lt; 20) return (b &amp; c) | ((~b) &amp; d);
  if(t &lt; 40) return b ^ c ^ d;
  if(t &lt; 60) return (b &amp; c) | (b &amp; d) | (c &amp; d);
  return b ^ c ^ d;
}

/*
 * Determine the appropriate additive constant for the current iteration
 */
function sha1_kt(t)
{
  return (t &lt; 20) ?  1518500249 : (t &lt; 40) ?  1859775393 :
         (t &lt; 60) ? -1894007588 : -899497514;
}

/*
 * Calculate the HMAC-SHA1 of a key and some data
 */
function core_hmac_sha1(key, data)
{
  var bkey = str2binb(key);
  if(bkey.length &gt; 16) bkey = core_sha1(bkey, key.length * chrsz);

  var ipad = Array(16), opad = Array(16);
  for(var i = 0; i &lt; 16; i++)
  {
    ipad[i] = bkey[i] ^ 0x36363636;
    opad[i] = bkey[i] ^ 0x5C5C5C5C;
  }

  var hash = core_sha1(ipad.concat(str2binb(data)), 512 + data.length * chrsz);
  return core_sha1(opad.concat(hash), 512 + 160);
}

/*
 * Add integers, wrapping at 2^32. This uses 16-bit operations internally
 * to work around bugs in some JS interpreters.
 */
function safe_add(x, y)
{
  var lsw = (x &amp; 0xFFFF) + (y &amp; 0xFFFF);
  var msw = (x &gt;&gt; 16) + (y &gt;&gt; 16) + (lsw &gt;&gt; 16);
  return (msw &lt;&lt; 16) | (lsw &amp; 0xFFFF);
}

/*
 * Bitwise rotate a 32-bit number to the left.
 */
function rol(num, cnt)
{
  return (num &lt;&lt; cnt) | (num &gt;&gt;&gt; (32 - cnt));
}

/*
 * Convert an 8-bit or 16-bit string to an array of big-endian words
 * In 8-bit function, characters &gt;255 have their hi-byte silently ignored.
 */
function str2binb(str)
{
  var bin = Array();
  var mask = (1 &lt;&lt; chrsz) - 1;
  for(var i = 0; i &lt; str.length * chrsz; i += chrsz)
    bin[i&gt;&gt;5] |= (str.charCodeAt(i / chrsz) &amp; mask) &lt;&lt; (32 - chrsz - i%32);
  return bin;
}

/*
 * Convert an array of big-endian words to a string
 */
function binb2str(bin)
{
  var str = &quot;&quot;;
  var mask = (1 &lt;&lt; chrsz) - 1;
  for(var i = 0; i &lt; bin.length * 32; i += chrsz)
    str += String.fromCharCode((bin[i&gt;&gt;5] &gt;&gt;&gt; (32 - chrsz - i%32)) &amp; mask);
  return str;
}

/*
 * Convert an array of big-endian words to a hex string.
 */
function binb2hex(binarray)
{
  var hex_tab = hexcase ? &quot;0123456789ABCDEF&quot; : &quot;0123456789abcdef&quot;;
  var str = &quot;&quot;;
  for(var i = 0; i &lt; binarray.length * 4; i++)
  {
    str += hex_tab.charAt((binarray[i&gt;&gt;2] &gt;&gt; ((3 - i%4)*8+4)) &amp; 0xF) +
           hex_tab.charAt((binarray[i&gt;&gt;2] &gt;&gt; ((3 - i%4)*8  )) &amp; 0xF);
  }
  return str;
}

/*
 * Convert an array of big-endian words to a base-64 string
 */
function binb2b64(binarray)
{
  var tab = &quot;ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/&quot;;
  var str = &quot;&quot;;
  for(var i = 0; i &lt; binarray.length * 4; i += 3)
  {
    var triplet = (((binarray[i   &gt;&gt; 2] &gt;&gt; 8 * (3 -  i   %4)) &amp; 0xFF) &lt;&lt; 16)
                | (((binarray[i+1 &gt;&gt; 2] &gt;&gt; 8 * (3 - (i+1)%4)) &amp; 0xFF) &lt;&lt; 8 )
                |  ((binarray[i+2 &gt;&gt; 2] &gt;&gt; 8 * (3 - (i+2)%4)) &amp; 0xFF);
    for(var j = 0; j &lt; 4; j++)
    {
      if(i * 8 + j * 6 &gt; binarray.length * 32) str += b64pad;
      else str += tab.charAt((triplet &gt;&gt; 6*(3-j)) &amp; 0x3F);
    }
  }
  return str;
}

/*
 * Copyright 2008 Netflix, Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/* Here&apos;s some JavaScript software for implementing OAuth.

   This isn&apos;t as useful as you might hope.  OAuth is based around
   allowing tools and websites to talk to each other.  However,
   JavaScript running in web browsers is hampered by security
   restrictions that prevent code running on one website from
   accessing data stored or served on another.

   Before you start hacking, make sure you understand the limitations
   posed by cross-domain XMLHttpRequest.

   On the bright side, some platforms use JavaScript as their
   language, but enable the programmer to access other web sites.
   Examples include Google Gadgets, and Microsoft Vista Sidebar.
   For those platforms, this library should come in handy.
*/

// The HMAC-SHA1 signature method calls b64_hmac_sha1, defined by
// http://pajhome.org.uk/crypt/md5/sha1.js

/* An OAuth message is represented as an object like this:
   {method: &quot;GET&quot;, action: &quot;http://server.com/path&quot;, parameters: ...}

   The parameters may be either a map {name: value, name2: value2}
   or an Array of name-value pairs [[name, value], [name2, value2]].
   The latter representation is more powerful: it supports parameters
   in a specific sequence, or several parameters with the same name;
   for example [[&quot;a&quot;, 1], [&quot;b&quot;, 2], [&quot;a&quot;, 3]].

   Parameter names and values are NOT percent-encoded in an object.
   They must be encoded before transmission and decoded after reception.
   For example, this message object:
   {method: &quot;GET&quot;, action: &quot;http://server/path&quot;, parameters: {p: &quot;x y&quot;}}
   ... can be transmitted as an HTTP request that begins:
   GET /path?p=x%20y HTTP/1.0
   (This isn&apos;t a valid OAuth request, since it lacks a signature etc.)
   Note that the object &quot;x y&quot; is transmitted as x%20y.  To encode
   parameters, you can call OAuth.addToURL, OAuth.formEncode or
   OAuth.getAuthorization.

   This message object model harmonizes with the browser object model for
   input elements of an form, whose value property isn&apos;t percent encoded.
   The browser encodes each value before transmitting it. For example,
   see consumer.setInputs in example/consumer.js.
 */

/* This script needs to know what time it is. By default, it uses the local
   clock (new Date), which is apt to be inaccurate in browsers. To do
   better, you can load this script from a URL whose query string contains
   an oauth_timestamp parameter, whose value is a current Unix timestamp.
   For example, when generating the enclosing document using PHP:

   &lt;script src=&quot;oauth.js?oauth_timestamp=&lt;?=time()?&gt;&quot; ...

   Another option is to call OAuth.correctTimestamp with a Unix timestamp.
 */

var OAuth; if (OAuth == null) OAuth = {};

OAuth.setProperties = function setProperties(into, from) {
    if (into != null &amp;&amp; from != null) {
        for (var key in from) {
            into[key] = from[key];
        }
    }
    return into;
}

OAuth.setProperties(OAuth, // utility functions
{
    percentEncode: function percentEncode(s) {
        if (s == null) {
            return &quot;&quot;;
        }
        if (s instanceof Array) {
            var e = &quot;&quot;;
            for (var i = 0; i &lt; s.length; ++s) {
                if (e != &quot;&quot;) e += &apos;&amp;&apos;;
                e += OAuth.percentEncode(s[i]);
            }
            return e;
        }
        s = encodeURIComponent(s);
        // Now replace the values which encodeURIComponent doesn&apos;t do
        // encodeURIComponent ignores: - _ . ! ~ * &apos; ( )
        // OAuth dictates the only ones you can ignore are: - _ . ~
        // Source: http://developer.mozilla.org/en/docs/Core_JavaScript_1.5_Reference:Global_Functions:encodeURIComponent
        s = s.replace(/\!/g, &quot;%21&quot;);
        s = s.replace(/\*/g, &quot;%2A&quot;);
        s = s.replace(/\&apos;/g, &quot;%27&quot;);
        s = s.replace(/\(/g, &quot;%28&quot;);
        s = s.replace(/\)/g, &quot;%29&quot;);
        return s;
    }
,
    decodePercent: function decodePercent(s) {
        if (s != null) {
            // Handle application/x-www-form-urlencoded, which is defined by
            // http://www.w3.org/TR/html4/interact/forms.html#h-17.13.4.1
            s = s.replace(/\+/g, &quot; &quot;);
        }
        return decodeURIComponent(s);
    }
,
    /** Convert the given parameters to an Array of name-value pairs. */
    getParameterList: function getParameterList(parameters) {
        if (parameters == null) {
            return [];
        }
        if (typeof parameters != &quot;object&quot;) {
            return OAuth.decodeForm(parameters + &quot;&quot;);
        }
        if (parameters instanceof Array) {
            return parameters;
        }
        var list = [];
        for (var p in parameters) {
            list.push([p, parameters[p]]);
        }
        return list;
    }
,
    /** Convert the given parameters to a map from name to value. */
    getParameterMap: function getParameterMap(parameters) {
        if (parameters == null) {
            return {};
        }
        if (typeof parameters != &quot;object&quot;) {
            return OAuth.getParameterMap(OAuth.decodeForm(parameters + &quot;&quot;));
        }
        if (parameters instanceof Array) {
            var map = {};
            for (var p = 0; p &lt; parameters.length; ++p) {
                var key = parameters[p][0];
                if (map[key] === undefined) { // first value wins
                    map[key] = parameters[p][1];
                }
            }
            return map;
        }
        return parameters;
    }
,
    getParameter: function getParameter(parameters, name) {
        if (parameters instanceof Array) {
            for (var p = 0; p &lt; parameters.length; ++p) {
                if (parameters[p][0] == name) {
                    return parameters[p][1]; // first value wins
                }
            }
        } else {
            return OAuth.getParameterMap(parameters)[name];
        }
        return null;
    }
,
    formEncode: function formEncode(parameters) {
        var form = &quot;&quot;;
        var list = OAuth.getParameterList(parameters);
        for (var p = 0; p &lt; list.length; ++p) {
            var value = list[p][1];
            if (value == null) value = &quot;&quot;;
            if (form != &quot;&quot;) form += &apos;&amp;&apos;;
            form += OAuth.percentEncode(list[p][0])
              +&apos;=&apos;+ OAuth.percentEncode(value);
        }
        return form;
    }
,
    decodeForm: function decodeForm(form) {
        var list = [];
        var nvps = form.split(&apos;&amp;&apos;);
        for (var n = 0; n &lt; nvps.length; ++n) {
            var nvp = nvps[n];
            if (nvp == &quot;&quot;) {
                continue;
            }
            var equals = nvp.indexOf(&apos;=&apos;);
            var name;
            var value;
            if (equals &lt; 0) {
                name = OAuth.decodePercent(nvp);
                value = null;
            } else {
                name = OAuth.decodePercent(nvp.substring(0, equals));
                value = OAuth.decodePercent(nvp.substring(equals + 1));
            }
            list.push([name, value]);
        }
        return list;
    }
,
    setParameter: function setParameter(message, name, value) {
        var parameters = message.parameters;
        if (parameters instanceof Array) {
            for (var p = 0; p &lt; parameters.length; ++p) {
                if (parameters[p][0] == name) {
                    if (value === undefined) {
                        parameters.splice(p, 1);
                    } else {
                        parameters[p][1] = value;
                        value = undefined;
                    }
                }
            }
            if (value !== undefined) {
                parameters.push([name, value]);
            }
        } else {
            parameters = OAuth.getParameterMap(parameters);
            parameters[name] = value;
            message.parameters = parameters;
        }
    }
,
    setParameters: function setParameters(message, parameters) {
        var list = OAuth.getParameterList(parameters);
        for (var i = 0; i &lt; list.length; ++i) {
            OAuth.setParameter(message, list[i][0], list[i][1]);
        }
    }
,
    /** Fill in parameters to help construct a request message.
        This function doesn&apos;t fill in every parameter.
        The accessor object should be like:
        {consumerKey:&apos;foo&apos;, consumerSecret:&apos;bar&apos;, accessorSecret:&apos;nurn&apos;, token:&apos;krelm&apos;, tokenSecret:&apos;blah&apos;}
        The accessorSecret property is optional.
     */
    completeRequest: function completeRequest(message, accessor) {
        if (message.method == null) {
            message.method = &quot;GET&quot;;
        }
        var map = OAuth.getParameterMap(message.parameters);
        if (map.oauth_consumer_key == null) {
            OAuth.setParameter(message, &quot;oauth_consumer_key&quot;, accessor.consumerKey || &quot;&quot;);
        }
        if (map.oauth_token == null &amp;&amp; accessor.token != null) {
            OAuth.setParameter(message, &quot;oauth_token&quot;, accessor.token);
        }
        if (map.oauth_version == null) {
            OAuth.setParameter(message, &quot;oauth_version&quot;, &quot;1.0&quot;);
        }
        if (map.oauth_timestamp == null) {
            OAuth.setParameter(message, &quot;oauth_timestamp&quot;, OAuth.timestamp());
        }
        if (map.oauth_nonce == null) {
            OAuth.setParameter(message, &quot;oauth_nonce&quot;, OAuth.nonce(6));
        }
        OAuth.SignatureMethod.sign(message, accessor);
    }
,
    setTimestampAndNonce: function setTimestampAndNonce(message) {
        OAuth.setParameter(message, &quot;oauth_timestamp&quot;, OAuth.timestamp());
        OAuth.setParameter(message, &quot;oauth_nonce&quot;, OAuth.nonce(6));
    }
,
    addToURL: function addToURL(url, parameters) {
        newURL = url;
        if (parameters != null) {
            var toAdd = OAuth.formEncode(parameters);
            if (toAdd.length &gt; 0) {
                var q = url.indexOf(&apos;?&apos;);
                if (q &lt; 0) newURL += &apos;?&apos;;
                else       newURL += &apos;&amp;&apos;;
                newURL += toAdd;
            }
        }
        return newURL;
    }
,
    /** Construct the value of the Authorization header for an HTTP request. */
    getAuthorizationHeader: function getAuthorizationHeader(realm, parameters) {
        var header = &apos;OAuth realm=&quot;&apos; + OAuth.percentEncode(realm) + &apos;&quot;&apos;;
        var list = OAuth.getParameterList(parameters);
        for (var p = 0; p &lt; list.length; ++p) {
            var parameter = list[p];
            var name = parameter[0];
            if (name.indexOf(&quot;oauth_&quot;) == 0) {
                header += &apos;,&apos; + OAuth.percentEncode(name) + &apos;=&quot;&apos; + OAuth.percentEncode(parameter[1]) + &apos;&quot;&apos;;
            }
        }
        return header;
    }
,
    /** Correct the time using a parameter from the URL from which the last script was loaded. */
    correctTimestampFromSrc: function correctTimestampFromSrc(parameterName) {
        parameterName = parameterName || &quot;oauth_timestamp&quot;;
        var scripts = document.getElementsByTagName(&apos;script&apos;);
        if (scripts == null || !scripts.length) return;
        var src = scripts[scripts.length-1].src;
        if (!src) return;
        var q = src.indexOf(&quot;?&quot;);
        if (q &lt; 0) return;
        parameters = OAuth.getParameterMap(OAuth.decodeForm(src.substring(q+1)));
        var t = parameters[parameterName];
        if (t == null) return;
        OAuth.correctTimestamp(t);
    }
,
    /** Generate timestamps starting with the given value. */
    correctTimestamp: function correctTimestamp(timestamp) {
        OAuth.timeCorrectionMsec = (timestamp * 1000) - (new Date()).getTime();
    }
,
    /** The difference between the correct time and my clock. */
    timeCorrectionMsec: 0
,
    timestamp: function timestamp() {
        var t = (new Date()).getTime() + OAuth.timeCorrectionMsec;
        return Math.floor(t / 1000);
    }
,
    nonce: function nonce(length) {
        var chars = OAuth.nonce.CHARS;
        var result = &quot;&quot;;
        for (var i = 0; i &lt; length; ++i) {
            var rnum = Math.floor(Math.random() * chars.length);
            result += chars.substring(rnum, rnum+1);
        }
        return result;
    }
});

OAuth.nonce.CHARS = &quot;0123456789ABCDEFGHIJKLMNOPQRSTUVWXTZabcdefghiklmnopqrstuvwxyz&quot;;

/** Define a constructor function,
    without causing trouble to anyone who was using it as a namespace.
    That is, if parent[name] already existed and had properties,
    copy those properties into the new constructor.
 */
OAuth.declareClass = function declareClass(parent, name, newConstructor) {
    var previous = parent[name];
    parent[name] = newConstructor;
    if (newConstructor != null &amp;&amp; previous != null) {
        for (var key in previous) {
            if (key != &quot;prototype&quot;) {
                newConstructor[key] = previous[key];
            }
        }
    }
    return newConstructor;
}

/** An abstract algorithm for signing messages. */
OAuth.declareClass(OAuth, &quot;SignatureMethod&quot;, function OAuthSignatureMethod(){});

OAuth.setProperties(OAuth.SignatureMethod.prototype, // instance members
{
    /** Add a signature to the message. */
    sign: function sign(message) {
        var baseString = OAuth.SignatureMethod.getBaseString(message);
        var signature = this.getSignature(baseString);
        OAuth.setParameter(message, &quot;oauth_signature&quot;, signature);
        return signature; // just in case someone&apos;s interested
    }
,
    /** Set the key string for signing. */
    initialize: function initialize(name, accessor) {
        var consumerSecret;
        if (accessor.accessorSecret != null
            &amp;&amp; name.length &gt; 9
            &amp;&amp; name.substring(name.length-9) == &quot;-Accessor&quot;)
        {
            consumerSecret = accessor.accessorSecret;
        } else {
            consumerSecret = accessor.consumerSecret;
        }
        this.key = OAuth.percentEncode(consumerSecret)
             +&quot;&amp;&quot;+ OAuth.percentEncode(accessor.tokenSecret);
    }
});

/* SignatureMethod expects an accessor object to be like this:
   {tokenSecret: &quot;lakjsdflkj...&quot;, consumerSecret: &quot;QOUEWRI..&quot;, accessorSecret: &quot;xcmvzc...&quot;}
   The accessorSecret property is optional.
 */
// Class members:
OAuth.setProperties(OAuth.SignatureMethod, // class members
{
    sign: function sign(message, accessor) {
        var name = OAuth.getParameterMap(message.parameters).oauth_signature_method;
        if (name == null || name == &quot;&quot;) {
            name = &quot;HMAC-SHA1&quot;;
            OAuth.setParameter(message, &quot;oauth_signature_method&quot;, name);
        }
        OAuth.SignatureMethod.newMethod(name, accessor).sign(message);
    }
,
    /** Instantiate a SignatureMethod for the given method name. */
    newMethod: function newMethod(name, accessor) {
        var impl = OAuth.SignatureMethod.REGISTERED[name];
        if (impl != null) {
            var method = new impl();
            method.initialize(name, accessor);
            return method;
        }
        var err = new Error(&quot;signature_method_rejected&quot;);
        var acceptable = &quot;&quot;;
        for (var r in OAuth.SignatureMethod.REGISTERED) {
            if (acceptable != &quot;&quot;) acceptable += &apos;&amp;&apos;;
            acceptable += OAuth.percentEncode(r);
        }
        err.oauth_acceptable_signature_methods = acceptable;
        throw err;
    }
,
    /** A map from signature method name to constructor. */
    REGISTERED : {}
,
    /** Subsequently, the given constructor will be used for the named methods.
        The constructor will be called with no parameters.
        The resulting object should usually implement getSignature(baseString).
        You can easily define such a constructor by calling makeSubclass, below.
     */
    registerMethodClass: function registerMethodClass(names, classConstructor) {
        for (var n = 0; n &lt; names.length; ++n) {
            OAuth.SignatureMethod.REGISTERED[names[n]] = classConstructor;
        }
    }
,
    /** Create a subclass of OAuth.SignatureMethod, with the given getSignature function. */
    makeSubclass: function makeSubclass(getSignatureFunction) {
        var superClass = OAuth.SignatureMethod;
        var subClass = function() {
            superClass.call(this);
        };
        subClass.prototype = new superClass();
        // Delete instance variables from prototype:
        // delete subclass.prototype... There aren&apos;t any.
        subClass.prototype.getSignature = getSignatureFunction;
        subClass.prototype.constructor = subClass;
        return subClass;
    }
,
    getBaseString: function getBaseString(message) {
        var URL = message.action;
        var q = URL.indexOf(&apos;?&apos;);
        var parameters;
        if (q &lt; 0) {
            parameters = message.parameters;
        } else {
            // Combine the URL query string with the other parameters:
            parameters = OAuth.decodeForm(URL.substring(q + 1));
            var toAdd = OAuth.getParameterList(message.parameters);
            for (var a = 0; a &lt; toAdd.length; ++a) {
                parameters.push(toAdd[a]);
            }
        }
        return OAuth.percentEncode(message.method.toUpperCase())
         +&apos;&amp;&apos;+ OAuth.percentEncode(OAuth.SignatureMethod.normalizeUrl(URL))
         +&apos;&amp;&apos;+ OAuth.percentEncode(OAuth.SignatureMethod.normalizeParameters(parameters));
    }
,
    normalizeUrl: function normalizeUrl(url) {
        var uri = OAuth.SignatureMethod.parseUri(url);
        var scheme = uri.protocol.toLowerCase();
        var authority = uri.authority.toLowerCase();
        var dropPort = (scheme == &quot;http&quot; &amp;&amp; uri.port == 80)
                    || (scheme == &quot;https&quot; &amp;&amp; uri.port == 443);
        if (dropPort) {
            // find the last : in the authority
            var index = authority.lastIndexOf(&quot;:&quot;);
            if (index &gt;= 0) {
                authority = authority.substring(0, index);
            }
        }
        var path = uri.path;
        if (!path) {
            path = &quot;/&quot;; // conforms to RFC 2616 section 3.2.2
        }
        // we know that there is no query and no fragment here.
        return scheme + &quot;://&quot; + authority + path;
    }
,
    parseUri: function parseUri (str) {
        /* This function was adapted from parseUri 1.2.1
           http://stevenlevithan.com/demo/parseuri/js/assets/parseuri.js
         */
        var o = {key: [&quot;source&quot;,&quot;protocol&quot;,&quot;authority&quot;,&quot;userInfo&quot;,&quot;user&quot;,&quot;password&quot;,&quot;host&quot;,&quot;port&quot;,&quot;relative&quot;,&quot;path&quot;,&quot;directory&quot;,&quot;file&quot;,&quot;query&quot;,&quot;anchor&quot;],
                 parser: {strict: /^(?:([^:\/?#]+):)?(?:\/\/((?:(([^:@\/]*):?([^:@\/]*))?@)?([^:\/?#]*)(?::(\d*))?))?((((?:[^?#\/]*\/)*)([^?#]*))(?:\?([^#]*))?(?:#(.*))?)/ }};
        var m = o.parser.strict.exec(str);
        var uri = {};
        var i = 14;
        while (i--) uri[o.key[i]] = m[i] || &quot;&quot;;
        return uri;
    }
,
    normalizeParameters: function normalizeParameters(parameters) {
        if (parameters == null) {
            return &quot;&quot;;
        }
        var list = OAuth.getParameterList(parameters);
        var sortable = [];
        for (var p = 0; p &lt; list.length; ++p) {
            var nvp = list[p];
            if (nvp[0] != &quot;oauth_signature&quot;) {
                sortable.push([ OAuth.percentEncode(nvp[0])
                              + &quot; &quot; // because it comes before any character that can appear in a percentEncoded string.
                              + OAuth.percentEncode(nvp[1])
                              , nvp]);
            }
        }
        sortable.sort(function(a,b) {
                          if (a[0] &lt; b[0]) return  -1;
                          if (a[0] &gt; b[0]) return 1;
                          return 0;
                      });
        var sorted = [];
        for (var s = 0; s &lt; sortable.length; ++s) {
            sorted.push(sortable[s][1]);
        }
        return OAuth.formEncode(sorted);
    }
});

OAuth.SignatureMethod.registerMethodClass([&quot;PLAINTEXT&quot;, &quot;PLAINTEXT-Accessor&quot;],
    OAuth.SignatureMethod.makeSubclass(
        function getSignature(baseString) {
            return this.key;
        }
    ));

OAuth.SignatureMethod.registerMethodClass([&quot;HMAC-SHA1&quot;, &quot;HMAC-SHA1-Accessor&quot;],
    OAuth.SignatureMethod.makeSubclass(
        function getSignature(baseString) {
            b64pad = &apos;=&apos;;
            var signature = b64_hmac_sha1(this.key, baseString);
            return signature;
        }
    ));

try {
    OAuth.correctTimestampFromSrc();
} catch(e) {
}


//--------------------------------------------------

var consumerKey = &quot;${consumer_key}&quot;;
var consumerSecret = &quot;${consumer_secret}&quot;;
var params = [];
var query = [];
query.push(&apos;access_token&apos; + &apos;=&apos; + &apos;kataiteeeeeeeeeeeeeeeeeee&apos;);
query.push(&apos;id_token&apos; + &apos;=&apos; + &apos;${id_token}&apos;);
var url =  &quot;${protocol}://${misp_url}/marvelous/people/@me/@self&quot;;

if (query.length) {
    url += &apos;?&apos; + query.join(&apos;&amp;&apos;);
}

var message = {
    method: &apos;put&apos;,
    parameters: params, 
    action: url
};

log.info(url);
log.info(consumerSecret);

var accessor = {
    consumerKey: consumerKey,
    consumerSecret: consumerSecret,
    token:  &apos;kataiteeeeeeeeeeeeeeeeeee&apos;,
    tokenSecret: &apos;${id_token}&apos;
};

OAuth.completeRequest(message, accessor);
vars.put(&apos;put_auth_header&apos;, OAuth.getAuthorizationHeader(&apos;&apos;, params).replace(&apos;OAuth realm=&quot;&quot;,&apos;, &apos; OAuth &apos;));
</stringProp>
            <stringProp name="scriptLanguage">javascript</stringProp>
          </BSFPreProcessor>
          <hashTree/>
          <HeaderManager guiclass="HeaderPanel" testclass="HeaderManager" testname="HTTP ヘッダマネージャ" enabled="true">
            <collectionProp name="HeaderManager.headers">
              <elementProp name="" elementType="Header">
                <stringProp name="Header.name">Authorization</stringProp>
                <stringProp name="Header.value">${put_auth_header}</stringProp>
              </elementProp>
              <elementProp name="" elementType="Header">
                <stringProp name="Header.name">content-type</stringProp>
                <stringProp name="Header.value">application/json; charset=utf8</stringProp>
              </elementProp>
              <elementProp name="" elementType="Header">
                <stringProp name="Header.name">Connection</stringProp>
                <stringProp name="Header.value">close</stringProp>
              </elementProp>
              <elementProp name="" elementType="Header">
                <stringProp name="Header.name">Accept-encoding</stringProp>
                <stringProp name="Header.value">gzip, deflate</stringProp>
              </elementProp>
            </collectionProp>
          </HeaderManager>
          <hashTree/>
          <BSFAssertion guiclass="TestBeanGUI" testclass="BSFAssertion" testname="レスポンスコード401" enabled="true">
            <stringProp name="filename"></stringProp>
            <stringProp name="parameters"></stringProp>
            <stringProp name="script">if (prev.getResponseCode() == &quot;401&quot;) {
	AssertionResult.setFailure(false);
	prev.setSuccessful(true);
} else {
	AssertionResult.setFailure(true);
}</stringProp>
            <stringProp name="scriptLanguage">javascript</stringProp>
          </BSFAssertion>
          <hashTree/>
        </hashTree>
        <HTTPSamplerProxy guiclass="HttpTestSampleGui" testclass="HTTPSamplerProxy" testname="Implicit.ユーザ取得エラー(トークンエラー)" enabled="true">
          <elementProp name="HTTPsampler.Arguments" elementType="Arguments" guiclass="HTTPArgumentsPanel" testclass="Arguments" enabled="true">
            <collectionProp name="Arguments.arguments">
              <elementProp name="access_token" elementType="HTTPArgument">
                <boolProp name="HTTPArgument.always_encode">false</boolProp>
                <stringProp name="Argument.value">aaaaaa</stringProp>
                <stringProp name="Argument.metadata">=</stringProp>
                <boolProp name="HTTPArgument.use_equals">true</boolProp>
                <stringProp name="Argument.name">access_token</stringProp>
              </elementProp>
              <elementProp name="id_token" elementType="HTTPArgument">
                <boolProp name="HTTPArgument.always_encode">false</boolProp>
                <stringProp name="Argument.value">${id_token}</stringProp>
                <stringProp name="Argument.metadata">=</stringProp>
                <boolProp name="HTTPArgument.use_equals">true</boolProp>
                <stringProp name="Argument.name">id_token</stringProp>
              </elementProp>
            </collectionProp>
          </elementProp>
          <stringProp name="HTTPSampler.domain"></stringProp>
          <stringProp name="HTTPSampler.port"></stringProp>
          <stringProp name="HTTPSampler.connect_timeout"></stringProp>
          <stringProp name="HTTPSampler.response_timeout"></stringProp>
          <stringProp name="HTTPSampler.protocol"></stringProp>
          <stringProp name="HTTPSampler.contentEncoding"></stringProp>
          <stringProp name="HTTPSampler.path">/marvelous/people/@me/@self</stringProp>
          <stringProp name="HTTPSampler.method">GET</stringProp>
          <boolProp name="HTTPSampler.follow_redirects">true</boolProp>
          <boolProp name="HTTPSampler.auto_redirects">false</boolProp>
          <boolProp name="HTTPSampler.use_keepalive">true</boolProp>
          <boolProp name="HTTPSampler.DO_MULTIPART_POST">false</boolProp>
          <boolProp name="HTTPSampler.monitor">false</boolProp>
          <stringProp name="HTTPSampler.embedded_url_re"></stringProp>
        </HTTPSamplerProxy>
        <hashTree>
          <BSFPreProcessor guiclass="TestBeanGUI" testclass="BSFPreProcessor" testname="BSF PreProcessor" enabled="true">
            <stringProp name="filename"></stringProp>
            <stringProp name="parameters"></stringProp>
            <stringProp name="script">/*
 * A JavaScript implementation of the Secure Hash Algorithm, SHA-1, as defined
 * in FIPS PUB 180-1
 * Version 2.1a Copyright Paul Johnston 2000 - 2002.
 * Other contributors: Greg Holt, Andrew Kepert, Ydnar, Lostinet
 * Distributed under the BSD License
 * See http://pajhome.org.uk/crypt/md5 for details.
 */

/*
 * Configurable variables. You may need to tweak these to be compatible with
 * the server-side, but the defaults work in most cases.
 */
var hexcase = 0;  /* hex output format. 0 - lowercase; 1 - uppercase        */
var b64pad  = &quot;&quot;; /* base-64 pad character. &quot;=&quot; for strict RFC compliance   */
var chrsz   = 8;  /* bits per input character. 8 - ASCII; 16 - Unicode      */

/*
 * These are the functions you&apos;ll usually want to call
 * They take string arguments and return either hex or base-64 encoded strings
 */
function hex_sha1(s){return binb2hex(core_sha1(str2binb(s),s.length * chrsz));}
function b64_sha1(s){return binb2b64(core_sha1(str2binb(s),s.length * chrsz));}
function str_sha1(s){return binb2str(core_sha1(str2binb(s),s.length * chrsz));}
function hex_hmac_sha1(key, data){ return binb2hex(core_hmac_sha1(key, data));}
function b64_hmac_sha1(key, data){ return binb2b64(core_hmac_sha1(key, data));}
function str_hmac_sha1(key, data){ return binb2str(core_hmac_sha1(key, data));}

/*
 * Perform a simple self-test to see if the VM is working
 */
function sha1_vm_test()
{
  return hex_sha1(&quot;abc&quot;) == &quot;a9993e364706816aba3e25717850c26c9cd0d89d&quot;;
}

/*
 * Calculate the SHA-1 of an array of big-endian words, and a bit length
 */
function core_sha1(x, len)
{
  /* append padding */
  x[len &gt;&gt; 5] |= 0x80 &lt;&lt; (24 - len % 32);
  x[((len + 64 &gt;&gt; 9) &lt;&lt; 4) + 15] = len;

  var w = Array(80);
  var a =  1732584193;
  var b = -271733879;
  var c = -1732584194;
  var d =  271733878;
  var e = -1009589776;

  for(var i = 0; i &lt; x.length; i += 16)
  {
    var olda = a;
    var oldb = b;
    var oldc = c;
    var oldd = d;
    var olde = e;

    for(var j = 0; j &lt; 80; j++)
    {
      if(j &lt; 16) w[j] = x[i + j];
      else w[j] = rol(w[j-3] ^ w[j-8] ^ w[j-14] ^ w[j-16], 1);
      var t = safe_add(safe_add(rol(a, 5), sha1_ft(j, b, c, d)),
                       safe_add(safe_add(e, w[j]), sha1_kt(j)));
      e = d;
      d = c;
      c = rol(b, 30);
      b = a;
      a = t;
    }

    a = safe_add(a, olda);
    b = safe_add(b, oldb);
    c = safe_add(c, oldc);
    d = safe_add(d, oldd);
    e = safe_add(e, olde);
  }
  return Array(a, b, c, d, e);

}

/*
 * Perform the appropriate triplet combination function for the current
 * iteration
 */
function sha1_ft(t, b, c, d)
{
  if(t &lt; 20) return (b &amp; c) | ((~b) &amp; d);
  if(t &lt; 40) return b ^ c ^ d;
  if(t &lt; 60) return (b &amp; c) | (b &amp; d) | (c &amp; d);
  return b ^ c ^ d;
}

/*
 * Determine the appropriate additive constant for the current iteration
 */
function sha1_kt(t)
{
  return (t &lt; 20) ?  1518500249 : (t &lt; 40) ?  1859775393 :
         (t &lt; 60) ? -1894007588 : -899497514;
}

/*
 * Calculate the HMAC-SHA1 of a key and some data
 */
function core_hmac_sha1(key, data)
{
  var bkey = str2binb(key);
  if(bkey.length &gt; 16) bkey = core_sha1(bkey, key.length * chrsz);

  var ipad = Array(16), opad = Array(16);
  for(var i = 0; i &lt; 16; i++)
  {
    ipad[i] = bkey[i] ^ 0x36363636;
    opad[i] = bkey[i] ^ 0x5C5C5C5C;
  }

  var hash = core_sha1(ipad.concat(str2binb(data)), 512 + data.length * chrsz);
  return core_sha1(opad.concat(hash), 512 + 160);
}

/*
 * Add integers, wrapping at 2^32. This uses 16-bit operations internally
 * to work around bugs in some JS interpreters.
 */
function safe_add(x, y)
{
  var lsw = (x &amp; 0xFFFF) + (y &amp; 0xFFFF);
  var msw = (x &gt;&gt; 16) + (y &gt;&gt; 16) + (lsw &gt;&gt; 16);
  return (msw &lt;&lt; 16) | (lsw &amp; 0xFFFF);
}

/*
 * Bitwise rotate a 32-bit number to the left.
 */
function rol(num, cnt)
{
  return (num &lt;&lt; cnt) | (num &gt;&gt;&gt; (32 - cnt));
}

/*
 * Convert an 8-bit or 16-bit string to an array of big-endian words
 * In 8-bit function, characters &gt;255 have their hi-byte silently ignored.
 */
function str2binb(str)
{
  var bin = Array();
  var mask = (1 &lt;&lt; chrsz) - 1;
  for(var i = 0; i &lt; str.length * chrsz; i += chrsz)
    bin[i&gt;&gt;5] |= (str.charCodeAt(i / chrsz) &amp; mask) &lt;&lt; (32 - chrsz - i%32);
  return bin;
}

/*
 * Convert an array of big-endian words to a string
 */
function binb2str(bin)
{
  var str = &quot;&quot;;
  var mask = (1 &lt;&lt; chrsz) - 1;
  for(var i = 0; i &lt; bin.length * 32; i += chrsz)
    str += String.fromCharCode((bin[i&gt;&gt;5] &gt;&gt;&gt; (32 - chrsz - i%32)) &amp; mask);
  return str;
}

/*
 * Convert an array of big-endian words to a hex string.
 */
function binb2hex(binarray)
{
  var hex_tab = hexcase ? &quot;0123456789ABCDEF&quot; : &quot;0123456789abcdef&quot;;
  var str = &quot;&quot;;
  for(var i = 0; i &lt; binarray.length * 4; i++)
  {
    str += hex_tab.charAt((binarray[i&gt;&gt;2] &gt;&gt; ((3 - i%4)*8+4)) &amp; 0xF) +
           hex_tab.charAt((binarray[i&gt;&gt;2] &gt;&gt; ((3 - i%4)*8  )) &amp; 0xF);
  }
  return str;
}

/*
 * Convert an array of big-endian words to a base-64 string
 */
function binb2b64(binarray)
{
  var tab = &quot;ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/&quot;;
  var str = &quot;&quot;;
  for(var i = 0; i &lt; binarray.length * 4; i += 3)
  {
    var triplet = (((binarray[i   &gt;&gt; 2] &gt;&gt; 8 * (3 -  i   %4)) &amp; 0xFF) &lt;&lt; 16)
                | (((binarray[i+1 &gt;&gt; 2] &gt;&gt; 8 * (3 - (i+1)%4)) &amp; 0xFF) &lt;&lt; 8 )
                |  ((binarray[i+2 &gt;&gt; 2] &gt;&gt; 8 * (3 - (i+2)%4)) &amp; 0xFF);
    for(var j = 0; j &lt; 4; j++)
    {
      if(i * 8 + j * 6 &gt; binarray.length * 32) str += b64pad;
      else str += tab.charAt((triplet &gt;&gt; 6*(3-j)) &amp; 0x3F);
    }
  }
  return str;
}

/*
 * Copyright 2008 Netflix, Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/* Here&apos;s some JavaScript software for implementing OAuth.

   This isn&apos;t as useful as you might hope.  OAuth is based around
   allowing tools and websites to talk to each other.  However,
   JavaScript running in web browsers is hampered by security
   restrictions that prevent code running on one website from
   accessing data stored or served on another.

   Before you start hacking, make sure you understand the limitations
   posed by cross-domain XMLHttpRequest.

   On the bright side, some platforms use JavaScript as their
   language, but enable the programmer to access other web sites.
   Examples include Google Gadgets, and Microsoft Vista Sidebar.
   For those platforms, this library should come in handy.
*/

// The HMAC-SHA1 signature method calls b64_hmac_sha1, defined by
// http://pajhome.org.uk/crypt/md5/sha1.js

/* An OAuth message is represented as an object like this:
   {method: &quot;GET&quot;, action: &quot;http://server.com/path&quot;, parameters: ...}

   The parameters may be either a map {name: value, name2: value2}
   or an Array of name-value pairs [[name, value], [name2, value2]].
   The latter representation is more powerful: it supports parameters
   in a specific sequence, or several parameters with the same name;
   for example [[&quot;a&quot;, 1], [&quot;b&quot;, 2], [&quot;a&quot;, 3]].

   Parameter names and values are NOT percent-encoded in an object.
   They must be encoded before transmission and decoded after reception.
   For example, this message object:
   {method: &quot;GET&quot;, action: &quot;http://server/path&quot;, parameters: {p: &quot;x y&quot;}}
   ... can be transmitted as an HTTP request that begins:
   GET /path?p=x%20y HTTP/1.0
   (This isn&apos;t a valid OAuth request, since it lacks a signature etc.)
   Note that the object &quot;x y&quot; is transmitted as x%20y.  To encode
   parameters, you can call OAuth.addToURL, OAuth.formEncode or
   OAuth.getAuthorization.

   This message object model harmonizes with the browser object model for
   input elements of an form, whose value property isn&apos;t percent encoded.
   The browser encodes each value before transmitting it. For example,
   see consumer.setInputs in example/consumer.js.
 */

/* This script needs to know what time it is. By default, it uses the local
   clock (new Date), which is apt to be inaccurate in browsers. To do
   better, you can load this script from a URL whose query string contains
   an oauth_timestamp parameter, whose value is a current Unix timestamp.
   For example, when generating the enclosing document using PHP:

   &lt;script src=&quot;oauth.js?oauth_timestamp=&lt;?=time()?&gt;&quot; ...

   Another option is to call OAuth.correctTimestamp with a Unix timestamp.
 */

var OAuth; if (OAuth == null) OAuth = {};

OAuth.setProperties = function setProperties(into, from) {
    if (into != null &amp;&amp; from != null) {
        for (var key in from) {
            into[key] = from[key];
        }
    }
    return into;
}

OAuth.setProperties(OAuth, // utility functions
{
    percentEncode: function percentEncode(s) {
        if (s == null) {
            return &quot;&quot;;
        }
        if (s instanceof Array) {
            var e = &quot;&quot;;
            for (var i = 0; i &lt; s.length; ++s) {
                if (e != &quot;&quot;) e += &apos;&amp;&apos;;
                e += OAuth.percentEncode(s[i]);
            }
            return e;
        }
        s = encodeURIComponent(s);
        // Now replace the values which encodeURIComponent doesn&apos;t do
        // encodeURIComponent ignores: - _ . ! ~ * &apos; ( )
        // OAuth dictates the only ones you can ignore are: - _ . ~
        // Source: http://developer.mozilla.org/en/docs/Core_JavaScript_1.5_Reference:Global_Functions:encodeURIComponent
        s = s.replace(/\!/g, &quot;%21&quot;);
        s = s.replace(/\*/g, &quot;%2A&quot;);
        s = s.replace(/\&apos;/g, &quot;%27&quot;);
        s = s.replace(/\(/g, &quot;%28&quot;);
        s = s.replace(/\)/g, &quot;%29&quot;);
        return s;
    }
,
    decodePercent: function decodePercent(s) {
        if (s != null) {
            // Handle application/x-www-form-urlencoded, which is defined by
            // http://www.w3.org/TR/html4/interact/forms.html#h-17.13.4.1
            s = s.replace(/\+/g, &quot; &quot;);
        }
        return decodeURIComponent(s);
    }
,
    /** Convert the given parameters to an Array of name-value pairs. */
    getParameterList: function getParameterList(parameters) {
        if (parameters == null) {
            return [];
        }
        if (typeof parameters != &quot;object&quot;) {
            return OAuth.decodeForm(parameters + &quot;&quot;);
        }
        if (parameters instanceof Array) {
            return parameters;
        }
        var list = [];
        for (var p in parameters) {
            list.push([p, parameters[p]]);
        }
        return list;
    }
,
    /** Convert the given parameters to a map from name to value. */
    getParameterMap: function getParameterMap(parameters) {
        if (parameters == null) {
            return {};
        }
        if (typeof parameters != &quot;object&quot;) {
            return OAuth.getParameterMap(OAuth.decodeForm(parameters + &quot;&quot;));
        }
        if (parameters instanceof Array) {
            var map = {};
            for (var p = 0; p &lt; parameters.length; ++p) {
                var key = parameters[p][0];
                if (map[key] === undefined) { // first value wins
                    map[key] = parameters[p][1];
                }
            }
            return map;
        }
        return parameters;
    }
,
    getParameter: function getParameter(parameters, name) {
        if (parameters instanceof Array) {
            for (var p = 0; p &lt; parameters.length; ++p) {
                if (parameters[p][0] == name) {
                    return parameters[p][1]; // first value wins
                }
            }
        } else {
            return OAuth.getParameterMap(parameters)[name];
        }
        return null;
    }
,
    formEncode: function formEncode(parameters) {
        var form = &quot;&quot;;
        var list = OAuth.getParameterList(parameters);
        for (var p = 0; p &lt; list.length; ++p) {
            var value = list[p][1];
            if (value == null) value = &quot;&quot;;
            if (form != &quot;&quot;) form += &apos;&amp;&apos;;
            form += OAuth.percentEncode(list[p][0])
              +&apos;=&apos;+ OAuth.percentEncode(value);
        }
        return form;
    }
,
    decodeForm: function decodeForm(form) {
        var list = [];
        var nvps = form.split(&apos;&amp;&apos;);
        for (var n = 0; n &lt; nvps.length; ++n) {
            var nvp = nvps[n];
            if (nvp == &quot;&quot;) {
                continue;
            }
            var equals = nvp.indexOf(&apos;=&apos;);
            var name;
            var value;
            if (equals &lt; 0) {
                name = OAuth.decodePercent(nvp);
                value = null;
            } else {
                name = OAuth.decodePercent(nvp.substring(0, equals));
                value = OAuth.decodePercent(nvp.substring(equals + 1));
            }
            list.push([name, value]);
        }
        return list;
    }
,
    setParameter: function setParameter(message, name, value) {
        var parameters = message.parameters;
        if (parameters instanceof Array) {
            for (var p = 0; p &lt; parameters.length; ++p) {
                if (parameters[p][0] == name) {
                    if (value === undefined) {
                        parameters.splice(p, 1);
                    } else {
                        parameters[p][1] = value;
                        value = undefined;
                    }
                }
            }
            if (value !== undefined) {
                parameters.push([name, value]);
            }
        } else {
            parameters = OAuth.getParameterMap(parameters);
            parameters[name] = value;
            message.parameters = parameters;
        }
    }
,
    setParameters: function setParameters(message, parameters) {
        var list = OAuth.getParameterList(parameters);
        for (var i = 0; i &lt; list.length; ++i) {
            OAuth.setParameter(message, list[i][0], list[i][1]);
        }
    }
,
    /** Fill in parameters to help construct a request message.
        This function doesn&apos;t fill in every parameter.
        The accessor object should be like:
        {consumerKey:&apos;foo&apos;, consumerSecret:&apos;bar&apos;, accessorSecret:&apos;nurn&apos;, token:&apos;krelm&apos;, tokenSecret:&apos;blah&apos;}
        The accessorSecret property is optional.
     */
    completeRequest: function completeRequest(message, accessor) {
        if (message.method == null) {
            message.method = &quot;GET&quot;;
        }
        var map = OAuth.getParameterMap(message.parameters);
        if (map.oauth_consumer_key == null) {
            OAuth.setParameter(message, &quot;oauth_consumer_key&quot;, accessor.consumerKey || &quot;&quot;);
        }
        if (map.oauth_token == null &amp;&amp; accessor.token != null) {
            OAuth.setParameter(message, &quot;oauth_token&quot;, accessor.token);
        }
        if (map.oauth_version == null) {
            OAuth.setParameter(message, &quot;oauth_version&quot;, &quot;1.0&quot;);
        }
        if (map.oauth_timestamp == null) {
            OAuth.setParameter(message, &quot;oauth_timestamp&quot;, OAuth.timestamp());
        }
        if (map.oauth_nonce == null) {
            OAuth.setParameter(message, &quot;oauth_nonce&quot;, OAuth.nonce(6));
        }
        OAuth.SignatureMethod.sign(message, accessor);
    }
,
    setTimestampAndNonce: function setTimestampAndNonce(message) {
        OAuth.setParameter(message, &quot;oauth_timestamp&quot;, OAuth.timestamp());
        OAuth.setParameter(message, &quot;oauth_nonce&quot;, OAuth.nonce(6));
    }
,
    addToURL: function addToURL(url, parameters) {
        newURL = url;
        if (parameters != null) {
            var toAdd = OAuth.formEncode(parameters);
            if (toAdd.length &gt; 0) {
                var q = url.indexOf(&apos;?&apos;);
                if (q &lt; 0) newURL += &apos;?&apos;;
                else       newURL += &apos;&amp;&apos;;
                newURL += toAdd;
            }
        }
        return newURL;
    }
,
    /** Construct the value of the Authorization header for an HTTP request. */
    getAuthorizationHeader: function getAuthorizationHeader(realm, parameters) {
        var header = &apos;OAuth realm=&quot;&apos; + OAuth.percentEncode(realm) + &apos;&quot;&apos;;
        var list = OAuth.getParameterList(parameters);
        for (var p = 0; p &lt; list.length; ++p) {
            var parameter = list[p];
            var name = parameter[0];
            if (name.indexOf(&quot;oauth_&quot;) == 0) {
                header += &apos;,&apos; + OAuth.percentEncode(name) + &apos;=&quot;&apos; + OAuth.percentEncode(parameter[1]) + &apos;&quot;&apos;;
            }
        }
        return header;
    }
,
    /** Correct the time using a parameter from the URL from which the last script was loaded. */
    correctTimestampFromSrc: function correctTimestampFromSrc(parameterName) {
        parameterName = parameterName || &quot;oauth_timestamp&quot;;
        var scripts = document.getElementsByTagName(&apos;script&apos;);
        if (scripts == null || !scripts.length) return;
        var src = scripts[scripts.length-1].src;
        if (!src) return;
        var q = src.indexOf(&quot;?&quot;);
        if (q &lt; 0) return;
        parameters = OAuth.getParameterMap(OAuth.decodeForm(src.substring(q+1)));
        var t = parameters[parameterName];
        if (t == null) return;
        OAuth.correctTimestamp(t);
    }
,
    /** Generate timestamps starting with the given value. */
    correctTimestamp: function correctTimestamp(timestamp) {
        OAuth.timeCorrectionMsec = (timestamp * 1000) - (new Date()).getTime();
    }
,
    /** The difference between the correct time and my clock. */
    timeCorrectionMsec: 0
,
    timestamp: function timestamp() {
        var t = (new Date()).getTime() + OAuth.timeCorrectionMsec;
        return Math.floor(t / 1000);
    }
,
    nonce: function nonce(length) {
        var chars = OAuth.nonce.CHARS;
        var result = &quot;&quot;;
        for (var i = 0; i &lt; length; ++i) {
            var rnum = Math.floor(Math.random() * chars.length);
            result += chars.substring(rnum, rnum+1);
        }
        return result;
    }
});

OAuth.nonce.CHARS = &quot;0123456789ABCDEFGHIJKLMNOPQRSTUVWXTZabcdefghiklmnopqrstuvwxyz&quot;;

/** Define a constructor function,
    without causing trouble to anyone who was using it as a namespace.
    That is, if parent[name] already existed and had properties,
    copy those properties into the new constructor.
 */
OAuth.declareClass = function declareClass(parent, name, newConstructor) {
    var previous = parent[name];
    parent[name] = newConstructor;
    if (newConstructor != null &amp;&amp; previous != null) {
        for (var key in previous) {
            if (key != &quot;prototype&quot;) {
                newConstructor[key] = previous[key];
            }
        }
    }
    return newConstructor;
}

/** An abstract algorithm for signing messages. */
OAuth.declareClass(OAuth, &quot;SignatureMethod&quot;, function OAuthSignatureMethod(){});

OAuth.setProperties(OAuth.SignatureMethod.prototype, // instance members
{
    /** Add a signature to the message. */
    sign: function sign(message) {
        var baseString = OAuth.SignatureMethod.getBaseString(message);
        var signature = this.getSignature(baseString);
        OAuth.setParameter(message, &quot;oauth_signature&quot;, signature);
        return signature; // just in case someone&apos;s interested
    }
,
    /** Set the key string for signing. */
    initialize: function initialize(name, accessor) {
        var consumerSecret;
        if (accessor.accessorSecret != null
            &amp;&amp; name.length &gt; 9
            &amp;&amp; name.substring(name.length-9) == &quot;-Accessor&quot;)
        {
            consumerSecret = accessor.accessorSecret;
        } else {
            consumerSecret = accessor.consumerSecret;
        }
        this.key = OAuth.percentEncode(consumerSecret)
             +&quot;&amp;&quot;+ OAuth.percentEncode(accessor.tokenSecret);
    }
});

/* SignatureMethod expects an accessor object to be like this:
   {tokenSecret: &quot;lakjsdflkj...&quot;, consumerSecret: &quot;QOUEWRI..&quot;, accessorSecret: &quot;xcmvzc...&quot;}
   The accessorSecret property is optional.
 */
// Class members:
OAuth.setProperties(OAuth.SignatureMethod, // class members
{
    sign: function sign(message, accessor) {
        var name = OAuth.getParameterMap(message.parameters).oauth_signature_method;
        if (name == null || name == &quot;&quot;) {
            name = &quot;HMAC-SHA1&quot;;
            OAuth.setParameter(message, &quot;oauth_signature_method&quot;, name);
        }
        OAuth.SignatureMethod.newMethod(name, accessor).sign(message);
    }
,
    /** Instantiate a SignatureMethod for the given method name. */
    newMethod: function newMethod(name, accessor) {
        var impl = OAuth.SignatureMethod.REGISTERED[name];
        if (impl != null) {
            var method = new impl();
            method.initialize(name, accessor);
            return method;
        }
        var err = new Error(&quot;signature_method_rejected&quot;);
        var acceptable = &quot;&quot;;
        for (var r in OAuth.SignatureMethod.REGISTERED) {
            if (acceptable != &quot;&quot;) acceptable += &apos;&amp;&apos;;
            acceptable += OAuth.percentEncode(r);
        }
        err.oauth_acceptable_signature_methods = acceptable;
        throw err;
    }
,
    /** A map from signature method name to constructor. */
    REGISTERED : {}
,
    /** Subsequently, the given constructor will be used for the named methods.
        The constructor will be called with no parameters.
        The resulting object should usually implement getSignature(baseString).
        You can easily define such a constructor by calling makeSubclass, below.
     */
    registerMethodClass: function registerMethodClass(names, classConstructor) {
        for (var n = 0; n &lt; names.length; ++n) {
            OAuth.SignatureMethod.REGISTERED[names[n]] = classConstructor;
        }
    }
,
    /** Create a subclass of OAuth.SignatureMethod, with the given getSignature function. */
    makeSubclass: function makeSubclass(getSignatureFunction) {
        var superClass = OAuth.SignatureMethod;
        var subClass = function() {
            superClass.call(this);
        };
        subClass.prototype = new superClass();
        // Delete instance variables from prototype:
        // delete subclass.prototype... There aren&apos;t any.
        subClass.prototype.getSignature = getSignatureFunction;
        subClass.prototype.constructor = subClass;
        return subClass;
    }
,
    getBaseString: function getBaseString(message) {
        var URL = message.action;
        var q = URL.indexOf(&apos;?&apos;);
        var parameters;
        if (q &lt; 0) {
            parameters = message.parameters;
        } else {
            // Combine the URL query string with the other parameters:
            parameters = OAuth.decodeForm(URL.substring(q + 1));
            var toAdd = OAuth.getParameterList(message.parameters);
            for (var a = 0; a &lt; toAdd.length; ++a) {
                parameters.push(toAdd[a]);
            }
        }
        return OAuth.percentEncode(message.method.toUpperCase())
         +&apos;&amp;&apos;+ OAuth.percentEncode(OAuth.SignatureMethod.normalizeUrl(URL))
         +&apos;&amp;&apos;+ OAuth.percentEncode(OAuth.SignatureMethod.normalizeParameters(parameters));
    }
,
    normalizeUrl: function normalizeUrl(url) {
        var uri = OAuth.SignatureMethod.parseUri(url);
        var scheme = uri.protocol.toLowerCase();
        var authority = uri.authority.toLowerCase();
        var dropPort = (scheme == &quot;http&quot; &amp;&amp; uri.port == 80)
                    || (scheme == &quot;https&quot; &amp;&amp; uri.port == 443);
        if (dropPort) {
            // find the last : in the authority
            var index = authority.lastIndexOf(&quot;:&quot;);
            if (index &gt;= 0) {
                authority = authority.substring(0, index);
            }
        }
        var path = uri.path;
        if (!path) {
            path = &quot;/&quot;; // conforms to RFC 2616 section 3.2.2
        }
        // we know that there is no query and no fragment here.
        return scheme + &quot;://&quot; + authority + path;
    }
,
    parseUri: function parseUri (str) {
        /* This function was adapted from parseUri 1.2.1
           http://stevenlevithan.com/demo/parseuri/js/assets/parseuri.js
         */
        var o = {key: [&quot;source&quot;,&quot;protocol&quot;,&quot;authority&quot;,&quot;userInfo&quot;,&quot;user&quot;,&quot;password&quot;,&quot;host&quot;,&quot;port&quot;,&quot;relative&quot;,&quot;path&quot;,&quot;directory&quot;,&quot;file&quot;,&quot;query&quot;,&quot;anchor&quot;],
                 parser: {strict: /^(?:([^:\/?#]+):)?(?:\/\/((?:(([^:@\/]*):?([^:@\/]*))?@)?([^:\/?#]*)(?::(\d*))?))?((((?:[^?#\/]*\/)*)([^?#]*))(?:\?([^#]*))?(?:#(.*))?)/ }};
        var m = o.parser.strict.exec(str);
        var uri = {};
        var i = 14;
        while (i--) uri[o.key[i]] = m[i] || &quot;&quot;;
        return uri;
    }
,
    normalizeParameters: function normalizeParameters(parameters) {
        if (parameters == null) {
            return &quot;&quot;;
        }
        var list = OAuth.getParameterList(parameters);
        var sortable = [];
        for (var p = 0; p &lt; list.length; ++p) {
            var nvp = list[p];
            if (nvp[0] != &quot;oauth_signature&quot;) {
                sortable.push([ OAuth.percentEncode(nvp[0])
                              + &quot; &quot; // because it comes before any character that can appear in a percentEncoded string.
                              + OAuth.percentEncode(nvp[1])
                              , nvp]);
            }
        }
        sortable.sort(function(a,b) {
                          if (a[0] &lt; b[0]) return  -1;
                          if (a[0] &gt; b[0]) return 1;
                          return 0;
                      });
        var sorted = [];
        for (var s = 0; s &lt; sortable.length; ++s) {
            sorted.push(sortable[s][1]);
        }
        return OAuth.formEncode(sorted);
    }
});

OAuth.SignatureMethod.registerMethodClass([&quot;PLAINTEXT&quot;, &quot;PLAINTEXT-Accessor&quot;],
    OAuth.SignatureMethod.makeSubclass(
        function getSignature(baseString) {
            return this.key;
        }
    ));

OAuth.SignatureMethod.registerMethodClass([&quot;HMAC-SHA1&quot;, &quot;HMAC-SHA1-Accessor&quot;],
    OAuth.SignatureMethod.makeSubclass(
        function getSignature(baseString) {
            b64pad = &apos;=&apos;;
            var signature = b64_hmac_sha1(this.key, baseString);
            return signature;
        }
    ));

try {
    OAuth.correctTimestampFromSrc();
} catch(e) {
}


//--------------------------------------------------

var consumerKey = &quot;${consumer_key}&quot;;
var consumerSecret = &quot;${consumer_secret}&quot;;
var params = [];
var query = [];
query.push(&apos;access_token&apos; + &apos;=&apos; + &apos;aaaaaa&apos;);
query.push(&apos;id_token&apos; + &apos;=&apos; + &apos;${id_token}&apos;);
var url =  &quot;${protocol}://${misp_url}/marvelous/people/@me/@self&quot;;

if (query.length) {
    url += &apos;?&apos; + query.join(&apos;&amp;&apos;);
}

var message = {
    method: &apos;get&apos;,
    parameters: params, 
    action: url
};

log.info(url);
log.info(consumerSecret);

var accessor = {
    consumerKey: consumerKey,
    consumerSecret: consumerSecret,
    token:  &apos;${access_token}&apos;,
    tokenSecret: &apos;${id_token}&apos;
};

OAuth.completeRequest(message, accessor);
vars.put(&apos;put_auth_header&apos;, OAuth.getAuthorizationHeader(&apos;&apos;, params).replace(&apos;OAuth realm=&quot;&quot;,&apos;, &apos; OAuth &apos;));
</stringProp>
            <stringProp name="scriptLanguage">javascript</stringProp>
          </BSFPreProcessor>
          <hashTree/>
          <HeaderManager guiclass="HeaderPanel" testclass="HeaderManager" testname="HTTP ヘッダマネージャ" enabled="true">
            <collectionProp name="HeaderManager.headers">
              <elementProp name="" elementType="Header">
                <stringProp name="Header.name">Authorization</stringProp>
                <stringProp name="Header.value">${put_auth_header}</stringProp>
              </elementProp>
              <elementProp name="" elementType="Header">
                <stringProp name="Header.name">content-type</stringProp>
                <stringProp name="Header.value">application/x-www-form-urlencoded</stringProp>
              </elementProp>
              <elementProp name="" elementType="Header">
                <stringProp name="Header.name">Connection</stringProp>
                <stringProp name="Header.value">close</stringProp>
              </elementProp>
              <elementProp name="" elementType="Header">
                <stringProp name="Header.name">Accept-encoding</stringProp>
                <stringProp name="Header.value">gzip, deflate</stringProp>
              </elementProp>
            </collectionProp>
          </HeaderManager>
          <hashTree/>
          <BSFAssertion guiclass="TestBeanGUI" testclass="BSFAssertion" testname="レスポンスコード401" enabled="true">
            <stringProp name="filename"></stringProp>
            <stringProp name="parameters"></stringProp>
            <stringProp name="script">if (prev.getResponseCode() == &quot;401&quot;) {
	AssertionResult.setFailure(false);
	prev.setSuccessful(true);
} else {
	AssertionResult.setFailure(true);
	AssertionResult.setFailureMessage(prev.getResponseCode());
}</stringProp>
            <stringProp name="scriptLanguage">javascript</stringProp>
          </BSFAssertion>
          <hashTree/>
        </hashTree>
      </hashTree>
      <ThreadGroup guiclass="ThreadGroupGui" testclass="ThreadGroup" testname="Basic_1.ID連携→解除" enabled="true">
        <stringProp name="ThreadGroup.on_sample_error">continue</stringProp>
        <elementProp name="ThreadGroup.main_controller" elementType="LoopController" guiclass="LoopControlPanel" testclass="LoopController" testname="ループコントローラ" enabled="true">
          <boolProp name="LoopController.continue_forever">false</boolProp>
          <stringProp name="LoopController.loops">1</stringProp>
        </elementProp>
        <stringProp name="ThreadGroup.num_threads">1</stringProp>
        <stringProp name="ThreadGroup.ramp_time">1</stringProp>
        <longProp name="ThreadGroup.start_time">1386654990000</longProp>
        <longProp name="ThreadGroup.end_time">1386654990000</longProp>
        <boolProp name="ThreadGroup.scheduler">false</boolProp>
        <stringProp name="ThreadGroup.duration"></stringProp>
        <stringProp name="ThreadGroup.delay"></stringProp>
        <stringProp name="TestPlan.comments">Dummy3は</stringProp>
      </ThreadGroup>
      <hashTree>
        <HTTPSamplerProxy guiclass="HttpTestSampleGui" testclass="HTTPSamplerProxy" testname="Basic.ID連携認証" enabled="true">
          <elementProp name="HTTPsampler.Arguments" elementType="Arguments" guiclass="HTTPArgumentsPanel" testclass="Arguments" enabled="true">
            <collectionProp name="Arguments.arguments">
              <elementProp name="response_type" elementType="HTTPArgument">
                <boolProp name="HTTPArgument.always_encode">false</boolProp>
                <stringProp name="Argument.name">response_type</stringProp>
                <stringProp name="Argument.value">code</stringProp>
                <stringProp name="Argument.metadata">=</stringProp>
                <boolProp name="HTTPArgument.use_equals">true</boolProp>
              </elementProp>
              <elementProp name="client_id" elementType="HTTPArgument">
                <boolProp name="HTTPArgument.always_encode">false</boolProp>
                <stringProp name="Argument.name">client_id</stringProp>
                <stringProp name="Argument.value">00000</stringProp>
                <stringProp name="Argument.metadata">=</stringProp>
                <boolProp name="HTTPArgument.use_equals">true</boolProp>
              </elementProp>
              <elementProp name="redirect_uri" elementType="HTTPArgument">
                <boolProp name="HTTPArgument.always_encode">false</boolProp>
                <stringProp name="Argument.name">redirect_uri</stringProp>
                <stringProp name="Argument.value">${protocol}%3A%2F%2F${jmeter_path}%2Ftest%2Fmisp%2Fmisp-callback</stringProp>
                <stringProp name="Argument.metadata">=</stringProp>
                <boolProp name="HTTPArgument.use_equals">true</boolProp>
              </elementProp>
              <elementProp name="scope" elementType="HTTPArgument">
                <boolProp name="HTTPArgument.always_encode">false</boolProp>
                <stringProp name="Argument.name">scope</stringProp>
                <stringProp name="Argument.value">openid</stringProp>
                <stringProp name="Argument.metadata">=</stringProp>
                <boolProp name="HTTPArgument.use_equals">true</boolProp>
              </elementProp>
              <elementProp name="state" elementType="HTTPArgument">
                <boolProp name="HTTPArgument.always_encode">false</boolProp>
                <stringProp name="Argument.name">state</stringProp>
                <stringProp name="Argument.value">ddd</stringProp>
                <stringProp name="Argument.metadata">=</stringProp>
                <boolProp name="HTTPArgument.use_equals">true</boolProp>
              </elementProp>
              <elementProp name="platform_id" elementType="HTTPArgument">
                <boolProp name="HTTPArgument.always_encode">false</boolProp>
                <stringProp name="Argument.name">platform_id</stringProp>
                <stringProp name="Argument.value">Dummy1</stringProp>
                <stringProp name="Argument.metadata">=</stringProp>
                <boolProp name="HTTPArgument.use_equals">true</boolProp>
              </elementProp>
            </collectionProp>
          </elementProp>
          <stringProp name="HTTPSampler.domain"></stringProp>
          <stringProp name="HTTPSampler.port"></stringProp>
          <stringProp name="HTTPSampler.connect_timeout"></stringProp>
          <stringProp name="HTTPSampler.response_timeout"></stringProp>
          <stringProp name="HTTPSampler.protocol"></stringProp>
          <stringProp name="HTTPSampler.contentEncoding"></stringProp>
          <stringProp name="HTTPSampler.path">/marvelous/federation</stringProp>
          <stringProp name="HTTPSampler.method">GET</stringProp>
          <boolProp name="HTTPSampler.follow_redirects">true</boolProp>
          <boolProp name="HTTPSampler.auto_redirects">false</boolProp>
          <boolProp name="HTTPSampler.use_keepalive">true</boolProp>
          <boolProp name="HTTPSampler.DO_MULTIPART_POST">false</boolProp>
          <boolProp name="HTTPSampler.monitor">false</boolProp>
          <stringProp name="HTTPSampler.embedded_url_re"></stringProp>
          <stringProp name="TestPlan.comments">Detected the start of a redirect chain</stringProp>
        </HTTPSamplerProxy>
        <hashTree>
          <RegexExtractor guiclass="RegexExtractorGui" testclass="RegexExtractor" testname="code" enabled="true">
            <stringProp name="RegexExtractor.useHeaders">false</stringProp>
            <stringProp name="RegexExtractor.refname">code</stringProp>
            <stringProp name="RegexExtractor.regex">code=(.*?)&lt;br&gt;</stringProp>
            <stringProp name="RegexExtractor.template">$1$</stringProp>
            <stringProp name="RegexExtractor.default"></stringProp>
            <stringProp name="RegexExtractor.match_number">1</stringProp>
          </RegexExtractor>
          <hashTree/>
        </hashTree>
        <HTTPSamplerProxy guiclass="HttpTestSampleGui" testclass="HTTPSamplerProxy" testname="Basic.トークン取得" enabled="true">
          <elementProp name="HTTPsampler.Arguments" elementType="Arguments" guiclass="HTTPArgumentsPanel" testclass="Arguments" enabled="true">
            <collectionProp name="Arguments.arguments">
              <elementProp name="code" elementType="HTTPArgument">
                <boolProp name="HTTPArgument.always_encode">false</boolProp>
                <stringProp name="Argument.value">${code}</stringProp>
                <stringProp name="Argument.metadata">=</stringProp>
                <boolProp name="HTTPArgument.use_equals">true</boolProp>
                <stringProp name="Argument.name">code</stringProp>
              </elementProp>
              <elementProp name="grant_type" elementType="HTTPArgument">
                <boolProp name="HTTPArgument.always_encode">false</boolProp>
                <stringProp name="Argument.value">authorization_code</stringProp>
                <stringProp name="Argument.metadata">=</stringProp>
                <boolProp name="HTTPArgument.use_equals">true</boolProp>
                <stringProp name="Argument.name">grant_type</stringProp>
              </elementProp>
              <elementProp name="redirect_uri" elementType="HTTPArgument">
                <boolProp name="HTTPArgument.always_encode">false</boolProp>
                <stringProp name="Argument.value">${protocol}%3A%2F%2F${jmeter_path}%2Ftest%2Fmisp%2Fmisp-callback</stringProp>
                <stringProp name="Argument.metadata">=</stringProp>
                <boolProp name="HTTPArgument.use_equals">true</boolProp>
                <stringProp name="Argument.name">redirect_uri</stringProp>
              </elementProp>
            </collectionProp>
          </elementProp>
          <stringProp name="HTTPSampler.domain">${jmeter_path}</stringProp>
          <stringProp name="HTTPSampler.port"></stringProp>
          <stringProp name="HTTPSampler.connect_timeout"></stringProp>
          <stringProp name="HTTPSampler.response_timeout"></stringProp>
          <stringProp name="HTTPSampler.protocol">${protocol}</stringProp>
          <stringProp name="HTTPSampler.contentEncoding">utf-8</stringProp>
          <stringProp name="HTTPSampler.path">/marvelous/token</stringProp>
          <stringProp name="HTTPSampler.method">POST</stringProp>
          <boolProp name="HTTPSampler.follow_redirects">true</boolProp>
          <boolProp name="HTTPSampler.auto_redirects">false</boolProp>
          <boolProp name="HTTPSampler.use_keepalive">true</boolProp>
          <boolProp name="HTTPSampler.DO_MULTIPART_POST">false</boolProp>
          <boolProp name="HTTPSampler.monitor">false</boolProp>
          <stringProp name="HTTPSampler.embedded_url_re"></stringProp>
          <stringProp name="TestPlan.comments">Detected the start of a redirect chain</stringProp>
        </HTTPSamplerProxy>
        <hashTree>
          <RegexExtractor guiclass="RegexExtractorGui" testclass="RegexExtractor" testname="access_token" enabled="true">
            <stringProp name="RegexExtractor.useHeaders">false</stringProp>
            <stringProp name="RegexExtractor.refname">access_token</stringProp>
            <stringProp name="RegexExtractor.regex">&quot;access_token&quot;:&quot;(.*?)&quot;,</stringProp>
            <stringProp name="RegexExtractor.template">$1$</stringProp>
            <stringProp name="RegexExtractor.default"></stringProp>
            <stringProp name="RegexExtractor.match_number">1</stringProp>
          </RegexExtractor>
          <hashTree/>
          <RegexExtractor guiclass="RegexExtractorGui" testclass="RegexExtractor" testname="id_token" enabled="true">
            <stringProp name="RegexExtractor.useHeaders">false</stringProp>
            <stringProp name="RegexExtractor.refname">id_token</stringProp>
            <stringProp name="RegexExtractor.regex">&quot;id_token&quot;:&quot;(.*?)&quot;</stringProp>
            <stringProp name="RegexExtractor.template">$1$</stringProp>
            <stringProp name="RegexExtractor.default"></stringProp>
            <stringProp name="RegexExtractor.match_number">1</stringProp>
          </RegexExtractor>
          <hashTree/>
          <BSFPreProcessor guiclass="TestBeanGUI" testclass="BSFPreProcessor" testname="BSF PreProcessor" enabled="true">
            <stringProp name="filename"></stringProp>
            <stringProp name="parameters"></stringProp>
            <stringProp name="script">/*
 * A JavaScript implementation of the Secure Hash Algorithm, SHA-1, as defined
 * in FIPS PUB 180-1
 * Version 2.1a Copyright Paul Johnston 2000 - 2002.
 * Other contributors: Greg Holt, Andrew Kepert, Ydnar, Lostinet
 * Distributed under the BSD License
 * See http://pajhome.org.uk/crypt/md5 for details.
 */

/*
 * Configurable variables. You may need to tweak these to be compatible with
 * the server-side, but the defaults work in most cases.
 */
var hexcase = 0;  /* hex output format. 0 - lowercase; 1 - uppercase        */
var b64pad  = &quot;&quot;; /* base-64 pad character. &quot;=&quot; for strict RFC compliance   */
var chrsz   = 8;  /* bits per input character. 8 - ASCII; 16 - Unicode      */

/*
 * These are the functions you&apos;ll usually want to call
 * They take string arguments and return either hex or base-64 encoded strings
 */
function hex_sha1(s){return binb2hex(core_sha1(str2binb(s),s.length * chrsz));}
function b64_sha1(s){return binb2b64(core_sha1(str2binb(s),s.length * chrsz));}
function str_sha1(s){return binb2str(core_sha1(str2binb(s),s.length * chrsz));}
function hex_hmac_sha1(key, data){ return binb2hex(core_hmac_sha1(key, data));}
function b64_hmac_sha1(key, data){ return binb2b64(core_hmac_sha1(key, data));}
function str_hmac_sha1(key, data){ return binb2str(core_hmac_sha1(key, data));}

/*
 * Perform a simple self-test to see if the VM is working
 */
function sha1_vm_test()
{
  return hex_sha1(&quot;abc&quot;) == &quot;a9993e364706816aba3e25717850c26c9cd0d89d&quot;;
}

/*
 * Calculate the SHA-1 of an array of big-endian words, and a bit length
 */
function core_sha1(x, len)
{
  /* append padding */
  x[len &gt;&gt; 5] |= 0x80 &lt;&lt; (24 - len % 32);
  x[((len + 64 &gt;&gt; 9) &lt;&lt; 4) + 15] = len;

  var w = Array(80);
  var a =  1732584193;
  var b = -271733879;
  var c = -1732584194;
  var d =  271733878;
  var e = -1009589776;

  for(var i = 0; i &lt; x.length; i += 16)
  {
    var olda = a;
    var oldb = b;
    var oldc = c;
    var oldd = d;
    var olde = e;

    for(var j = 0; j &lt; 80; j++)
    {
      if(j &lt; 16) w[j] = x[i + j];
      else w[j] = rol(w[j-3] ^ w[j-8] ^ w[j-14] ^ w[j-16], 1);
      var t = safe_add(safe_add(rol(a, 5), sha1_ft(j, b, c, d)),
                       safe_add(safe_add(e, w[j]), sha1_kt(j)));
      e = d;
      d = c;
      c = rol(b, 30);
      b = a;
      a = t;
    }

    a = safe_add(a, olda);
    b = safe_add(b, oldb);
    c = safe_add(c, oldc);
    d = safe_add(d, oldd);
    e = safe_add(e, olde);
  }
  return Array(a, b, c, d, e);

}

/*
 * Perform the appropriate triplet combination function for the current
 * iteration
 */
function sha1_ft(t, b, c, d)
{
  if(t &lt; 20) return (b &amp; c) | ((~b) &amp; d);
  if(t &lt; 40) return b ^ c ^ d;
  if(t &lt; 60) return (b &amp; c) | (b &amp; d) | (c &amp; d);
  return b ^ c ^ d;
}

/*
 * Determine the appropriate additive constant for the current iteration
 */
function sha1_kt(t)
{
  return (t &lt; 20) ?  1518500249 : (t &lt; 40) ?  1859775393 :
         (t &lt; 60) ? -1894007588 : -899497514;
}

/*
 * Calculate the HMAC-SHA1 of a key and some data
 */
function core_hmac_sha1(key, data)
{
  var bkey = str2binb(key);
  if(bkey.length &gt; 16) bkey = core_sha1(bkey, key.length * chrsz);

  var ipad = Array(16), opad = Array(16);
  for(var i = 0; i &lt; 16; i++)
  {
    ipad[i] = bkey[i] ^ 0x36363636;
    opad[i] = bkey[i] ^ 0x5C5C5C5C;
  }

  var hash = core_sha1(ipad.concat(str2binb(data)), 512 + data.length * chrsz);
  return core_sha1(opad.concat(hash), 512 + 160);
}

/*
 * Add integers, wrapping at 2^32. This uses 16-bit operations internally
 * to work around bugs in some JS interpreters.
 */
function safe_add(x, y)
{
  var lsw = (x &amp; 0xFFFF) + (y &amp; 0xFFFF);
  var msw = (x &gt;&gt; 16) + (y &gt;&gt; 16) + (lsw &gt;&gt; 16);
  return (msw &lt;&lt; 16) | (lsw &amp; 0xFFFF);
}

/*
 * Bitwise rotate a 32-bit number to the left.
 */
function rol(num, cnt)
{
  return (num &lt;&lt; cnt) | (num &gt;&gt;&gt; (32 - cnt));
}

/*
 * Convert an 8-bit or 16-bit string to an array of big-endian words
 * In 8-bit function, characters &gt;255 have their hi-byte silently ignored.
 */
function str2binb(str)
{
  var bin = Array();
  var mask = (1 &lt;&lt; chrsz) - 1;
  for(var i = 0; i &lt; str.length * chrsz; i += chrsz)
    bin[i&gt;&gt;5] |= (str.charCodeAt(i / chrsz) &amp; mask) &lt;&lt; (32 - chrsz - i%32);
  return bin;
}

/*
 * Convert an array of big-endian words to a string
 */
function binb2str(bin)
{
  var str = &quot;&quot;;
  var mask = (1 &lt;&lt; chrsz) - 1;
  for(var i = 0; i &lt; bin.length * 32; i += chrsz)
    str += String.fromCharCode((bin[i&gt;&gt;5] &gt;&gt;&gt; (32 - chrsz - i%32)) &amp; mask);
  return str;
}

/*
 * Convert an array of big-endian words to a hex string.
 */
function binb2hex(binarray)
{
  var hex_tab = hexcase ? &quot;0123456789ABCDEF&quot; : &quot;0123456789abcdef&quot;;
  var str = &quot;&quot;;
  for(var i = 0; i &lt; binarray.length * 4; i++)
  {
    str += hex_tab.charAt((binarray[i&gt;&gt;2] &gt;&gt; ((3 - i%4)*8+4)) &amp; 0xF) +
           hex_tab.charAt((binarray[i&gt;&gt;2] &gt;&gt; ((3 - i%4)*8  )) &amp; 0xF);
  }
  return str;
}

/*
 * Convert an array of big-endian words to a base-64 string
 */
function binb2b64(binarray)
{
  var tab = &quot;ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/&quot;;
  var str = &quot;&quot;;
  for(var i = 0; i &lt; binarray.length * 4; i += 3)
  {
    var triplet = (((binarray[i   &gt;&gt; 2] &gt;&gt; 8 * (3 -  i   %4)) &amp; 0xFF) &lt;&lt; 16)
                | (((binarray[i+1 &gt;&gt; 2] &gt;&gt; 8 * (3 - (i+1)%4)) &amp; 0xFF) &lt;&lt; 8 )
                |  ((binarray[i+2 &gt;&gt; 2] &gt;&gt; 8 * (3 - (i+2)%4)) &amp; 0xFF);
    for(var j = 0; j &lt; 4; j++)
    {
      if(i * 8 + j * 6 &gt; binarray.length * 32) str += b64pad;
      else str += tab.charAt((triplet &gt;&gt; 6*(3-j)) &amp; 0x3F);
    }
  }
  return str;
}

/*
 * Copyright 2008 Netflix, Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/* Here&apos;s some JavaScript software for implementing OAuth.

   This isn&apos;t as useful as you might hope.  OAuth is based around
   allowing tools and websites to talk to each other.  However,
   JavaScript running in web browsers is hampered by security
   restrictions that prevent code running on one website from
   accessing data stored or served on another.

   Before you start hacking, make sure you understand the limitations
   posed by cross-domain XMLHttpRequest.

   On the bright side, some platforms use JavaScript as their
   language, but enable the programmer to access other web sites.
   Examples include Google Gadgets, and Microsoft Vista Sidebar.
   For those platforms, this library should come in handy.
*/

// The HMAC-SHA1 signature method calls b64_hmac_sha1, defined by
// http://pajhome.org.uk/crypt/md5/sha1.js

/* An OAuth message is represented as an object like this:
   {method: &quot;GET&quot;, action: &quot;http://server.com/path&quot;, parameters: ...}

   The parameters may be either a map {name: value, name2: value2}
   or an Array of name-value pairs [[name, value], [name2, value2]].
   The latter representation is more powerful: it supports parameters
   in a specific sequence, or several parameters with the same name;
   for example [[&quot;a&quot;, 1], [&quot;b&quot;, 2], [&quot;a&quot;, 3]].

   Parameter names and values are NOT percent-encoded in an object.
   They must be encoded before transmission and decoded after reception.
   For example, this message object:
   {method: &quot;GET&quot;, action: &quot;http://server/path&quot;, parameters: {p: &quot;x y&quot;}}
   ... can be transmitted as an HTTP request that begins:
   GET /path?p=x%20y HTTP/1.0
   (This isn&apos;t a valid OAuth request, since it lacks a signature etc.)
   Note that the object &quot;x y&quot; is transmitted as x%20y.  To encode
   parameters, you can call OAuth.addToURL, OAuth.formEncode or
   OAuth.getAuthorization.

   This message object model harmonizes with the browser object model for
   input elements of an form, whose value property isn&apos;t percent encoded.
   The browser encodes each value before transmitting it. For example,
   see consumer.setInputs in example/consumer.js.
 */

/* This script needs to know what time it is. By default, it uses the local
   clock (new Date), which is apt to be inaccurate in browsers. To do
   better, you can load this script from a URL whose query string contains
   an oauth_timestamp parameter, whose value is a current Unix timestamp.
   For example, when generating the enclosing document using PHP:

   &lt;script src=&quot;oauth.js?oauth_timestamp=&lt;?=time()?&gt;&quot; ...

   Another option is to call OAuth.correctTimestamp with a Unix timestamp.
 */

var OAuth; if (OAuth == null) OAuth = {};

OAuth.setProperties = function setProperties(into, from) {
    if (into != null &amp;&amp; from != null) {
        for (var key in from) {
            into[key] = from[key];
        }
    }
    return into;
}

OAuth.setProperties(OAuth, // utility functions
{
    percentEncode: function percentEncode(s) {
        if (s == null) {
            return &quot;&quot;;
        }
        if (s instanceof Array) {
            var e = &quot;&quot;;
            for (var i = 0; i &lt; s.length; ++s) {
                if (e != &quot;&quot;) e += &apos;&amp;&apos;;
                e += OAuth.percentEncode(s[i]);
            }
            return e;
        }
        s = encodeURIComponent(s);
        // Now replace the values which encodeURIComponent doesn&apos;t do
        // encodeURIComponent ignores: - _ . ! ~ * &apos; ( )
        // OAuth dictates the only ones you can ignore are: - _ . ~
        // Source: http://developer.mozilla.org/en/docs/Core_JavaScript_1.5_Reference:Global_Functions:encodeURIComponent
        s = s.replace(/\!/g, &quot;%21&quot;);
        s = s.replace(/\*/g, &quot;%2A&quot;);
        s = s.replace(/\&apos;/g, &quot;%27&quot;);
        s = s.replace(/\(/g, &quot;%28&quot;);
        s = s.replace(/\)/g, &quot;%29&quot;);
        return s;
    }
,
    decodePercent: function decodePercent(s) {
        if (s != null) {
            // Handle application/x-www-form-urlencoded, which is defined by
            // http://www.w3.org/TR/html4/interact/forms.html#h-17.13.4.1
            s = s.replace(/\+/g, &quot; &quot;);
        }
        return decodeURIComponent(s);
    }
,
    /** Convert the given parameters to an Array of name-value pairs. */
    getParameterList: function getParameterList(parameters) {
        if (parameters == null) {
            return [];
        }
        if (typeof parameters != &quot;object&quot;) {
            return OAuth.decodeForm(parameters + &quot;&quot;);
        }
        if (parameters instanceof Array) {
            return parameters;
        }
        var list = [];
        for (var p in parameters) {
            list.push([p, parameters[p]]);
        }
        return list;
    }
,
    /** Convert the given parameters to a map from name to value. */
    getParameterMap: function getParameterMap(parameters) {
        if (parameters == null) {
            return {};
        }
        if (typeof parameters != &quot;object&quot;) {
            return OAuth.getParameterMap(OAuth.decodeForm(parameters + &quot;&quot;));
        }
        if (parameters instanceof Array) {
            var map = {};
            for (var p = 0; p &lt; parameters.length; ++p) {
                var key = parameters[p][0];
                if (map[key] === undefined) { // first value wins
                    map[key] = parameters[p][1];
                }
            }
            return map;
        }
        return parameters;
    }
,
    getParameter: function getParameter(parameters, name) {
        if (parameters instanceof Array) {
            for (var p = 0; p &lt; parameters.length; ++p) {
                if (parameters[p][0] == name) {
                    return parameters[p][1]; // first value wins
                }
            }
        } else {
            return OAuth.getParameterMap(parameters)[name];
        }
        return null;
    }
,
    formEncode: function formEncode(parameters) {
        var form = &quot;&quot;;
        var list = OAuth.getParameterList(parameters);
        for (var p = 0; p &lt; list.length; ++p) {
            var value = list[p][1];
            if (value == null) value = &quot;&quot;;
            if (form != &quot;&quot;) form += &apos;&amp;&apos;;
            form += OAuth.percentEncode(list[p][0])
              +&apos;=&apos;+ OAuth.percentEncode(value);
        }
        return form;
    }
,
    decodeForm: function decodeForm(form) {
        var list = [];
        var nvps = form.split(&apos;&amp;&apos;);
        for (var n = 0; n &lt; nvps.length; ++n) {
            var nvp = nvps[n];
            if (nvp == &quot;&quot;) {
                continue;
            }
            var equals = nvp.indexOf(&apos;=&apos;);
            var name;
            var value;
            if (equals &lt; 0) {
                name = OAuth.decodePercent(nvp);
                value = null;
            } else {
                name = OAuth.decodePercent(nvp.substring(0, equals));
                value = OAuth.decodePercent(nvp.substring(equals + 1));
            }
            list.push([name, value]);
        }
        return list;
    }
,
    setParameter: function setParameter(message, name, value) {
        var parameters = message.parameters;
        if (parameters instanceof Array) {
            for (var p = 0; p &lt; parameters.length; ++p) {
                if (parameters[p][0] == name) {
                    if (value === undefined) {
                        parameters.splice(p, 1);
                    } else {
                        parameters[p][1] = value;
                        value = undefined;
                    }
                }
            }
            if (value !== undefined) {
                parameters.push([name, value]);
            }
        } else {
            parameters = OAuth.getParameterMap(parameters);
            parameters[name] = value;
            message.parameters = parameters;
        }
    }
,
    setParameters: function setParameters(message, parameters) {
        var list = OAuth.getParameterList(parameters);
        for (var i = 0; i &lt; list.length; ++i) {
            OAuth.setParameter(message, list[i][0], list[i][1]);
        }
    }
,
    /** Fill in parameters to help construct a request message.
        This function doesn&apos;t fill in every parameter.
        The accessor object should be like:
        {consumerKey:&apos;foo&apos;, consumerSecret:&apos;bar&apos;, accessorSecret:&apos;nurn&apos;, token:&apos;krelm&apos;, tokenSecret:&apos;blah&apos;}
        The accessorSecret property is optional.
     */
    completeRequest: function completeRequest(message, accessor) {
        if (message.method == null) {
            message.method = &quot;GET&quot;;
        }
        var map = OAuth.getParameterMap(message.parameters);
        if (map.oauth_consumer_key == null) {
            OAuth.setParameter(message, &quot;oauth_consumer_key&quot;, accessor.consumerKey || &quot;&quot;);
        }
        if (map.oauth_token == null &amp;&amp; accessor.token != null) {
            OAuth.setParameter(message, &quot;oauth_token&quot;, accessor.token);
        }
        if (map.oauth_version == null) {
            OAuth.setParameter(message, &quot;oauth_version&quot;, &quot;1.0&quot;);
        }
        if (map.oauth_timestamp == null) {
            OAuth.setParameter(message, &quot;oauth_timestamp&quot;, OAuth.timestamp());
        }
        if (map.oauth_nonce == null) {
            OAuth.setParameter(message, &quot;oauth_nonce&quot;, OAuth.nonce(6));
        }
        OAuth.SignatureMethod.sign(message, accessor);
    }
,
    setTimestampAndNonce: function setTimestampAndNonce(message) {
        OAuth.setParameter(message, &quot;oauth_timestamp&quot;, OAuth.timestamp());
        OAuth.setParameter(message, &quot;oauth_nonce&quot;, OAuth.nonce(6));
    }
,
    addToURL: function addToURL(url, parameters) {
        newURL = url;
        if (parameters != null) {
            var toAdd = OAuth.formEncode(parameters);
            if (toAdd.length &gt; 0) {
                var q = url.indexOf(&apos;?&apos;);
                if (q &lt; 0) newURL += &apos;?&apos;;
                else       newURL += &apos;&amp;&apos;;
                newURL += toAdd;
            }
        }
        return newURL;
    }
,
    /** Construct the value of the Authorization header for an HTTP request. */
    getAuthorizationHeader: function getAuthorizationHeader(realm, parameters) {
        var header = &apos;OAuth realm=&quot;&apos; + OAuth.percentEncode(realm) + &apos;&quot;&apos;;
        var list = OAuth.getParameterList(parameters);
        for (var p = 0; p &lt; list.length; ++p) {
            var parameter = list[p];
            var name = parameter[0];
            if (name.indexOf(&quot;oauth_&quot;) == 0) {
                header += &apos;,&apos; + OAuth.percentEncode(name) + &apos;=&quot;&apos; + OAuth.percentEncode(parameter[1]) + &apos;&quot;&apos;;
            }
        }
        return header;
    }
,
    /** Correct the time using a parameter from the URL from which the last script was loaded. */
    correctTimestampFromSrc: function correctTimestampFromSrc(parameterName) {
        parameterName = parameterName || &quot;oauth_timestamp&quot;;
        var scripts = document.getElementsByTagName(&apos;script&apos;);
        if (scripts == null || !scripts.length) return;
        var src = scripts[scripts.length-1].src;
        if (!src) return;
        var q = src.indexOf(&quot;?&quot;);
        if (q &lt; 0) return;
        parameters = OAuth.getParameterMap(OAuth.decodeForm(src.substring(q+1)));
        var t = parameters[parameterName];
        if (t == null) return;
        OAuth.correctTimestamp(t);
    }
,
    /** Generate timestamps starting with the given value. */
    correctTimestamp: function correctTimestamp(timestamp) {
        OAuth.timeCorrectionMsec = (timestamp * 1000) - (new Date()).getTime();
    }
,
    /** The difference between the correct time and my clock. */
    timeCorrectionMsec: 0
,
    timestamp: function timestamp() {
        var t = (new Date()).getTime() + OAuth.timeCorrectionMsec;
        return Math.floor(t / 1000);
    }
,
    nonce: function nonce(length) {
        var chars = OAuth.nonce.CHARS;
        var result = &quot;&quot;;
        for (var i = 0; i &lt; length; ++i) {
            var rnum = Math.floor(Math.random() * chars.length);
            result += chars.substring(rnum, rnum+1);
        }
        return result;
    }
});

OAuth.nonce.CHARS = &quot;0123456789ABCDEFGHIJKLMNOPQRSTUVWXTZabcdefghiklmnopqrstuvwxyz&quot;;

/** Define a constructor function,
    without causing trouble to anyone who was using it as a namespace.
    That is, if parent[name] already existed and had properties,
    copy those properties into the new constructor.
 */
OAuth.declareClass = function declareClass(parent, name, newConstructor) {
    var previous = parent[name];
    parent[name] = newConstructor;
    if (newConstructor != null &amp;&amp; previous != null) {
        for (var key in previous) {
            if (key != &quot;prototype&quot;) {
                newConstructor[key] = previous[key];
            }
        }
    }
    return newConstructor;
}

/** An abstract algorithm for signing messages. */
OAuth.declareClass(OAuth, &quot;SignatureMethod&quot;, function OAuthSignatureMethod(){});

OAuth.setProperties(OAuth.SignatureMethod.prototype, // instance members
{
    /** Add a signature to the message. */
    sign: function sign(message) {
        var baseString = OAuth.SignatureMethod.getBaseString(message);
        var signature = this.getSignature(baseString);
        OAuth.setParameter(message, &quot;oauth_signature&quot;, signature);
        return signature; // just in case someone&apos;s interested
    }
,
    /** Set the key string for signing. */
    initialize: function initialize(name, accessor) {
        var consumerSecret;
        if (accessor.accessorSecret != null
            &amp;&amp; name.length &gt; 9
            &amp;&amp; name.substring(name.length-9) == &quot;-Accessor&quot;)
        {
            consumerSecret = accessor.accessorSecret;
        } else {
            consumerSecret = accessor.consumerSecret;
        }
        this.key = OAuth.percentEncode(consumerSecret)
             +&quot;&amp;&quot;+ OAuth.percentEncode(accessor.tokenSecret);
    }
});

/* SignatureMethod expects an accessor object to be like this:
   {tokenSecret: &quot;lakjsdflkj...&quot;, consumerSecret: &quot;QOUEWRI..&quot;, accessorSecret: &quot;xcmvzc...&quot;}
   The accessorSecret property is optional.
 */
// Class members:
OAuth.setProperties(OAuth.SignatureMethod, // class members
{
    sign: function sign(message, accessor) {
        var name = OAuth.getParameterMap(message.parameters).oauth_signature_method;
        if (name == null || name == &quot;&quot;) {
            name = &quot;HMAC-SHA1&quot;;
            OAuth.setParameter(message, &quot;oauth_signature_method&quot;, name);
        }
        OAuth.SignatureMethod.newMethod(name, accessor).sign(message);
    }
,
    /** Instantiate a SignatureMethod for the given method name. */
    newMethod: function newMethod(name, accessor) {
        var impl = OAuth.SignatureMethod.REGISTERED[name];
        if (impl != null) {
            var method = new impl();
            method.initialize(name, accessor);
            return method;
        }
        var err = new Error(&quot;signature_method_rejected&quot;);
        var acceptable = &quot;&quot;;
        for (var r in OAuth.SignatureMethod.REGISTERED) {
            if (acceptable != &quot;&quot;) acceptable += &apos;&amp;&apos;;
            acceptable += OAuth.percentEncode(r);
        }
        err.oauth_acceptable_signature_methods = acceptable;
        throw err;
    }
,
    /** A map from signature method name to constructor. */
    REGISTERED : {}
,
    /** Subsequently, the given constructor will be used for the named methods.
        The constructor will be called with no parameters.
        The resulting object should usually implement getSignature(baseString).
        You can easily define such a constructor by calling makeSubclass, below.
     */
    registerMethodClass: function registerMethodClass(names, classConstructor) {
        for (var n = 0; n &lt; names.length; ++n) {
            OAuth.SignatureMethod.REGISTERED[names[n]] = classConstructor;
        }
    }
,
    /** Create a subclass of OAuth.SignatureMethod, with the given getSignature function. */
    makeSubclass: function makeSubclass(getSignatureFunction) {
        var superClass = OAuth.SignatureMethod;
        var subClass = function() {
            superClass.call(this);
        };
        subClass.prototype = new superClass();
        // Delete instance variables from prototype:
        // delete subclass.prototype... There aren&apos;t any.
        subClass.prototype.getSignature = getSignatureFunction;
        subClass.prototype.constructor = subClass;
        return subClass;
    }
,
    getBaseString: function getBaseString(message) {
        var URL = message.action;
        var q = URL.indexOf(&apos;?&apos;);
        var parameters;
        if (q &lt; 0) {
            parameters = message.parameters;
        } else {
            // Combine the URL query string with the other parameters:
            parameters = OAuth.decodeForm(URL.substring(q + 1));
            var toAdd = OAuth.getParameterList(message.parameters);
            for (var a = 0; a &lt; toAdd.length; ++a) {
                parameters.push(toAdd[a]);
            }
        }
        return OAuth.percentEncode(message.method.toUpperCase())
         +&apos;&amp;&apos;+ OAuth.percentEncode(OAuth.SignatureMethod.normalizeUrl(URL))
         +&apos;&amp;&apos;+ OAuth.percentEncode(OAuth.SignatureMethod.normalizeParameters(parameters));
    }
,
    normalizeUrl: function normalizeUrl(url) {
        var uri = OAuth.SignatureMethod.parseUri(url);
        var scheme = uri.protocol.toLowerCase();
        var authority = uri.authority.toLowerCase();
        var dropPort = (scheme == &quot;http&quot; &amp;&amp; uri.port == 80)
                    || (scheme == &quot;https&quot; &amp;&amp; uri.port == 443);
        if (dropPort) {
            // find the last : in the authority
            var index = authority.lastIndexOf(&quot;:&quot;);
            if (index &gt;= 0) {
                authority = authority.substring(0, index);
            }
        }
        var path = uri.path;
        if (!path) {
            path = &quot;/&quot;; // conforms to RFC 2616 section 3.2.2
        }
        // we know that there is no query and no fragment here.
        return scheme + &quot;://&quot; + authority + path;
    }
,
    parseUri: function parseUri (str) {
        /* This function was adapted from parseUri 1.2.1
           http://stevenlevithan.com/demo/parseuri/js/assets/parseuri.js
         */
        var o = {key: [&quot;source&quot;,&quot;protocol&quot;,&quot;authority&quot;,&quot;userInfo&quot;,&quot;user&quot;,&quot;password&quot;,&quot;host&quot;,&quot;port&quot;,&quot;relative&quot;,&quot;path&quot;,&quot;directory&quot;,&quot;file&quot;,&quot;query&quot;,&quot;anchor&quot;],
                 parser: {strict: /^(?:([^:\/?#]+):)?(?:\/\/((?:(([^:@\/]*):?([^:@\/]*))?@)?([^:\/?#]*)(?::(\d*))?))?((((?:[^?#\/]*\/)*)([^?#]*))(?:\?([^#]*))?(?:#(.*))?)/ }};
        var m = o.parser.strict.exec(str);
        var uri = {};
        var i = 14;
        while (i--) uri[o.key[i]] = m[i] || &quot;&quot;;
        return uri;
    }
,
    normalizeParameters: function normalizeParameters(parameters) {
        if (parameters == null) {
            return &quot;&quot;;
        }
        var list = OAuth.getParameterList(parameters);
        var sortable = [];
        for (var p = 0; p &lt; list.length; ++p) {
            var nvp = list[p];
            if (nvp[0] != &quot;oauth_signature&quot;) {
                sortable.push([ OAuth.percentEncode(nvp[0])
                              + &quot; &quot; // because it comes before any character that can appear in a percentEncoded string.
                              + OAuth.percentEncode(nvp[1])
                              , nvp]);
            }
        }
        sortable.sort(function(a,b) {
                          if (a[0] &lt; b[0]) return  -1;
                          if (a[0] &gt; b[0]) return 1;
                          return 0;
                      });
        var sorted = [];
        for (var s = 0; s &lt; sortable.length; ++s) {
            sorted.push(sortable[s][1]);
        }
        return OAuth.formEncode(sorted);
    }
});

OAuth.SignatureMethod.registerMethodClass([&quot;PLAINTEXT&quot;, &quot;PLAINTEXT-Accessor&quot;],
    OAuth.SignatureMethod.makeSubclass(
        function getSignature(baseString) {
            return this.key;
        }
    ));

OAuth.SignatureMethod.registerMethodClass([&quot;HMAC-SHA1&quot;, &quot;HMAC-SHA1-Accessor&quot;],
    OAuth.SignatureMethod.makeSubclass(
        function getSignature(baseString) {
            b64pad = &apos;=&apos;;
            var signature = b64_hmac_sha1(this.key, baseString);
            return signature;
        }
    ));

try {
    OAuth.correctTimestampFromSrc();
} catch(e) {
}


//--------------------------------------------------

var consumerKey = &quot;${consumer_key}&quot;;
var consumerSecret = &quot;${consumer_secret}&quot;;
var params = [];
var query = [];

query.push(&apos;code&apos; + &apos;=&apos; + &apos;${code}&apos;);
query.push(&apos;grant_type&apos; + &apos;=&apos; + &apos;authorization_code&apos;);
query.push(&apos;redirect_uri&apos; + &apos;=&apos; + &apos;${protocol}%3A%2F%2F${jmeter_path}%2Ftest%2Fmisp%2Fmisp-callback&apos;);
var url =  &quot;${protocol}://${misp_url}/marvelous/token&quot;;

if (query.length) {
    url += &apos;?&apos; + query.join(&apos;&amp;&apos;);
}

var message = {
    method: &apos;post&apos;,
    parameters: params, 
    action: url
};
       
var accessor = {
    consumerKey: consumerKey,
    consumerSecret: consumerSecret,
    token: null,
    tokenSecret: null
};

OAuth.completeRequest(message, accessor);
vars.put(&apos;token_auth_header&apos;, OAuth.getAuthorizationHeader(&apos;&apos;, params).replace(&apos;OAuth realm=&quot;&quot;,&apos;, &apos; OAuth &apos;));
</stringProp>
            <stringProp name="scriptLanguage">javascript</stringProp>
          </BSFPreProcessor>
          <hashTree/>
          <HeaderManager guiclass="HeaderPanel" testclass="HeaderManager" testname="HTTP ヘッダマネージャ" enabled="true">
            <collectionProp name="HeaderManager.headers">
              <elementProp name="" elementType="Header">
                <stringProp name="Header.name">Authorization</stringProp>
                <stringProp name="Header.value">${token_auth_header}</stringProp>
              </elementProp>
              <elementProp name="" elementType="Header">
                <stringProp name="Header.name">content-type</stringProp>
                <stringProp name="Header.value">application/x-www-form-urlencoded</stringProp>
              </elementProp>
            </collectionProp>
          </HeaderManager>
          <hashTree/>
        </hashTree>
        <HTTPSamplerProxy guiclass="HttpTestSampleGui" testclass="HTTPSamplerProxy" testname="Basic.ユーザ更新" enabled="true">
          <boolProp name="HTTPSampler.postBodyRaw">true</boolProp>
          <elementProp name="HTTPsampler.Arguments" elementType="Arguments">
            <collectionProp name="Arguments.arguments">
              <elementProp name="" elementType="HTTPArgument">
                <boolProp name="HTTPArgument.always_encode">false</boolProp>
                <stringProp name="Argument.value">{&#xd;
  &quot;entry&quot;: [&#xd;
    {&#xd;
      &quot;apps&quot;: [&#xd;
        {&#xd;
          &quot;value&quot;: {&#xd;
            &quot;appId&quot;: &quot;00000&quot;,&#xd;
            &quot;userId&quot;: &quot;trustedproxy_basic_2&quot;,&#xd;
            &quot;username&quot;: &quot;trustedproxyユーザ1&quot;,&#xd;
            &quot;password&quot;: &quot;trustedproxy_password1&quot;&#xd;
          }&#xd;
        }&#xd;
      ]&#xd;
    }&#xd;
  ]&#xd;
}</stringProp>
                <stringProp name="Argument.metadata">=</stringProp>
              </elementProp>
            </collectionProp>
          </elementProp>
          <stringProp name="HTTPSampler.domain"></stringProp>
          <stringProp name="HTTPSampler.port"></stringProp>
          <stringProp name="HTTPSampler.connect_timeout"></stringProp>
          <stringProp name="HTTPSampler.response_timeout"></stringProp>
          <stringProp name="HTTPSampler.protocol"></stringProp>
          <stringProp name="HTTPSampler.contentEncoding"></stringProp>
          <stringProp name="HTTPSampler.path">/marvelous/people/@me/@self?access_token=${access_token}&amp;id_token=${id_token}</stringProp>
          <stringProp name="HTTPSampler.method">PUT</stringProp>
          <boolProp name="HTTPSampler.follow_redirects">true</boolProp>
          <boolProp name="HTTPSampler.auto_redirects">false</boolProp>
          <boolProp name="HTTPSampler.use_keepalive">true</boolProp>
          <boolProp name="HTTPSampler.DO_MULTIPART_POST">false</boolProp>
          <boolProp name="HTTPSampler.monitor">false</boolProp>
          <stringProp name="HTTPSampler.embedded_url_re"></stringProp>
        </HTTPSamplerProxy>
        <hashTree>
          <BSFPreProcessor guiclass="TestBeanGUI" testclass="BSFPreProcessor" testname="BSF PreProcessor" enabled="true">
            <stringProp name="filename"></stringProp>
            <stringProp name="parameters"></stringProp>
            <stringProp name="script">/*
 * A JavaScript implementation of the Secure Hash Algorithm, SHA-1, as defined
 * in FIPS PUB 180-1
 * Version 2.1a Copyright Paul Johnston 2000 - 2002.
 * Other contributors: Greg Holt, Andrew Kepert, Ydnar, Lostinet
 * Distributed under the BSD License
 * See http://pajhome.org.uk/crypt/md5 for details.
 */

/*
 * Configurable variables. You may need to tweak these to be compatible with
 * the server-side, but the defaults work in most cases.
 */
var hexcase = 0;  /* hex output format. 0 - lowercase; 1 - uppercase        */
var b64pad  = &quot;&quot;; /* base-64 pad character. &quot;=&quot; for strict RFC compliance   */
var chrsz   = 8;  /* bits per input character. 8 - ASCII; 16 - Unicode      */

/*
 * These are the functions you&apos;ll usually want to call
 * They take string arguments and return either hex or base-64 encoded strings
 */
function hex_sha1(s){return binb2hex(core_sha1(str2binb(s),s.length * chrsz));}
function b64_sha1(s){return binb2b64(core_sha1(str2binb(s),s.length * chrsz));}
function str_sha1(s){return binb2str(core_sha1(str2binb(s),s.length * chrsz));}
function hex_hmac_sha1(key, data){ return binb2hex(core_hmac_sha1(key, data));}
function b64_hmac_sha1(key, data){ return binb2b64(core_hmac_sha1(key, data));}
function str_hmac_sha1(key, data){ return binb2str(core_hmac_sha1(key, data));}

/*
 * Perform a simple self-test to see if the VM is working
 */
function sha1_vm_test()
{
  return hex_sha1(&quot;abc&quot;) == &quot;a9993e364706816aba3e25717850c26c9cd0d89d&quot;;
}

/*
 * Calculate the SHA-1 of an array of big-endian words, and a bit length
 */
function core_sha1(x, len)
{
  /* append padding */
  x[len &gt;&gt; 5] |= 0x80 &lt;&lt; (24 - len % 32);
  x[((len + 64 &gt;&gt; 9) &lt;&lt; 4) + 15] = len;

  var w = Array(80);
  var a =  1732584193;
  var b = -271733879;
  var c = -1732584194;
  var d =  271733878;
  var e = -1009589776;

  for(var i = 0; i &lt; x.length; i += 16)
  {
    var olda = a;
    var oldb = b;
    var oldc = c;
    var oldd = d;
    var olde = e;

    for(var j = 0; j &lt; 80; j++)
    {
      if(j &lt; 16) w[j] = x[i + j];
      else w[j] = rol(w[j-3] ^ w[j-8] ^ w[j-14] ^ w[j-16], 1);
      var t = safe_add(safe_add(rol(a, 5), sha1_ft(j, b, c, d)),
                       safe_add(safe_add(e, w[j]), sha1_kt(j)));
      e = d;
      d = c;
      c = rol(b, 30);
      b = a;
      a = t;
    }

    a = safe_add(a, olda);
    b = safe_add(b, oldb);
    c = safe_add(c, oldc);
    d = safe_add(d, oldd);
    e = safe_add(e, olde);
  }
  return Array(a, b, c, d, e);

}

/*
 * Perform the appropriate triplet combination function for the current
 * iteration
 */
function sha1_ft(t, b, c, d)
{
  if(t &lt; 20) return (b &amp; c) | ((~b) &amp; d);
  if(t &lt; 40) return b ^ c ^ d;
  if(t &lt; 60) return (b &amp; c) | (b &amp; d) | (c &amp; d);
  return b ^ c ^ d;
}

/*
 * Determine the appropriate additive constant for the current iteration
 */
function sha1_kt(t)
{
  return (t &lt; 20) ?  1518500249 : (t &lt; 40) ?  1859775393 :
         (t &lt; 60) ? -1894007588 : -899497514;
}

/*
 * Calculate the HMAC-SHA1 of a key and some data
 */
function core_hmac_sha1(key, data)
{
  var bkey = str2binb(key);
  if(bkey.length &gt; 16) bkey = core_sha1(bkey, key.length * chrsz);

  var ipad = Array(16), opad = Array(16);
  for(var i = 0; i &lt; 16; i++)
  {
    ipad[i] = bkey[i] ^ 0x36363636;
    opad[i] = bkey[i] ^ 0x5C5C5C5C;
  }

  var hash = core_sha1(ipad.concat(str2binb(data)), 512 + data.length * chrsz);
  return core_sha1(opad.concat(hash), 512 + 160);
}

/*
 * Add integers, wrapping at 2^32. This uses 16-bit operations internally
 * to work around bugs in some JS interpreters.
 */
function safe_add(x, y)
{
  var lsw = (x &amp; 0xFFFF) + (y &amp; 0xFFFF);
  var msw = (x &gt;&gt; 16) + (y &gt;&gt; 16) + (lsw &gt;&gt; 16);
  return (msw &lt;&lt; 16) | (lsw &amp; 0xFFFF);
}

/*
 * Bitwise rotate a 32-bit number to the left.
 */
function rol(num, cnt)
{
  return (num &lt;&lt; cnt) | (num &gt;&gt;&gt; (32 - cnt));
}

/*
 * Convert an 8-bit or 16-bit string to an array of big-endian words
 * In 8-bit function, characters &gt;255 have their hi-byte silently ignored.
 */
function str2binb(str)
{
  var bin = Array();
  var mask = (1 &lt;&lt; chrsz) - 1;
  for(var i = 0; i &lt; str.length * chrsz; i += chrsz)
    bin[i&gt;&gt;5] |= (str.charCodeAt(i / chrsz) &amp; mask) &lt;&lt; (32 - chrsz - i%32);
  return bin;
}

/*
 * Convert an array of big-endian words to a string
 */
function binb2str(bin)
{
  var str = &quot;&quot;;
  var mask = (1 &lt;&lt; chrsz) - 1;
  for(var i = 0; i &lt; bin.length * 32; i += chrsz)
    str += String.fromCharCode((bin[i&gt;&gt;5] &gt;&gt;&gt; (32 - chrsz - i%32)) &amp; mask);
  return str;
}

/*
 * Convert an array of big-endian words to a hex string.
 */
function binb2hex(binarray)
{
  var hex_tab = hexcase ? &quot;0123456789ABCDEF&quot; : &quot;0123456789abcdef&quot;;
  var str = &quot;&quot;;
  for(var i = 0; i &lt; binarray.length * 4; i++)
  {
    str += hex_tab.charAt((binarray[i&gt;&gt;2] &gt;&gt; ((3 - i%4)*8+4)) &amp; 0xF) +
           hex_tab.charAt((binarray[i&gt;&gt;2] &gt;&gt; ((3 - i%4)*8  )) &amp; 0xF);
  }
  return str;
}

/*
 * Convert an array of big-endian words to a base-64 string
 */
function binb2b64(binarray)
{
  var tab = &quot;ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/&quot;;
  var str = &quot;&quot;;
  for(var i = 0; i &lt; binarray.length * 4; i += 3)
  {
    var triplet = (((binarray[i   &gt;&gt; 2] &gt;&gt; 8 * (3 -  i   %4)) &amp; 0xFF) &lt;&lt; 16)
                | (((binarray[i+1 &gt;&gt; 2] &gt;&gt; 8 * (3 - (i+1)%4)) &amp; 0xFF) &lt;&lt; 8 )
                |  ((binarray[i+2 &gt;&gt; 2] &gt;&gt; 8 * (3 - (i+2)%4)) &amp; 0xFF);
    for(var j = 0; j &lt; 4; j++)
    {
      if(i * 8 + j * 6 &gt; binarray.length * 32) str += b64pad;
      else str += tab.charAt((triplet &gt;&gt; 6*(3-j)) &amp; 0x3F);
    }
  }
  return str;
}

/*
 * Copyright 2008 Netflix, Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/* Here&apos;s some JavaScript software for implementing OAuth.

   This isn&apos;t as useful as you might hope.  OAuth is based around
   allowing tools and websites to talk to each other.  However,
   JavaScript running in web browsers is hampered by security
   restrictions that prevent code running on one website from
   accessing data stored or served on another.

   Before you start hacking, make sure you understand the limitations
   posed by cross-domain XMLHttpRequest.

   On the bright side, some platforms use JavaScript as their
   language, but enable the programmer to access other web sites.
   Examples include Google Gadgets, and Microsoft Vista Sidebar.
   For those platforms, this library should come in handy.
*/

// The HMAC-SHA1 signature method calls b64_hmac_sha1, defined by
// http://pajhome.org.uk/crypt/md5/sha1.js

/* An OAuth message is represented as an object like this:
   {method: &quot;GET&quot;, action: &quot;http://server.com/path&quot;, parameters: ...}

   The parameters may be either a map {name: value, name2: value2}
   or an Array of name-value pairs [[name, value], [name2, value2]].
   The latter representation is more powerful: it supports parameters
   in a specific sequence, or several parameters with the same name;
   for example [[&quot;a&quot;, 1], [&quot;b&quot;, 2], [&quot;a&quot;, 3]].

   Parameter names and values are NOT percent-encoded in an object.
   They must be encoded before transmission and decoded after reception.
   For example, this message object:
   {method: &quot;GET&quot;, action: &quot;http://server/path&quot;, parameters: {p: &quot;x y&quot;}}
   ... can be transmitted as an HTTP request that begins:
   GET /path?p=x%20y HTTP/1.0
   (This isn&apos;t a valid OAuth request, since it lacks a signature etc.)
   Note that the object &quot;x y&quot; is transmitted as x%20y.  To encode
   parameters, you can call OAuth.addToURL, OAuth.formEncode or
   OAuth.getAuthorization.

   This message object model harmonizes with the browser object model for
   input elements of an form, whose value property isn&apos;t percent encoded.
   The browser encodes each value before transmitting it. For example,
   see consumer.setInputs in example/consumer.js.
 */

/* This script needs to know what time it is. By default, it uses the local
   clock (new Date), which is apt to be inaccurate in browsers. To do
   better, you can load this script from a URL whose query string contains
   an oauth_timestamp parameter, whose value is a current Unix timestamp.
   For example, when generating the enclosing document using PHP:

   &lt;script src=&quot;oauth.js?oauth_timestamp=&lt;?=time()?&gt;&quot; ...

   Another option is to call OAuth.correctTimestamp with a Unix timestamp.
 */

var OAuth; if (OAuth == null) OAuth = {};

OAuth.setProperties = function setProperties(into, from) {
    if (into != null &amp;&amp; from != null) {
        for (var key in from) {
            into[key] = from[key];
        }
    }
    return into;
}

OAuth.setProperties(OAuth, // utility functions
{
    percentEncode: function percentEncode(s) {
        if (s == null) {
            return &quot;&quot;;
        }
        if (s instanceof Array) {
            var e = &quot;&quot;;
            for (var i = 0; i &lt; s.length; ++s) {
                if (e != &quot;&quot;) e += &apos;&amp;&apos;;
                e += OAuth.percentEncode(s[i]);
            }
            return e;
        }
        s = encodeURIComponent(s);
        // Now replace the values which encodeURIComponent doesn&apos;t do
        // encodeURIComponent ignores: - _ . ! ~ * &apos; ( )
        // OAuth dictates the only ones you can ignore are: - _ . ~
        // Source: http://developer.mozilla.org/en/docs/Core_JavaScript_1.5_Reference:Global_Functions:encodeURIComponent
        s = s.replace(/\!/g, &quot;%21&quot;);
        s = s.replace(/\*/g, &quot;%2A&quot;);
        s = s.replace(/\&apos;/g, &quot;%27&quot;);
        s = s.replace(/\(/g, &quot;%28&quot;);
        s = s.replace(/\)/g, &quot;%29&quot;);
        return s;
    }
,
    decodePercent: function decodePercent(s) {
        if (s != null) {
            // Handle application/x-www-form-urlencoded, which is defined by
            // http://www.w3.org/TR/html4/interact/forms.html#h-17.13.4.1
            s = s.replace(/\+/g, &quot; &quot;);
        }
        return decodeURIComponent(s);
    }
,
    /** Convert the given parameters to an Array of name-value pairs. */
    getParameterList: function getParameterList(parameters) {
        if (parameters == null) {
            return [];
        }
        if (typeof parameters != &quot;object&quot;) {
            return OAuth.decodeForm(parameters + &quot;&quot;);
        }
        if (parameters instanceof Array) {
            return parameters;
        }
        var list = [];
        for (var p in parameters) {
            list.push([p, parameters[p]]);
        }
        return list;
    }
,
    /** Convert the given parameters to a map from name to value. */
    getParameterMap: function getParameterMap(parameters) {
        if (parameters == null) {
            return {};
        }
        if (typeof parameters != &quot;object&quot;) {
            return OAuth.getParameterMap(OAuth.decodeForm(parameters + &quot;&quot;));
        }
        if (parameters instanceof Array) {
            var map = {};
            for (var p = 0; p &lt; parameters.length; ++p) {
                var key = parameters[p][0];
                if (map[key] === undefined) { // first value wins
                    map[key] = parameters[p][1];
                }
            }
            return map;
        }
        return parameters;
    }
,
    getParameter: function getParameter(parameters, name) {
        if (parameters instanceof Array) {
            for (var p = 0; p &lt; parameters.length; ++p) {
                if (parameters[p][0] == name) {
                    return parameters[p][1]; // first value wins
                }
            }
        } else {
            return OAuth.getParameterMap(parameters)[name];
        }
        return null;
    }
,
    formEncode: function formEncode(parameters) {
        var form = &quot;&quot;;
        var list = OAuth.getParameterList(parameters);
        for (var p = 0; p &lt; list.length; ++p) {
            var value = list[p][1];
            if (value == null) value = &quot;&quot;;
            if (form != &quot;&quot;) form += &apos;&amp;&apos;;
            form += OAuth.percentEncode(list[p][0])
              +&apos;=&apos;+ OAuth.percentEncode(value);
        }
        return form;
    }
,
    decodeForm: function decodeForm(form) {
        var list = [];
        var nvps = form.split(&apos;&amp;&apos;);
        for (var n = 0; n &lt; nvps.length; ++n) {
            var nvp = nvps[n];
            if (nvp == &quot;&quot;) {
                continue;
            }
            var equals = nvp.indexOf(&apos;=&apos;);
            var name;
            var value;
            if (equals &lt; 0) {
                name = OAuth.decodePercent(nvp);
                value = null;
            } else {
                name = OAuth.decodePercent(nvp.substring(0, equals));
                value = OAuth.decodePercent(nvp.substring(equals + 1));
            }
            list.push([name, value]);
        }
        return list;
    }
,
    setParameter: function setParameter(message, name, value) {
        var parameters = message.parameters;
        if (parameters instanceof Array) {
            for (var p = 0; p &lt; parameters.length; ++p) {
                if (parameters[p][0] == name) {
                    if (value === undefined) {
                        parameters.splice(p, 1);
                    } else {
                        parameters[p][1] = value;
                        value = undefined;
                    }
                }
            }
            if (value !== undefined) {
                parameters.push([name, value]);
            }
        } else {
            parameters = OAuth.getParameterMap(parameters);
            parameters[name] = value;
            message.parameters = parameters;
        }
    }
,
    setParameters: function setParameters(message, parameters) {
        var list = OAuth.getParameterList(parameters);
        for (var i = 0; i &lt; list.length; ++i) {
            OAuth.setParameter(message, list[i][0], list[i][1]);
        }
    }
,
    /** Fill in parameters to help construct a request message.
        This function doesn&apos;t fill in every parameter.
        The accessor object should be like:
        {consumerKey:&apos;foo&apos;, consumerSecret:&apos;bar&apos;, accessorSecret:&apos;nurn&apos;, token:&apos;krelm&apos;, tokenSecret:&apos;blah&apos;}
        The accessorSecret property is optional.
     */
    completeRequest: function completeRequest(message, accessor) {
        if (message.method == null) {
            message.method = &quot;GET&quot;;
        }
        var map = OAuth.getParameterMap(message.parameters);
        if (map.oauth_consumer_key == null) {
            OAuth.setParameter(message, &quot;oauth_consumer_key&quot;, accessor.consumerKey || &quot;&quot;);
        }
        if (map.oauth_token == null &amp;&amp; accessor.token != null) {
            OAuth.setParameter(message, &quot;oauth_token&quot;, accessor.token);
        }
        if (map.oauth_version == null) {
            OAuth.setParameter(message, &quot;oauth_version&quot;, &quot;1.0&quot;);
        }
        if (map.oauth_timestamp == null) {
            OAuth.setParameter(message, &quot;oauth_timestamp&quot;, OAuth.timestamp());
        }
        if (map.oauth_nonce == null) {
            OAuth.setParameter(message, &quot;oauth_nonce&quot;, OAuth.nonce(6));
        }
        OAuth.SignatureMethod.sign(message, accessor);
    }
,
    setTimestampAndNonce: function setTimestampAndNonce(message) {
        OAuth.setParameter(message, &quot;oauth_timestamp&quot;, OAuth.timestamp());
        OAuth.setParameter(message, &quot;oauth_nonce&quot;, OAuth.nonce(6));
    }
,
    addToURL: function addToURL(url, parameters) {
        newURL = url;
        if (parameters != null) {
            var toAdd = OAuth.formEncode(parameters);
            if (toAdd.length &gt; 0) {
                var q = url.indexOf(&apos;?&apos;);
                if (q &lt; 0) newURL += &apos;?&apos;;
                else       newURL += &apos;&amp;&apos;;
                newURL += toAdd;
            }
        }
        return newURL;
    }
,
    /** Construct the value of the Authorization header for an HTTP request. */
    getAuthorizationHeader: function getAuthorizationHeader(realm, parameters) {
        var header = &apos;OAuth realm=&quot;&apos; + OAuth.percentEncode(realm) + &apos;&quot;&apos;;
        var list = OAuth.getParameterList(parameters);
        for (var p = 0; p &lt; list.length; ++p) {
            var parameter = list[p];
            var name = parameter[0];
            if (name.indexOf(&quot;oauth_&quot;) == 0) {
                header += &apos;,&apos; + OAuth.percentEncode(name) + &apos;=&quot;&apos; + OAuth.percentEncode(parameter[1]) + &apos;&quot;&apos;;
            }
        }
        return header;
    }
,
    /** Correct the time using a parameter from the URL from which the last script was loaded. */
    correctTimestampFromSrc: function correctTimestampFromSrc(parameterName) {
        parameterName = parameterName || &quot;oauth_timestamp&quot;;
        var scripts = document.getElementsByTagName(&apos;script&apos;);
        if (scripts == null || !scripts.length) return;
        var src = scripts[scripts.length-1].src;
        if (!src) return;
        var q = src.indexOf(&quot;?&quot;);
        if (q &lt; 0) return;
        parameters = OAuth.getParameterMap(OAuth.decodeForm(src.substring(q+1)));
        var t = parameters[parameterName];
        if (t == null) return;
        OAuth.correctTimestamp(t);
    }
,
    /** Generate timestamps starting with the given value. */
    correctTimestamp: function correctTimestamp(timestamp) {
        OAuth.timeCorrectionMsec = (timestamp * 1000) - (new Date()).getTime();
    }
,
    /** The difference between the correct time and my clock. */
    timeCorrectionMsec: 0
,
    timestamp: function timestamp() {
        var t = (new Date()).getTime() + OAuth.timeCorrectionMsec;
        return Math.floor(t / 1000);
    }
,
    nonce: function nonce(length) {
        var chars = OAuth.nonce.CHARS;
        var result = &quot;&quot;;
        for (var i = 0; i &lt; length; ++i) {
            var rnum = Math.floor(Math.random() * chars.length);
            result += chars.substring(rnum, rnum+1);
        }
        return result;
    }
});

OAuth.nonce.CHARS = &quot;0123456789ABCDEFGHIJKLMNOPQRSTUVWXTZabcdefghiklmnopqrstuvwxyz&quot;;

/** Define a constructor function,
    without causing trouble to anyone who was using it as a namespace.
    That is, if parent[name] already existed and had properties,
    copy those properties into the new constructor.
 */
OAuth.declareClass = function declareClass(parent, name, newConstructor) {
    var previous = parent[name];
    parent[name] = newConstructor;
    if (newConstructor != null &amp;&amp; previous != null) {
        for (var key in previous) {
            if (key != &quot;prototype&quot;) {
                newConstructor[key] = previous[key];
            }
        }
    }
    return newConstructor;
}

/** An abstract algorithm for signing messages. */
OAuth.declareClass(OAuth, &quot;SignatureMethod&quot;, function OAuthSignatureMethod(){});

OAuth.setProperties(OAuth.SignatureMethod.prototype, // instance members
{
    /** Add a signature to the message. */
    sign: function sign(message) {
        var baseString = OAuth.SignatureMethod.getBaseString(message);
        var signature = this.getSignature(baseString);
        OAuth.setParameter(message, &quot;oauth_signature&quot;, signature);
        return signature; // just in case someone&apos;s interested
    }
,
    /** Set the key string for signing. */
    initialize: function initialize(name, accessor) {
        var consumerSecret;
        if (accessor.accessorSecret != null
            &amp;&amp; name.length &gt; 9
            &amp;&amp; name.substring(name.length-9) == &quot;-Accessor&quot;)
        {
            consumerSecret = accessor.accessorSecret;
        } else {
            consumerSecret = accessor.consumerSecret;
        }
        this.key = OAuth.percentEncode(consumerSecret)
             +&quot;&amp;&quot;+ OAuth.percentEncode(accessor.tokenSecret);
    }
});

/* SignatureMethod expects an accessor object to be like this:
   {tokenSecret: &quot;lakjsdflkj...&quot;, consumerSecret: &quot;QOUEWRI..&quot;, accessorSecret: &quot;xcmvzc...&quot;}
   The accessorSecret property is optional.
 */
// Class members:
OAuth.setProperties(OAuth.SignatureMethod, // class members
{
    sign: function sign(message, accessor) {
        var name = OAuth.getParameterMap(message.parameters).oauth_signature_method;
        if (name == null || name == &quot;&quot;) {
            name = &quot;HMAC-SHA1&quot;;
            OAuth.setParameter(message, &quot;oauth_signature_method&quot;, name);
        }
        OAuth.SignatureMethod.newMethod(name, accessor).sign(message);
    }
,
    /** Instantiate a SignatureMethod for the given method name. */
    newMethod: function newMethod(name, accessor) {
        var impl = OAuth.SignatureMethod.REGISTERED[name];
        if (impl != null) {
            var method = new impl();
            method.initialize(name, accessor);
            return method;
        }
        var err = new Error(&quot;signature_method_rejected&quot;);
        var acceptable = &quot;&quot;;
        for (var r in OAuth.SignatureMethod.REGISTERED) {
            if (acceptable != &quot;&quot;) acceptable += &apos;&amp;&apos;;
            acceptable += OAuth.percentEncode(r);
        }
        err.oauth_acceptable_signature_methods = acceptable;
        throw err;
    }
,
    /** A map from signature method name to constructor. */
    REGISTERED : {}
,
    /** Subsequently, the given constructor will be used for the named methods.
        The constructor will be called with no parameters.
        The resulting object should usually implement getSignature(baseString).
        You can easily define such a constructor by calling makeSubclass, below.
     */
    registerMethodClass: function registerMethodClass(names, classConstructor) {
        for (var n = 0; n &lt; names.length; ++n) {
            OAuth.SignatureMethod.REGISTERED[names[n]] = classConstructor;
        }
    }
,
    /** Create a subclass of OAuth.SignatureMethod, with the given getSignature function. */
    makeSubclass: function makeSubclass(getSignatureFunction) {
        var superClass = OAuth.SignatureMethod;
        var subClass = function() {
            superClass.call(this);
        };
        subClass.prototype = new superClass();
        // Delete instance variables from prototype:
        // delete subclass.prototype... There aren&apos;t any.
        subClass.prototype.getSignature = getSignatureFunction;
        subClass.prototype.constructor = subClass;
        return subClass;
    }
,
    getBaseString: function getBaseString(message) {
        var URL = message.action;
        var q = URL.indexOf(&apos;?&apos;);
        var parameters;
        if (q &lt; 0) {
            parameters = message.parameters;
        } else {
            // Combine the URL query string with the other parameters:
            parameters = OAuth.decodeForm(URL.substring(q + 1));
            var toAdd = OAuth.getParameterList(message.parameters);
            for (var a = 0; a &lt; toAdd.length; ++a) {
                parameters.push(toAdd[a]);
            }
        }
        return OAuth.percentEncode(message.method.toUpperCase())
         +&apos;&amp;&apos;+ OAuth.percentEncode(OAuth.SignatureMethod.normalizeUrl(URL))
         +&apos;&amp;&apos;+ OAuth.percentEncode(OAuth.SignatureMethod.normalizeParameters(parameters));
    }
,
    normalizeUrl: function normalizeUrl(url) {
        var uri = OAuth.SignatureMethod.parseUri(url);
        var scheme = uri.protocol.toLowerCase();
        var authority = uri.authority.toLowerCase();
        var dropPort = (scheme == &quot;http&quot; &amp;&amp; uri.port == 80)
                    || (scheme == &quot;https&quot; &amp;&amp; uri.port == 443);
        if (dropPort) {
            // find the last : in the authority
            var index = authority.lastIndexOf(&quot;:&quot;);
            if (index &gt;= 0) {
                authority = authority.substring(0, index);
            }
        }
        var path = uri.path;
        if (!path) {
            path = &quot;/&quot;; // conforms to RFC 2616 section 3.2.2
        }
        // we know that there is no query and no fragment here.
        return scheme + &quot;://&quot; + authority + path;
    }
,
    parseUri: function parseUri (str) {
        /* This function was adapted from parseUri 1.2.1
           http://stevenlevithan.com/demo/parseuri/js/assets/parseuri.js
         */
        var o = {key: [&quot;source&quot;,&quot;protocol&quot;,&quot;authority&quot;,&quot;userInfo&quot;,&quot;user&quot;,&quot;password&quot;,&quot;host&quot;,&quot;port&quot;,&quot;relative&quot;,&quot;path&quot;,&quot;directory&quot;,&quot;file&quot;,&quot;query&quot;,&quot;anchor&quot;],
                 parser: {strict: /^(?:([^:\/?#]+):)?(?:\/\/((?:(([^:@\/]*):?([^:@\/]*))?@)?([^:\/?#]*)(?::(\d*))?))?((((?:[^?#\/]*\/)*)([^?#]*))(?:\?([^#]*))?(?:#(.*))?)/ }};
        var m = o.parser.strict.exec(str);
        var uri = {};
        var i = 14;
        while (i--) uri[o.key[i]] = m[i] || &quot;&quot;;
        return uri;
    }
,
    normalizeParameters: function normalizeParameters(parameters) {
        if (parameters == null) {
            return &quot;&quot;;
        }
        var list = OAuth.getParameterList(parameters);
        var sortable = [];
        for (var p = 0; p &lt; list.length; ++p) {
            var nvp = list[p];
            if (nvp[0] != &quot;oauth_signature&quot;) {
                sortable.push([ OAuth.percentEncode(nvp[0])
                              + &quot; &quot; // because it comes before any character that can appear in a percentEncoded string.
                              + OAuth.percentEncode(nvp[1])
                              , nvp]);
            }
        }
        sortable.sort(function(a,b) {
                          if (a[0] &lt; b[0]) return  -1;
                          if (a[0] &gt; b[0]) return 1;
                          return 0;
                      });
        var sorted = [];
        for (var s = 0; s &lt; sortable.length; ++s) {
            sorted.push(sortable[s][1]);
        }
        return OAuth.formEncode(sorted);
    }
});

OAuth.SignatureMethod.registerMethodClass([&quot;PLAINTEXT&quot;, &quot;PLAINTEXT-Accessor&quot;],
    OAuth.SignatureMethod.makeSubclass(
        function getSignature(baseString) {
            return this.key;
        }
    ));

OAuth.SignatureMethod.registerMethodClass([&quot;HMAC-SHA1&quot;, &quot;HMAC-SHA1-Accessor&quot;],
    OAuth.SignatureMethod.makeSubclass(
        function getSignature(baseString) {
            b64pad = &apos;=&apos;;
            var signature = b64_hmac_sha1(this.key, baseString);
            return signature;
        }
    ));

try {
    OAuth.correctTimestampFromSrc();
} catch(e) {
}


//--------------------------------------------------

var consumerKey = &quot;${consumer_key}&quot;;
var consumerSecret = &quot;${consumer_secret}&quot;;
var params = [];
var query = [];
query.push(&apos;access_token&apos; + &apos;=&apos; + &apos;${access_token}&apos;);
query.push(&apos;id_token&apos; + &apos;=&apos; + &apos;${id_token}&apos;);
var url =  &quot;${protocol}://${misp_url}/marvelous/people/@me/@self&quot;;

if (query.length) {
    url += &apos;?&apos; + query.join(&apos;&amp;&apos;);
}

var message = {
    method: &apos;put&apos;,
    parameters: params, 
    action: url
};

log.info(url);
log.info(consumerSecret);

var accessor = {
    consumerKey: consumerKey,
    consumerSecret: consumerSecret,
    token:  &apos;${access_token}&apos;,
    tokenSecret: &apos;${id_token}&apos;
};

OAuth.completeRequest(message, accessor);
vars.put(&apos;put_auth_header&apos;, OAuth.getAuthorizationHeader(&apos;&apos;, params).replace(&apos;OAuth realm=&quot;&quot;,&apos;, &apos; OAuth &apos;));
</stringProp>
            <stringProp name="scriptLanguage">javascript</stringProp>
          </BSFPreProcessor>
          <hashTree/>
          <HeaderManager guiclass="HeaderPanel" testclass="HeaderManager" testname="HTTP ヘッダマネージャ" enabled="true">
            <collectionProp name="HeaderManager.headers">
              <elementProp name="" elementType="Header">
                <stringProp name="Header.name">Authorization</stringProp>
                <stringProp name="Header.value">${put_auth_header}</stringProp>
              </elementProp>
              <elementProp name="" elementType="Header">
                <stringProp name="Header.name">content-type</stringProp>
                <stringProp name="Header.value">application/json; charset=utf8</stringProp>
              </elementProp>
              <elementProp name="" elementType="Header">
                <stringProp name="Header.name">Connection</stringProp>
                <stringProp name="Header.value">close</stringProp>
              </elementProp>
              <elementProp name="" elementType="Header">
                <stringProp name="Header.name">Accept-encoding</stringProp>
                <stringProp name="Header.value">gzip, deflate</stringProp>
              </elementProp>
            </collectionProp>
          </HeaderManager>
          <hashTree/>
        </hashTree>
        <HTTPSamplerProxy guiclass="HttpTestSampleGui" testclass="HTTPSamplerProxy" testname="Basic.MISP連携一覧画面" enabled="true">
          <elementProp name="HTTPsampler.Arguments" elementType="Arguments" guiclass="HTTPArgumentsPanel" testclass="Arguments" enabled="true">
            <collectionProp name="Arguments.arguments">
              <elementProp name="response_type" elementType="HTTPArgument">
                <boolProp name="HTTPArgument.always_encode">false</boolProp>
                <stringProp name="Argument.name">response_type</stringProp>
                <stringProp name="Argument.value">code</stringProp>
                <stringProp name="Argument.metadata">=</stringProp>
                <boolProp name="HTTPArgument.use_equals">true</boolProp>
              </elementProp>
              <elementProp name="client_id" elementType="HTTPArgument">
                <boolProp name="HTTPArgument.always_encode">false</boolProp>
                <stringProp name="Argument.name">client_id</stringProp>
                <stringProp name="Argument.value">00000</stringProp>
                <stringProp name="Argument.metadata">=</stringProp>
                <boolProp name="HTTPArgument.use_equals">true</boolProp>
              </elementProp>
              <elementProp name="redirect_uri" elementType="HTTPArgument">
                <boolProp name="HTTPArgument.always_encode">false</boolProp>
                <stringProp name="Argument.name">redirect_uri</stringProp>
                <stringProp name="Argument.value">${protocol}%3A%2F%2F${jmeter_path}%2Ftest%2Fmisp%2Fmisp-callback</stringProp>
                <stringProp name="Argument.metadata">=</stringProp>
                <boolProp name="HTTPArgument.use_equals">true</boolProp>
              </elementProp>
              <elementProp name="scope" elementType="HTTPArgument">
                <boolProp name="HTTPArgument.always_encode">false</boolProp>
                <stringProp name="Argument.name">scope</stringProp>
                <stringProp name="Argument.value">openid</stringProp>
                <stringProp name="Argument.metadata">=</stringProp>
                <boolProp name="HTTPArgument.use_equals">true</boolProp>
              </elementProp>
              <elementProp name="state" elementType="HTTPArgument">
                <boolProp name="HTTPArgument.always_encode">false</boolProp>
                <stringProp name="Argument.name">state</stringProp>
                <stringProp name="Argument.value">ddd</stringProp>
                <stringProp name="Argument.metadata">=</stringProp>
                <boolProp name="HTTPArgument.use_equals">true</boolProp>
              </elementProp>
              <elementProp name="nonce" elementType="HTTPArgument">
                <boolProp name="HTTPArgument.always_encode">false</boolProp>
                <stringProp name="Argument.name">nonce</stringProp>
                <stringProp name="Argument.value">nnnnonce</stringProp>
                <stringProp name="Argument.metadata">=</stringProp>
                <boolProp name="HTTPArgument.use_equals">true</boolProp>
              </elementProp>
              <elementProp name="access_token" elementType="HTTPArgument">
                <boolProp name="HTTPArgument.always_encode">false</boolProp>
                <stringProp name="Argument.value">${access_token}</stringProp>
                <stringProp name="Argument.metadata">=</stringProp>
                <boolProp name="HTTPArgument.use_equals">true</boolProp>
                <stringProp name="Argument.name">access_token</stringProp>
              </elementProp>
              <elementProp name="id_token" elementType="HTTPArgument">
                <boolProp name="HTTPArgument.always_encode">false</boolProp>
                <stringProp name="Argument.value">${id_token}</stringProp>
                <stringProp name="Argument.metadata">=</stringProp>
                <boolProp name="HTTPArgument.use_equals">true</boolProp>
                <stringProp name="Argument.name">id_token</stringProp>
              </elementProp>
            </collectionProp>
          </elementProp>
          <stringProp name="HTTPSampler.domain"></stringProp>
          <stringProp name="HTTPSampler.port"></stringProp>
          <stringProp name="HTTPSampler.connect_timeout"></stringProp>
          <stringProp name="HTTPSampler.response_timeout"></stringProp>
          <stringProp name="HTTPSampler.protocol"></stringProp>
          <stringProp name="HTTPSampler.contentEncoding"></stringProp>
          <stringProp name="HTTPSampler.path">/marvelous/authorization/login</stringProp>
          <stringProp name="HTTPSampler.method">GET</stringProp>
          <boolProp name="HTTPSampler.follow_redirects">true</boolProp>
          <boolProp name="HTTPSampler.auto_redirects">false</boolProp>
          <boolProp name="HTTPSampler.use_keepalive">true</boolProp>
          <boolProp name="HTTPSampler.DO_MULTIPART_POST">false</boolProp>
          <boolProp name="HTTPSampler.monitor">false</boolProp>
          <stringProp name="HTTPSampler.embedded_url_re"></stringProp>
        </HTTPSamplerProxy>
        <hashTree>
          <RegexExtractor guiclass="RegexExtractorGui" testclass="RegexExtractor" testname="response_type_params" enabled="true">
            <stringProp name="RegexExtractor.useHeaders">false</stringProp>
            <stringProp name="RegexExtractor.refname">response_type_params</stringProp>
            <stringProp name="RegexExtractor.regex">response_type=(.*?)&quot; data-cancelidfederation</stringProp>
            <stringProp name="RegexExtractor.template">$1$</stringProp>
            <stringProp name="RegexExtractor.default"></stringProp>
            <stringProp name="RegexExtractor.match_number">1</stringProp>
          </RegexExtractor>
          <hashTree/>
          <ResponseAssertion guiclass="AssertionGui" testclass="ResponseAssertion" testname="アサーション" enabled="true">
            <collectionProp name="Asserion.test_strings">
              <stringProp name="-443737813">platform_id=Dummy1&quot; data-login=&quot;true&quot; checked&gt;</stringProp>
            </collectionProp>
            <stringProp name="TestPlan.comments">確認項目
1.ユーザID統合された画面が表示されているか
2.最終ログインのプラットフォームに、ログイン状態のフラグが立っているか</stringProp>
            <stringProp name="Assertion.test_field">Assertion.response_data</stringProp>
            <boolProp name="Assertion.assume_success">false</boolProp>
            <intProp name="Assertion.test_type">2</intProp>
          </ResponseAssertion>
          <hashTree/>
        </hashTree>
        <HTTPSamplerProxy guiclass="HttpTestSampleGui" testclass="HTTPSamplerProxy" testname="Basic.連携解除" enabled="true">
          <elementProp name="HTTPsampler.Arguments" elementType="Arguments" guiclass="HTTPArgumentsPanel" testclass="Arguments" enabled="true">
            <collectionProp name="Arguments.arguments">
              <elementProp name="response_type" elementType="HTTPArgument">
                <boolProp name="HTTPArgument.always_encode">false</boolProp>
                <stringProp name="Argument.value">${response_type_params}</stringProp>
                <stringProp name="Argument.metadata">=</stringProp>
                <boolProp name="HTTPArgument.use_equals">true</boolProp>
                <stringProp name="Argument.name">response_type</stringProp>
              </elementProp>
            </collectionProp>
          </elementProp>
          <stringProp name="HTTPSampler.domain"></stringProp>
          <stringProp name="HTTPSampler.port"></stringProp>
          <stringProp name="HTTPSampler.connect_timeout"></stringProp>
          <stringProp name="HTTPSampler.response_timeout"></stringProp>
          <stringProp name="HTTPSampler.protocol"></stringProp>
          <stringProp name="HTTPSampler.contentEncoding"></stringProp>
          <stringProp name="HTTPSampler.path">/marvelous/federation/cancel-application-user-federation</stringProp>
          <stringProp name="HTTPSampler.method">GET</stringProp>
          <boolProp name="HTTPSampler.follow_redirects">true</boolProp>
          <boolProp name="HTTPSampler.auto_redirects">false</boolProp>
          <boolProp name="HTTPSampler.use_keepalive">true</boolProp>
          <boolProp name="HTTPSampler.DO_MULTIPART_POST">false</boolProp>
          <boolProp name="HTTPSampler.monitor">false</boolProp>
          <stringProp name="HTTPSampler.embedded_url_re"></stringProp>
          <stringProp name="TestPlan.comments">Detected the start of a redirect chain</stringProp>
        </HTTPSamplerProxy>
        <hashTree>
          <ResponseAssertion guiclass="AssertionGui" testclass="ResponseAssertion" testname="アサーション" enabled="true">
            <collectionProp name="Asserion.test_strings">
              <stringProp name="159609953">privacyprotection</stringProp>
            </collectionProp>
            <stringProp name="TestPlan.comments">確認項目
初回ログイン画面が表示されているか</stringProp>
            <stringProp name="Assertion.test_field">Assertion.response_data</stringProp>
            <boolProp name="Assertion.assume_success">false</boolProp>
            <intProp name="Assertion.test_type">2</intProp>
          </ResponseAssertion>
          <hashTree/>
        </hashTree>
      </hashTree>
      <ThreadGroup guiclass="ThreadGroupGui" testclass="ThreadGroup" testname="Basic_2.Dummy1→Dummy2 ID連携後、解除" enabled="true">
        <stringProp name="ThreadGroup.on_sample_error">continue</stringProp>
        <elementProp name="ThreadGroup.main_controller" elementType="LoopController" guiclass="LoopControlPanel" testclass="LoopController" testname="ループコントローラ" enabled="true">
          <boolProp name="LoopController.continue_forever">false</boolProp>
          <stringProp name="LoopController.loops">1</stringProp>
        </elementProp>
        <stringProp name="ThreadGroup.num_threads">1</stringProp>
        <stringProp name="ThreadGroup.ramp_time">1</stringProp>
        <longProp name="ThreadGroup.start_time">1386654990000</longProp>
        <longProp name="ThreadGroup.end_time">1386654990000</longProp>
        <boolProp name="ThreadGroup.scheduler">false</boolProp>
        <stringProp name="ThreadGroup.duration"></stringProp>
        <stringProp name="ThreadGroup.delay"></stringProp>
      </ThreadGroup>
      <hashTree>
        <HTTPSamplerProxy guiclass="HttpTestSampleGui" testclass="HTTPSamplerProxy" testname="Basic.ID連携認証(Dummy1)" enabled="true">
          <elementProp name="HTTPsampler.Arguments" elementType="Arguments" guiclass="HTTPArgumentsPanel" testclass="Arguments" enabled="true">
            <collectionProp name="Arguments.arguments">
              <elementProp name="response_type" elementType="HTTPArgument">
                <boolProp name="HTTPArgument.always_encode">false</boolProp>
                <stringProp name="Argument.name">response_type</stringProp>
                <stringProp name="Argument.value">code</stringProp>
                <stringProp name="Argument.metadata">=</stringProp>
                <boolProp name="HTTPArgument.use_equals">true</boolProp>
              </elementProp>
              <elementProp name="client_id" elementType="HTTPArgument">
                <boolProp name="HTTPArgument.always_encode">false</boolProp>
                <stringProp name="Argument.name">client_id</stringProp>
                <stringProp name="Argument.value">00000</stringProp>
                <stringProp name="Argument.metadata">=</stringProp>
                <boolProp name="HTTPArgument.use_equals">true</boolProp>
              </elementProp>
              <elementProp name="redirect_uri" elementType="HTTPArgument">
                <boolProp name="HTTPArgument.always_encode">false</boolProp>
                <stringProp name="Argument.name">redirect_uri</stringProp>
                <stringProp name="Argument.value">${protocol}%3A%2F%2F${jmeter_path}%2Ftest%2Fmisp%2Fmisp-callback</stringProp>
                <stringProp name="Argument.metadata">=</stringProp>
                <boolProp name="HTTPArgument.use_equals">true</boolProp>
              </elementProp>
              <elementProp name="scope" elementType="HTTPArgument">
                <boolProp name="HTTPArgument.always_encode">false</boolProp>
                <stringProp name="Argument.name">scope</stringProp>
                <stringProp name="Argument.value">openid</stringProp>
                <stringProp name="Argument.metadata">=</stringProp>
                <boolProp name="HTTPArgument.use_equals">true</boolProp>
              </elementProp>
              <elementProp name="state" elementType="HTTPArgument">
                <boolProp name="HTTPArgument.always_encode">false</boolProp>
                <stringProp name="Argument.name">state</stringProp>
                <stringProp name="Argument.value">ddd</stringProp>
                <stringProp name="Argument.metadata">=</stringProp>
                <boolProp name="HTTPArgument.use_equals">true</boolProp>
              </elementProp>
              <elementProp name="platform_id" elementType="HTTPArgument">
                <boolProp name="HTTPArgument.always_encode">false</boolProp>
                <stringProp name="Argument.name">platform_id</stringProp>
                <stringProp name="Argument.value">Dummy1</stringProp>
                <stringProp name="Argument.metadata">=</stringProp>
                <boolProp name="HTTPArgument.use_equals">true</boolProp>
              </elementProp>
            </collectionProp>
          </elementProp>
          <stringProp name="HTTPSampler.domain"></stringProp>
          <stringProp name="HTTPSampler.port"></stringProp>
          <stringProp name="HTTPSampler.connect_timeout"></stringProp>
          <stringProp name="HTTPSampler.response_timeout"></stringProp>
          <stringProp name="HTTPSampler.protocol"></stringProp>
          <stringProp name="HTTPSampler.contentEncoding"></stringProp>
          <stringProp name="HTTPSampler.path">/marvelous/federation</stringProp>
          <stringProp name="HTTPSampler.method">GET</stringProp>
          <boolProp name="HTTPSampler.follow_redirects">true</boolProp>
          <boolProp name="HTTPSampler.auto_redirects">false</boolProp>
          <boolProp name="HTTPSampler.use_keepalive">true</boolProp>
          <boolProp name="HTTPSampler.DO_MULTIPART_POST">false</boolProp>
          <boolProp name="HTTPSampler.monitor">false</boolProp>
          <stringProp name="HTTPSampler.embedded_url_re"></stringProp>
          <stringProp name="TestPlan.comments">Detected the start of a redirect chain</stringProp>
        </HTTPSamplerProxy>
        <hashTree>
          <RegexExtractor guiclass="RegexExtractorGui" testclass="RegexExtractor" testname="code" enabled="true">
            <stringProp name="RegexExtractor.useHeaders">false</stringProp>
            <stringProp name="RegexExtractor.refname">code</stringProp>
            <stringProp name="RegexExtractor.regex">code=(.*?)&lt;br&gt;</stringProp>
            <stringProp name="RegexExtractor.template">$1$</stringProp>
            <stringProp name="RegexExtractor.default"></stringProp>
            <stringProp name="RegexExtractor.match_number">1</stringProp>
          </RegexExtractor>
          <hashTree/>
        </hashTree>
        <HTTPSamplerProxy guiclass="HttpTestSampleGui" testclass="HTTPSamplerProxy" testname="Basic トークン取得(Dummy1)" enabled="true">
          <elementProp name="HTTPsampler.Arguments" elementType="Arguments" guiclass="HTTPArgumentsPanel" testclass="Arguments" enabled="true">
            <collectionProp name="Arguments.arguments">
              <elementProp name="grant_type" elementType="HTTPArgument">
                <boolProp name="HTTPArgument.always_encode">false</boolProp>
                <stringProp name="Argument.value">authorization_code</stringProp>
                <stringProp name="Argument.metadata">=</stringProp>
                <boolProp name="HTTPArgument.use_equals">true</boolProp>
                <stringProp name="Argument.name">grant_type</stringProp>
              </elementProp>
              <elementProp name="code" elementType="HTTPArgument">
                <boolProp name="HTTPArgument.always_encode">false</boolProp>
                <stringProp name="Argument.value">${code}</stringProp>
                <stringProp name="Argument.metadata">=</stringProp>
                <boolProp name="HTTPArgument.use_equals">true</boolProp>
                <stringProp name="Argument.name">code</stringProp>
              </elementProp>
              <elementProp name="redirect_uri" elementType="HTTPArgument">
                <boolProp name="HTTPArgument.always_encode">false</boolProp>
                <stringProp name="Argument.value">${protocol}%3A%2F%2F${jmeter_path}%2Ftest%2Fmisp%2Fmisp-callback</stringProp>
                <stringProp name="Argument.metadata">=</stringProp>
                <boolProp name="HTTPArgument.use_equals">true</boolProp>
                <stringProp name="Argument.name">redirect_uri</stringProp>
              </elementProp>
            </collectionProp>
          </elementProp>
          <stringProp name="HTTPSampler.domain">${misp_url}</stringProp>
          <stringProp name="HTTPSampler.port"></stringProp>
          <stringProp name="HTTPSampler.connect_timeout"></stringProp>
          <stringProp name="HTTPSampler.response_timeout"></stringProp>
          <stringProp name="HTTPSampler.protocol">${protocol}</stringProp>
          <stringProp name="HTTPSampler.contentEncoding"></stringProp>
          <stringProp name="HTTPSampler.path">/marvelous/token</stringProp>
          <stringProp name="HTTPSampler.method">POST</stringProp>
          <boolProp name="HTTPSampler.follow_redirects">true</boolProp>
          <boolProp name="HTTPSampler.auto_redirects">false</boolProp>
          <boolProp name="HTTPSampler.use_keepalive">true</boolProp>
          <boolProp name="HTTPSampler.DO_MULTIPART_POST">false</boolProp>
          <boolProp name="HTTPSampler.monitor">false</boolProp>
          <stringProp name="HTTPSampler.embedded_url_re"></stringProp>
        </HTTPSamplerProxy>
        <hashTree>
          <BSFPreProcessor guiclass="TestBeanGUI" testclass="BSFPreProcessor" testname="BSF PreProcessor" enabled="true">
            <stringProp name="filename"></stringProp>
            <stringProp name="parameters"></stringProp>
            <stringProp name="script">/*
 * A JavaScript implementation of the Secure Hash Algorithm, SHA-1, as defined
 * in FIPS PUB 180-1
 * Version 2.1a Copyright Paul Johnston 2000 - 2002.
 * Other contributors: Greg Holt, Andrew Kepert, Ydnar, Lostinet
 * Distributed under the BSD License
 * See http://pajhome.org.uk/crypt/md5 for details.
 */

/*
 * Configurable variables. You may need to tweak these to be compatible with
 * the server-side, but the defaults work in most cases.
 */
var hexcase = 0;  /* hex output format. 0 - lowercase; 1 - uppercase        */
var b64pad  = &quot;&quot;; /* base-64 pad character. &quot;=&quot; for strict RFC compliance   */
var chrsz   = 8;  /* bits per input character. 8 - ASCII; 16 - Unicode      */

/*
 * These are the functions you&apos;ll usually want to call
 * They take string arguments and return either hex or base-64 encoded strings
 */
function hex_sha1(s){return binb2hex(core_sha1(str2binb(s),s.length * chrsz));}
function b64_sha1(s){return binb2b64(core_sha1(str2binb(s),s.length * chrsz));}
function str_sha1(s){return binb2str(core_sha1(str2binb(s),s.length * chrsz));}
function hex_hmac_sha1(key, data){ return binb2hex(core_hmac_sha1(key, data));}
function b64_hmac_sha1(key, data){ return binb2b64(core_hmac_sha1(key, data));}
function str_hmac_sha1(key, data){ return binb2str(core_hmac_sha1(key, data));}

/*
 * Perform a simple self-test to see if the VM is working
 */
function sha1_vm_test()
{
  return hex_sha1(&quot;abc&quot;) == &quot;a9993e364706816aba3e25717850c26c9cd0d89d&quot;;
}

/*
 * Calculate the SHA-1 of an array of big-endian words, and a bit length
 */
function core_sha1(x, len)
{
  /* append padding */
  x[len &gt;&gt; 5] |= 0x80 &lt;&lt; (24 - len % 32);
  x[((len + 64 &gt;&gt; 9) &lt;&lt; 4) + 15] = len;

  var w = Array(80);
  var a =  1732584193;
  var b = -271733879;
  var c = -1732584194;
  var d =  271733878;
  var e = -1009589776;

  for(var i = 0; i &lt; x.length; i += 16)
  {
    var olda = a;
    var oldb = b;
    var oldc = c;
    var oldd = d;
    var olde = e;

    for(var j = 0; j &lt; 80; j++)
    {
      if(j &lt; 16) w[j] = x[i + j];
      else w[j] = rol(w[j-3] ^ w[j-8] ^ w[j-14] ^ w[j-16], 1);
      var t = safe_add(safe_add(rol(a, 5), sha1_ft(j, b, c, d)),
                       safe_add(safe_add(e, w[j]), sha1_kt(j)));
      e = d;
      d = c;
      c = rol(b, 30);
      b = a;
      a = t;
    }

    a = safe_add(a, olda);
    b = safe_add(b, oldb);
    c = safe_add(c, oldc);
    d = safe_add(d, oldd);
    e = safe_add(e, olde);
  }
  return Array(a, b, c, d, e);

}

/*
 * Perform the appropriate triplet combination function for the current
 * iteration
 */
function sha1_ft(t, b, c, d)
{
  if(t &lt; 20) return (b &amp; c) | ((~b) &amp; d);
  if(t &lt; 40) return b ^ c ^ d;
  if(t &lt; 60) return (b &amp; c) | (b &amp; d) | (c &amp; d);
  return b ^ c ^ d;
}

/*
 * Determine the appropriate additive constant for the current iteration
 */
function sha1_kt(t)
{
  return (t &lt; 20) ?  1518500249 : (t &lt; 40) ?  1859775393 :
         (t &lt; 60) ? -1894007588 : -899497514;
}

/*
 * Calculate the HMAC-SHA1 of a key and some data
 */
function core_hmac_sha1(key, data)
{
  var bkey = str2binb(key);
  if(bkey.length &gt; 16) bkey = core_sha1(bkey, key.length * chrsz);

  var ipad = Array(16), opad = Array(16);
  for(var i = 0; i &lt; 16; i++)
  {
    ipad[i] = bkey[i] ^ 0x36363636;
    opad[i] = bkey[i] ^ 0x5C5C5C5C;
  }

  var hash = core_sha1(ipad.concat(str2binb(data)), 512 + data.length * chrsz);
  return core_sha1(opad.concat(hash), 512 + 160);
}

/*
 * Add integers, wrapping at 2^32. This uses 16-bit operations internally
 * to work around bugs in some JS interpreters.
 */
function safe_add(x, y)
{
  var lsw = (x &amp; 0xFFFF) + (y &amp; 0xFFFF);
  var msw = (x &gt;&gt; 16) + (y &gt;&gt; 16) + (lsw &gt;&gt; 16);
  return (msw &lt;&lt; 16) | (lsw &amp; 0xFFFF);
}

/*
 * Bitwise rotate a 32-bit number to the left.
 */
function rol(num, cnt)
{
  return (num &lt;&lt; cnt) | (num &gt;&gt;&gt; (32 - cnt));
}

/*
 * Convert an 8-bit or 16-bit string to an array of big-endian words
 * In 8-bit function, characters &gt;255 have their hi-byte silently ignored.
 */
function str2binb(str)
{
  var bin = Array();
  var mask = (1 &lt;&lt; chrsz) - 1;
  for(var i = 0; i &lt; str.length * chrsz; i += chrsz)
    bin[i&gt;&gt;5] |= (str.charCodeAt(i / chrsz) &amp; mask) &lt;&lt; (32 - chrsz - i%32);
  return bin;
}

/*
 * Convert an array of big-endian words to a string
 */
function binb2str(bin)
{
  var str = &quot;&quot;;
  var mask = (1 &lt;&lt; chrsz) - 1;
  for(var i = 0; i &lt; bin.length * 32; i += chrsz)
    str += String.fromCharCode((bin[i&gt;&gt;5] &gt;&gt;&gt; (32 - chrsz - i%32)) &amp; mask);
  return str;
}

/*
 * Convert an array of big-endian words to a hex string.
 */
function binb2hex(binarray)
{
  var hex_tab = hexcase ? &quot;0123456789ABCDEF&quot; : &quot;0123456789abcdef&quot;;
  var str = &quot;&quot;;
  for(var i = 0; i &lt; binarray.length * 4; i++)
  {
    str += hex_tab.charAt((binarray[i&gt;&gt;2] &gt;&gt; ((3 - i%4)*8+4)) &amp; 0xF) +
           hex_tab.charAt((binarray[i&gt;&gt;2] &gt;&gt; ((3 - i%4)*8  )) &amp; 0xF);
  }
  return str;
}

/*
 * Convert an array of big-endian words to a base-64 string
 */
function binb2b64(binarray)
{
  var tab = &quot;ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/&quot;;
  var str = &quot;&quot;;
  for(var i = 0; i &lt; binarray.length * 4; i += 3)
  {
    var triplet = (((binarray[i   &gt;&gt; 2] &gt;&gt; 8 * (3 -  i   %4)) &amp; 0xFF) &lt;&lt; 16)
                | (((binarray[i+1 &gt;&gt; 2] &gt;&gt; 8 * (3 - (i+1)%4)) &amp; 0xFF) &lt;&lt; 8 )
                |  ((binarray[i+2 &gt;&gt; 2] &gt;&gt; 8 * (3 - (i+2)%4)) &amp; 0xFF);
    for(var j = 0; j &lt; 4; j++)
    {
      if(i * 8 + j * 6 &gt; binarray.length * 32) str += b64pad;
      else str += tab.charAt((triplet &gt;&gt; 6*(3-j)) &amp; 0x3F);
    }
  }
  return str;
}

/*
 * Copyright 2008 Netflix, Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/* Here&apos;s some JavaScript software for implementing OAuth.

   This isn&apos;t as useful as you might hope.  OAuth is based around
   allowing tools and websites to talk to each other.  However,
   JavaScript running in web browsers is hampered by security
   restrictions that prevent code running on one website from
   accessing data stored or served on another.

   Before you start hacking, make sure you understand the limitations
   posed by cross-domain XMLHttpRequest.

   On the bright side, some platforms use JavaScript as their
   language, but enable the programmer to access other web sites.
   Examples include Google Gadgets, and Microsoft Vista Sidebar.
   For those platforms, this library should come in handy.
*/

// The HMAC-SHA1 signature method calls b64_hmac_sha1, defined by
// http://pajhome.org.uk/crypt/md5/sha1.js

/* An OAuth message is represented as an object like this:
   {method: &quot;GET&quot;, action: &quot;http://server.com/path&quot;, parameters: ...}

   The parameters may be either a map {name: value, name2: value2}
   or an Array of name-value pairs [[name, value], [name2, value2]].
   The latter representation is more powerful: it supports parameters
   in a specific sequence, or several parameters with the same name;
   for example [[&quot;a&quot;, 1], [&quot;b&quot;, 2], [&quot;a&quot;, 3]].

   Parameter names and values are NOT percent-encoded in an object.
   They must be encoded before transmission and decoded after reception.
   For example, this message object:
   {method: &quot;GET&quot;, action: &quot;http://server/path&quot;, parameters: {p: &quot;x y&quot;}}
   ... can be transmitted as an HTTP request that begins:
   GET /path?p=x%20y HTTP/1.0
   (This isn&apos;t a valid OAuth request, since it lacks a signature etc.)
   Note that the object &quot;x y&quot; is transmitted as x%20y.  To encode
   parameters, you can call OAuth.addToURL, OAuth.formEncode or
   OAuth.getAuthorization.

   This message object model harmonizes with the browser object model for
   input elements of an form, whose value property isn&apos;t percent encoded.
   The browser encodes each value before transmitting it. For example,
   see consumer.setInputs in example/consumer.js.
 */

/* This script needs to know what time it is. By default, it uses the local
   clock (new Date), which is apt to be inaccurate in browsers. To do
   better, you can load this script from a URL whose query string contains
   an oauth_timestamp parameter, whose value is a current Unix timestamp.
   For example, when generating the enclosing document using PHP:

   &lt;script src=&quot;oauth.js?oauth_timestamp=&lt;?=time()?&gt;&quot; ...

   Another option is to call OAuth.correctTimestamp with a Unix timestamp.
 */

var OAuth; if (OAuth == null) OAuth = {};

OAuth.setProperties = function setProperties(into, from) {
    if (into != null &amp;&amp; from != null) {
        for (var key in from) {
            into[key] = from[key];
        }
    }
    return into;
}

OAuth.setProperties(OAuth, // utility functions
{
    percentEncode: function percentEncode(s) {
        if (s == null) {
            return &quot;&quot;;
        }
        if (s instanceof Array) {
            var e = &quot;&quot;;
            for (var i = 0; i &lt; s.length; ++s) {
                if (e != &quot;&quot;) e += &apos;&amp;&apos;;
                e += OAuth.percentEncode(s[i]);
            }
            return e;
        }
        s = encodeURIComponent(s);
        // Now replace the values which encodeURIComponent doesn&apos;t do
        // encodeURIComponent ignores: - _ . ! ~ * &apos; ( )
        // OAuth dictates the only ones you can ignore are: - _ . ~
        // Source: http://developer.mozilla.org/en/docs/Core_JavaScript_1.5_Reference:Global_Functions:encodeURIComponent
        s = s.replace(/\!/g, &quot;%21&quot;);
        s = s.replace(/\*/g, &quot;%2A&quot;);
        s = s.replace(/\&apos;/g, &quot;%27&quot;);
        s = s.replace(/\(/g, &quot;%28&quot;);
        s = s.replace(/\)/g, &quot;%29&quot;);
        return s;
    }
,
    decodePercent: function decodePercent(s) {
        if (s != null) {
            // Handle application/x-www-form-urlencoded, which is defined by
            // http://www.w3.org/TR/html4/interact/forms.html#h-17.13.4.1
            s = s.replace(/\+/g, &quot; &quot;);
        }
        return decodeURIComponent(s);
    }
,
    /** Convert the given parameters to an Array of name-value pairs. */
    getParameterList: function getParameterList(parameters) {
        if (parameters == null) {
            return [];
        }
        if (typeof parameters != &quot;object&quot;) {
            return OAuth.decodeForm(parameters + &quot;&quot;);
        }
        if (parameters instanceof Array) {
            return parameters;
        }
        var list = [];
        for (var p in parameters) {
            list.push([p, parameters[p]]);
        }
        return list;
    }
,
    /** Convert the given parameters to a map from name to value. */
    getParameterMap: function getParameterMap(parameters) {
        if (parameters == null) {
            return {};
        }
        if (typeof parameters != &quot;object&quot;) {
            return OAuth.getParameterMap(OAuth.decodeForm(parameters + &quot;&quot;));
        }
        if (parameters instanceof Array) {
            var map = {};
            for (var p = 0; p &lt; parameters.length; ++p) {
                var key = parameters[p][0];
                if (map[key] === undefined) { // first value wins
                    map[key] = parameters[p][1];
                }
            }
            return map;
        }
        return parameters;
    }
,
    getParameter: function getParameter(parameters, name) {
        if (parameters instanceof Array) {
            for (var p = 0; p &lt; parameters.length; ++p) {
                if (parameters[p][0] == name) {
                    return parameters[p][1]; // first value wins
                }
            }
        } else {
            return OAuth.getParameterMap(parameters)[name];
        }
        return null;
    }
,
    formEncode: function formEncode(parameters) {
        var form = &quot;&quot;;
        var list = OAuth.getParameterList(parameters);
        for (var p = 0; p &lt; list.length; ++p) {
            var value = list[p][1];
            if (value == null) value = &quot;&quot;;
            if (form != &quot;&quot;) form += &apos;&amp;&apos;;
            form += OAuth.percentEncode(list[p][0])
              +&apos;=&apos;+ OAuth.percentEncode(value);
        }
        return form;
    }
,
    decodeForm: function decodeForm(form) {
        var list = [];
        var nvps = form.split(&apos;&amp;&apos;);
        for (var n = 0; n &lt; nvps.length; ++n) {
            var nvp = nvps[n];
            if (nvp == &quot;&quot;) {
                continue;
            }
            var equals = nvp.indexOf(&apos;=&apos;);
            var name;
            var value;
            if (equals &lt; 0) {
                name = OAuth.decodePercent(nvp);
                value = null;
            } else {
                name = OAuth.decodePercent(nvp.substring(0, equals));
                value = OAuth.decodePercent(nvp.substring(equals + 1));
            }
            list.push([name, value]);
        }
        return list;
    }
,
    setParameter: function setParameter(message, name, value) {
        var parameters = message.parameters;
        if (parameters instanceof Array) {
            for (var p = 0; p &lt; parameters.length; ++p) {
                if (parameters[p][0] == name) {
                    if (value === undefined) {
                        parameters.splice(p, 1);
                    } else {
                        parameters[p][1] = value;
                        value = undefined;
                    }
                }
            }
            if (value !== undefined) {
                parameters.push([name, value]);
            }
        } else {
            parameters = OAuth.getParameterMap(parameters);
            parameters[name] = value;
            message.parameters = parameters;
        }
    }
,
    setParameters: function setParameters(message, parameters) {
        var list = OAuth.getParameterList(parameters);
        for (var i = 0; i &lt; list.length; ++i) {
            OAuth.setParameter(message, list[i][0], list[i][1]);
        }
    }
,
    /** Fill in parameters to help construct a request message.
        This function doesn&apos;t fill in every parameter.
        The accessor object should be like:
        {consumerKey:&apos;foo&apos;, consumerSecret:&apos;bar&apos;, accessorSecret:&apos;nurn&apos;, token:&apos;krelm&apos;, tokenSecret:&apos;blah&apos;}
        The accessorSecret property is optional.
     */
    completeRequest: function completeRequest(message, accessor) {
        if (message.method == null) {
            message.method = &quot;GET&quot;;
        }
        var map = OAuth.getParameterMap(message.parameters);
        if (map.oauth_consumer_key == null) {
            OAuth.setParameter(message, &quot;oauth_consumer_key&quot;, accessor.consumerKey || &quot;&quot;);
        }
        if (map.oauth_token == null &amp;&amp; accessor.token != null) {
            OAuth.setParameter(message, &quot;oauth_token&quot;, accessor.token);
        }
        if (map.oauth_version == null) {
            OAuth.setParameter(message, &quot;oauth_version&quot;, &quot;1.0&quot;);
        }
        if (map.oauth_timestamp == null) {
            OAuth.setParameter(message, &quot;oauth_timestamp&quot;, OAuth.timestamp());
        }
        if (map.oauth_nonce == null) {
            OAuth.setParameter(message, &quot;oauth_nonce&quot;, OAuth.nonce(6));
        }
        OAuth.SignatureMethod.sign(message, accessor);
    }
,
    setTimestampAndNonce: function setTimestampAndNonce(message) {
        OAuth.setParameter(message, &quot;oauth_timestamp&quot;, OAuth.timestamp());
        OAuth.setParameter(message, &quot;oauth_nonce&quot;, OAuth.nonce(6));
    }
,
    addToURL: function addToURL(url, parameters) {
        newURL = url;
        if (parameters != null) {
            var toAdd = OAuth.formEncode(parameters);
            if (toAdd.length &gt; 0) {
                var q = url.indexOf(&apos;?&apos;);
                if (q &lt; 0) newURL += &apos;?&apos;;
                else       newURL += &apos;&amp;&apos;;
                newURL += toAdd;
            }
        }
        return newURL;
    }
,
    /** Construct the value of the Authorization header for an HTTP request. */
    getAuthorizationHeader: function getAuthorizationHeader(realm, parameters) {
        var header = &apos;OAuth realm=&quot;&apos; + OAuth.percentEncode(realm) + &apos;&quot;&apos;;
        var list = OAuth.getParameterList(parameters);
        for (var p = 0; p &lt; list.length; ++p) {
            var parameter = list[p];
            var name = parameter[0];
            if (name.indexOf(&quot;oauth_&quot;) == 0) {
                header += &apos;,&apos; + OAuth.percentEncode(name) + &apos;=&quot;&apos; + OAuth.percentEncode(parameter[1]) + &apos;&quot;&apos;;
            }
        }
        return header;
    }
,
    /** Correct the time using a parameter from the URL from which the last script was loaded. */
    correctTimestampFromSrc: function correctTimestampFromSrc(parameterName) {
        parameterName = parameterName || &quot;oauth_timestamp&quot;;
        var scripts = document.getElementsByTagName(&apos;script&apos;);
        if (scripts == null || !scripts.length) return;
        var src = scripts[scripts.length-1].src;
        if (!src) return;
        var q = src.indexOf(&quot;?&quot;);
        if (q &lt; 0) return;
        parameters = OAuth.getParameterMap(OAuth.decodeForm(src.substring(q+1)));
        var t = parameters[parameterName];
        if (t == null) return;
        OAuth.correctTimestamp(t);
    }
,
    /** Generate timestamps starting with the given value. */
    correctTimestamp: function correctTimestamp(timestamp) {
        OAuth.timeCorrectionMsec = (timestamp * 1000) - (new Date()).getTime();
    }
,
    /** The difference between the correct time and my clock. */
    timeCorrectionMsec: 0
,
    timestamp: function timestamp() {
        var t = (new Date()).getTime() + OAuth.timeCorrectionMsec;
        return Math.floor(t / 1000);
    }
,
    nonce: function nonce(length) {
        var chars = OAuth.nonce.CHARS;
        var result = &quot;&quot;;
        for (var i = 0; i &lt; length; ++i) {
            var rnum = Math.floor(Math.random() * chars.length);
            result += chars.substring(rnum, rnum+1);
        }
        return result;
    }
});

OAuth.nonce.CHARS = &quot;0123456789ABCDEFGHIJKLMNOPQRSTUVWXTZabcdefghiklmnopqrstuvwxyz&quot;;

/** Define a constructor function,
    without causing trouble to anyone who was using it as a namespace.
    That is, if parent[name] already existed and had properties,
    copy those properties into the new constructor.
 */
OAuth.declareClass = function declareClass(parent, name, newConstructor) {
    var previous = parent[name];
    parent[name] = newConstructor;
    if (newConstructor != null &amp;&amp; previous != null) {
        for (var key in previous) {
            if (key != &quot;prototype&quot;) {
                newConstructor[key] = previous[key];
            }
        }
    }
    return newConstructor;
}

/** An abstract algorithm for signing messages. */
OAuth.declareClass(OAuth, &quot;SignatureMethod&quot;, function OAuthSignatureMethod(){});

OAuth.setProperties(OAuth.SignatureMethod.prototype, // instance members
{
    /** Add a signature to the message. */
    sign: function sign(message) {
        var baseString = OAuth.SignatureMethod.getBaseString(message);
        var signature = this.getSignature(baseString);
        OAuth.setParameter(message, &quot;oauth_signature&quot;, signature);
        return signature; // just in case someone&apos;s interested
    }
,
    /** Set the key string for signing. */
    initialize: function initialize(name, accessor) {
        var consumerSecret;
        if (accessor.accessorSecret != null
            &amp;&amp; name.length &gt; 9
            &amp;&amp; name.substring(name.length-9) == &quot;-Accessor&quot;)
        {
            consumerSecret = accessor.accessorSecret;
        } else {
            consumerSecret = accessor.consumerSecret;
        }
        this.key = OAuth.percentEncode(consumerSecret)
             +&quot;&amp;&quot;+ OAuth.percentEncode(accessor.tokenSecret);
    }
});

/* SignatureMethod expects an accessor object to be like this:
   {tokenSecret: &quot;lakjsdflkj...&quot;, consumerSecret: &quot;QOUEWRI..&quot;, accessorSecret: &quot;xcmvzc...&quot;}
   The accessorSecret property is optional.
 */
// Class members:
OAuth.setProperties(OAuth.SignatureMethod, // class members
{
    sign: function sign(message, accessor) {
        var name = OAuth.getParameterMap(message.parameters).oauth_signature_method;
        if (name == null || name == &quot;&quot;) {
            name = &quot;HMAC-SHA1&quot;;
            OAuth.setParameter(message, &quot;oauth_signature_method&quot;, name);
        }
        OAuth.SignatureMethod.newMethod(name, accessor).sign(message);
    }
,
    /** Instantiate a SignatureMethod for the given method name. */
    newMethod: function newMethod(name, accessor) {
        var impl = OAuth.SignatureMethod.REGISTERED[name];
        if (impl != null) {
            var method = new impl();
            method.initialize(name, accessor);
            return method;
        }
        var err = new Error(&quot;signature_method_rejected&quot;);
        var acceptable = &quot;&quot;;
        for (var r in OAuth.SignatureMethod.REGISTERED) {
            if (acceptable != &quot;&quot;) acceptable += &apos;&amp;&apos;;
            acceptable += OAuth.percentEncode(r);
        }
        err.oauth_acceptable_signature_methods = acceptable;
        throw err;
    }
,
    /** A map from signature method name to constructor. */
    REGISTERED : {}
,
    /** Subsequently, the given constructor will be used for the named methods.
        The constructor will be called with no parameters.
        The resulting object should usually implement getSignature(baseString).
        You can easily define such a constructor by calling makeSubclass, below.
     */
    registerMethodClass: function registerMethodClass(names, classConstructor) {
        for (var n = 0; n &lt; names.length; ++n) {
            OAuth.SignatureMethod.REGISTERED[names[n]] = classConstructor;
        }
    }
,
    /** Create a subclass of OAuth.SignatureMethod, with the given getSignature function. */
    makeSubclass: function makeSubclass(getSignatureFunction) {
        var superClass = OAuth.SignatureMethod;
        var subClass = function() {
            superClass.call(this);
        };
        subClass.prototype = new superClass();
        // Delete instance variables from prototype:
        // delete subclass.prototype... There aren&apos;t any.
        subClass.prototype.getSignature = getSignatureFunction;
        subClass.prototype.constructor = subClass;
        return subClass;
    }
,
    getBaseString: function getBaseString(message) {
        var URL = message.action;
        var q = URL.indexOf(&apos;?&apos;);
        var parameters;
        if (q &lt; 0) {
            parameters = message.parameters;
        } else {
            // Combine the URL query string with the other parameters:
            parameters = OAuth.decodeForm(URL.substring(q + 1));
            var toAdd = OAuth.getParameterList(message.parameters);
            for (var a = 0; a &lt; toAdd.length; ++a) {
                parameters.push(toAdd[a]);
            }
        }
        return OAuth.percentEncode(message.method.toUpperCase())
         +&apos;&amp;&apos;+ OAuth.percentEncode(OAuth.SignatureMethod.normalizeUrl(URL))
         +&apos;&amp;&apos;+ OAuth.percentEncode(OAuth.SignatureMethod.normalizeParameters(parameters));
    }
,
    normalizeUrl: function normalizeUrl(url) {
        var uri = OAuth.SignatureMethod.parseUri(url);
        var scheme = uri.protocol.toLowerCase();
        var authority = uri.authority.toLowerCase();
        var dropPort = (scheme == &quot;http&quot; &amp;&amp; uri.port == 80)
                    || (scheme == &quot;https&quot; &amp;&amp; uri.port == 443);
        if (dropPort) {
            // find the last : in the authority
            var index = authority.lastIndexOf(&quot;:&quot;);
            if (index &gt;= 0) {
                authority = authority.substring(0, index);
            }
        }
        var path = uri.path;
        if (!path) {
            path = &quot;/&quot;; // conforms to RFC 2616 section 3.2.2
        }
        // we know that there is no query and no fragment here.
        return scheme + &quot;://&quot; + authority + path;
    }
,
    parseUri: function parseUri (str) {
        /* This function was adapted from parseUri 1.2.1
           http://stevenlevithan.com/demo/parseuri/js/assets/parseuri.js
         */
        var o = {key: [&quot;source&quot;,&quot;protocol&quot;,&quot;authority&quot;,&quot;userInfo&quot;,&quot;user&quot;,&quot;password&quot;,&quot;host&quot;,&quot;port&quot;,&quot;relative&quot;,&quot;path&quot;,&quot;directory&quot;,&quot;file&quot;,&quot;query&quot;,&quot;anchor&quot;],
                 parser: {strict: /^(?:([^:\/?#]+):)?(?:\/\/((?:(([^:@\/]*):?([^:@\/]*))?@)?([^:\/?#]*)(?::(\d*))?))?((((?:[^?#\/]*\/)*)([^?#]*))(?:\?([^#]*))?(?:#(.*))?)/ }};
        var m = o.parser.strict.exec(str);
        var uri = {};
        var i = 14;
        while (i--) uri[o.key[i]] = m[i] || &quot;&quot;;
        return uri;
    }
,
    normalizeParameters: function normalizeParameters(parameters) {
        if (parameters == null) {
            return &quot;&quot;;
        }
        var list = OAuth.getParameterList(parameters);
        var sortable = [];
        for (var p = 0; p &lt; list.length; ++p) {
            var nvp = list[p];
            if (nvp[0] != &quot;oauth_signature&quot;) {
                sortable.push([ OAuth.percentEncode(nvp[0])
                              + &quot; &quot; // because it comes before any character that can appear in a percentEncoded string.
                              + OAuth.percentEncode(nvp[1])
                              , nvp]);
            }
        }
        sortable.sort(function(a,b) {
                          if (a[0] &lt; b[0]) return  -1;
                          if (a[0] &gt; b[0]) return 1;
                          return 0;
                      });
        var sorted = [];
        for (var s = 0; s &lt; sortable.length; ++s) {
            sorted.push(sortable[s][1]);
        }
        return OAuth.formEncode(sorted);
    }
});

OAuth.SignatureMethod.registerMethodClass([&quot;PLAINTEXT&quot;, &quot;PLAINTEXT-Accessor&quot;],
    OAuth.SignatureMethod.makeSubclass(
        function getSignature(baseString) {
            return this.key;
        }
    ));

OAuth.SignatureMethod.registerMethodClass([&quot;HMAC-SHA1&quot;, &quot;HMAC-SHA1-Accessor&quot;],
    OAuth.SignatureMethod.makeSubclass(
        function getSignature(baseString) {
            b64pad = &apos;=&apos;;
            var signature = b64_hmac_sha1(this.key, baseString);
            return signature;
        }
    ));

try {
    OAuth.correctTimestampFromSrc();
} catch(e) {
}


//--------------------------------------------------

var consumerKey = &quot;${consumer_key}&quot;;
var consumerSecret = &quot;${consumer_secret}&quot;;
var params = [];
var query = [];
query.push(&apos;grant_type&apos; + &apos;=&apos; + &apos;authorization_code&apos;);
query.push(&apos;code&apos; + &apos;=&apos; + &apos;${code}&apos;);
query.push(&apos;redirect_uri&apos; + &apos;=&apos; + &apos;${protocol}%3A%2F%2F${jmeter_path}%2Ftest%2Fmisp%2Fmisp-callback&apos;);
var url =  &quot;${protocol}://${misp_url}/marvelous/token&quot;;

if (query.length) {
    url += &apos;?&apos; + query.join(&apos;&amp;&apos;);
}

var message = {
    method: &apos;post&apos;,
    parameters: params, 
    action: url
};
       
var accessor = {
    consumerKey: consumerKey,
    consumerSecret: consumerSecret,
    token: null,
    tokenSecret: null
};

OAuth.completeRequest(message, accessor);
vars.put(&apos;token_auth_header&apos;, OAuth.getAuthorizationHeader(&apos;&apos;, params).replace(&apos;OAuth realm=&quot;&quot;,&apos;, &apos; OAuth &apos;));
</stringProp>
            <stringProp name="scriptLanguage">javascript</stringProp>
          </BSFPreProcessor>
          <hashTree/>
          <HeaderManager guiclass="HeaderPanel" testclass="HeaderManager" testname="HTTP ヘッダマネージャ" enabled="true">
            <collectionProp name="HeaderManager.headers">
              <elementProp name="" elementType="Header">
                <stringProp name="Header.name">Authorization</stringProp>
                <stringProp name="Header.value">${token_auth_header}</stringProp>
              </elementProp>
              <elementProp name="" elementType="Header">
                <stringProp name="Header.name">content-type</stringProp>
                <stringProp name="Header.value">application/x-www-form-urlencoded</stringProp>
              </elementProp>
            </collectionProp>
          </HeaderManager>
          <hashTree/>
          <RegexExtractor guiclass="RegexExtractorGui" testclass="RegexExtractor" testname="access_token_before" enabled="true">
            <stringProp name="RegexExtractor.useHeaders">false</stringProp>
            <stringProp name="RegexExtractor.refname">access_token_before</stringProp>
            <stringProp name="RegexExtractor.regex">&quot;access_token&quot;:&quot;(.*?)&quot;,</stringProp>
            <stringProp name="RegexExtractor.template">$1$</stringProp>
            <stringProp name="RegexExtractor.default"></stringProp>
            <stringProp name="RegexExtractor.match_number">1</stringProp>
          </RegexExtractor>
          <hashTree/>
          <RegexExtractor guiclass="RegexExtractorGui" testclass="RegexExtractor" testname="id_token_before" enabled="true">
            <stringProp name="RegexExtractor.useHeaders">false</stringProp>
            <stringProp name="RegexExtractor.refname">id_token_before</stringProp>
            <stringProp name="RegexExtractor.regex">&quot;id_token&quot;:&quot;(.*?)&quot;</stringProp>
            <stringProp name="RegexExtractor.template">$1$</stringProp>
            <stringProp name="RegexExtractor.default"></stringProp>
            <stringProp name="RegexExtractor.match_number">1</stringProp>
          </RegexExtractor>
          <hashTree/>
        </hashTree>
        <HTTPSamplerProxy guiclass="HttpTestSampleGui" testclass="HTTPSamplerProxy" testname="Basic.ユーザ更新(ID連携)(Dummy1)" enabled="true">
          <boolProp name="HTTPSampler.postBodyRaw">true</boolProp>
          <elementProp name="HTTPsampler.Arguments" elementType="Arguments">
            <collectionProp name="Arguments.arguments">
              <elementProp name="" elementType="HTTPArgument">
                <boolProp name="HTTPArgument.always_encode">false</boolProp>
                <stringProp name="Argument.value">{&#xd;
  &quot;entry&quot;: [&#xd;
    {&#xd;
      &quot;apps&quot;: [&#xd;
        {&#xd;
          &quot;value&quot;: {&#xd;
            &quot;appId&quot;: &quot;00000&quot;,&#xd;
            &quot;userId&quot;: &quot;basic_3&quot;,&#xd;
            &quot;username&quot;: &quot;basic_the_sun&quot;&#xd;
          }&#xd;
        }&#xd;
      ]&#xd;
    }&#xd;
  ]&#xd;
}</stringProp>
                <stringProp name="Argument.metadata">=</stringProp>
              </elementProp>
            </collectionProp>
          </elementProp>
          <stringProp name="HTTPSampler.domain"></stringProp>
          <stringProp name="HTTPSampler.port"></stringProp>
          <stringProp name="HTTPSampler.connect_timeout"></stringProp>
          <stringProp name="HTTPSampler.response_timeout"></stringProp>
          <stringProp name="HTTPSampler.protocol"></stringProp>
          <stringProp name="HTTPSampler.contentEncoding"></stringProp>
          <stringProp name="HTTPSampler.path">/marvelous/people/@me/@self?access_token=${access_token_before}&amp;id_token=${id_token_before}</stringProp>
          <stringProp name="HTTPSampler.method">PUT</stringProp>
          <boolProp name="HTTPSampler.follow_redirects">true</boolProp>
          <boolProp name="HTTPSampler.auto_redirects">false</boolProp>
          <boolProp name="HTTPSampler.use_keepalive">true</boolProp>
          <boolProp name="HTTPSampler.DO_MULTIPART_POST">false</boolProp>
          <boolProp name="HTTPSampler.monitor">false</boolProp>
          <stringProp name="HTTPSampler.embedded_url_re"></stringProp>
        </HTTPSamplerProxy>
        <hashTree>
          <BSFPreProcessor guiclass="TestBeanGUI" testclass="BSFPreProcessor" testname="BSF PreProcessor" enabled="true">
            <stringProp name="filename"></stringProp>
            <stringProp name="parameters"></stringProp>
            <stringProp name="script">/*
 * A JavaScript implementation of the Secure Hash Algorithm, SHA-1, as defined
 * in FIPS PUB 180-1
 * Version 2.1a Copyright Paul Johnston 2000 - 2002.
 * Other contributors: Greg Holt, Andrew Kepert, Ydnar, Lostinet
 * Distributed under the BSD License
 * See http://pajhome.org.uk/crypt/md5 for details.
 */

/*
 * Configurable variables. You may need to tweak these to be compatible with
 * the server-side, but the defaults work in most cases.
 */
var hexcase = 0;  /* hex output format. 0 - lowercase; 1 - uppercase        */
var b64pad  = &quot;&quot;; /* base-64 pad character. &quot;=&quot; for strict RFC compliance   */
var chrsz   = 8;  /* bits per input character. 8 - ASCII; 16 - Unicode      */

/*
 * These are the functions you&apos;ll usually want to call
 * They take string arguments and return either hex or base-64 encoded strings
 */
function hex_sha1(s){return binb2hex(core_sha1(str2binb(s),s.length * chrsz));}
function b64_sha1(s){return binb2b64(core_sha1(str2binb(s),s.length * chrsz));}
function str_sha1(s){return binb2str(core_sha1(str2binb(s),s.length * chrsz));}
function hex_hmac_sha1(key, data){ return binb2hex(core_hmac_sha1(key, data));}
function b64_hmac_sha1(key, data){ return binb2b64(core_hmac_sha1(key, data));}
function str_hmac_sha1(key, data){ return binb2str(core_hmac_sha1(key, data));}

/*
 * Perform a simple self-test to see if the VM is working
 */
function sha1_vm_test()
{
  return hex_sha1(&quot;abc&quot;) == &quot;a9993e364706816aba3e25717850c26c9cd0d89d&quot;;
}

/*
 * Calculate the SHA-1 of an array of big-endian words, and a bit length
 */
function core_sha1(x, len)
{
  /* append padding */
  x[len &gt;&gt; 5] |= 0x80 &lt;&lt; (24 - len % 32);
  x[((len + 64 &gt;&gt; 9) &lt;&lt; 4) + 15] = len;

  var w = Array(80);
  var a =  1732584193;
  var b = -271733879;
  var c = -1732584194;
  var d =  271733878;
  var e = -1009589776;

  for(var i = 0; i &lt; x.length; i += 16)
  {
    var olda = a;
    var oldb = b;
    var oldc = c;
    var oldd = d;
    var olde = e;

    for(var j = 0; j &lt; 80; j++)
    {
      if(j &lt; 16) w[j] = x[i + j];
      else w[j] = rol(w[j-3] ^ w[j-8] ^ w[j-14] ^ w[j-16], 1);
      var t = safe_add(safe_add(rol(a, 5), sha1_ft(j, b, c, d)),
                       safe_add(safe_add(e, w[j]), sha1_kt(j)));
      e = d;
      d = c;
      c = rol(b, 30);
      b = a;
      a = t;
    }

    a = safe_add(a, olda);
    b = safe_add(b, oldb);
    c = safe_add(c, oldc);
    d = safe_add(d, oldd);
    e = safe_add(e, olde);
  }
  return Array(a, b, c, d, e);

}

/*
 * Perform the appropriate triplet combination function for the current
 * iteration
 */
function sha1_ft(t, b, c, d)
{
  if(t &lt; 20) return (b &amp; c) | ((~b) &amp; d);
  if(t &lt; 40) return b ^ c ^ d;
  if(t &lt; 60) return (b &amp; c) | (b &amp; d) | (c &amp; d);
  return b ^ c ^ d;
}

/*
 * Determine the appropriate additive constant for the current iteration
 */
function sha1_kt(t)
{
  return (t &lt; 20) ?  1518500249 : (t &lt; 40) ?  1859775393 :
         (t &lt; 60) ? -1894007588 : -899497514;
}

/*
 * Calculate the HMAC-SHA1 of a key and some data
 */
function core_hmac_sha1(key, data)
{
  var bkey = str2binb(key);
  if(bkey.length &gt; 16) bkey = core_sha1(bkey, key.length * chrsz);

  var ipad = Array(16), opad = Array(16);
  for(var i = 0; i &lt; 16; i++)
  {
    ipad[i] = bkey[i] ^ 0x36363636;
    opad[i] = bkey[i] ^ 0x5C5C5C5C;
  }

  var hash = core_sha1(ipad.concat(str2binb(data)), 512 + data.length * chrsz);
  return core_sha1(opad.concat(hash), 512 + 160);
}

/*
 * Add integers, wrapping at 2^32. This uses 16-bit operations internally
 * to work around bugs in some JS interpreters.
 */
function safe_add(x, y)
{
  var lsw = (x &amp; 0xFFFF) + (y &amp; 0xFFFF);
  var msw = (x &gt;&gt; 16) + (y &gt;&gt; 16) + (lsw &gt;&gt; 16);
  return (msw &lt;&lt; 16) | (lsw &amp; 0xFFFF);
}

/*
 * Bitwise rotate a 32-bit number to the left.
 */
function rol(num, cnt)
{
  return (num &lt;&lt; cnt) | (num &gt;&gt;&gt; (32 - cnt));
}

/*
 * Convert an 8-bit or 16-bit string to an array of big-endian words
 * In 8-bit function, characters &gt;255 have their hi-byte silently ignored.
 */
function str2binb(str)
{
  var bin = Array();
  var mask = (1 &lt;&lt; chrsz) - 1;
  for(var i = 0; i &lt; str.length * chrsz; i += chrsz)
    bin[i&gt;&gt;5] |= (str.charCodeAt(i / chrsz) &amp; mask) &lt;&lt; (32 - chrsz - i%32);
  return bin;
}

/*
 * Convert an array of big-endian words to a string
 */
function binb2str(bin)
{
  var str = &quot;&quot;;
  var mask = (1 &lt;&lt; chrsz) - 1;
  for(var i = 0; i &lt; bin.length * 32; i += chrsz)
    str += String.fromCharCode((bin[i&gt;&gt;5] &gt;&gt;&gt; (32 - chrsz - i%32)) &amp; mask);
  return str;
}

/*
 * Convert an array of big-endian words to a hex string.
 */
function binb2hex(binarray)
{
  var hex_tab = hexcase ? &quot;0123456789ABCDEF&quot; : &quot;0123456789abcdef&quot;;
  var str = &quot;&quot;;
  for(var i = 0; i &lt; binarray.length * 4; i++)
  {
    str += hex_tab.charAt((binarray[i&gt;&gt;2] &gt;&gt; ((3 - i%4)*8+4)) &amp; 0xF) +
           hex_tab.charAt((binarray[i&gt;&gt;2] &gt;&gt; ((3 - i%4)*8  )) &amp; 0xF);
  }
  return str;
}

/*
 * Convert an array of big-endian words to a base-64 string
 */
function binb2b64(binarray)
{
  var tab = &quot;ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/&quot;;
  var str = &quot;&quot;;
  for(var i = 0; i &lt; binarray.length * 4; i += 3)
  {
    var triplet = (((binarray[i   &gt;&gt; 2] &gt;&gt; 8 * (3 -  i   %4)) &amp; 0xFF) &lt;&lt; 16)
                | (((binarray[i+1 &gt;&gt; 2] &gt;&gt; 8 * (3 - (i+1)%4)) &amp; 0xFF) &lt;&lt; 8 )
                |  ((binarray[i+2 &gt;&gt; 2] &gt;&gt; 8 * (3 - (i+2)%4)) &amp; 0xFF);
    for(var j = 0; j &lt; 4; j++)
    {
      if(i * 8 + j * 6 &gt; binarray.length * 32) str += b64pad;
      else str += tab.charAt((triplet &gt;&gt; 6*(3-j)) &amp; 0x3F);
    }
  }
  return str;
}

/*
 * Copyright 2008 Netflix, Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/* Here&apos;s some JavaScript software for implementing OAuth.

   This isn&apos;t as useful as you might hope.  OAuth is based around
   allowing tools and websites to talk to each other.  However,
   JavaScript running in web browsers is hampered by security
   restrictions that prevent code running on one website from
   accessing data stored or served on another.

   Before you start hacking, make sure you understand the limitations
   posed by cross-domain XMLHttpRequest.

   On the bright side, some platforms use JavaScript as their
   language, but enable the programmer to access other web sites.
   Examples include Google Gadgets, and Microsoft Vista Sidebar.
   For those platforms, this library should come in handy.
*/

// The HMAC-SHA1 signature method calls b64_hmac_sha1, defined by
// http://pajhome.org.uk/crypt/md5/sha1.js

/* An OAuth message is represented as an object like this:
   {method: &quot;GET&quot;, action: &quot;http://server.com/path&quot;, parameters: ...}

   The parameters may be either a map {name: value, name2: value2}
   or an Array of name-value pairs [[name, value], [name2, value2]].
   The latter representation is more powerful: it supports parameters
   in a specific sequence, or several parameters with the same name;
   for example [[&quot;a&quot;, 1], [&quot;b&quot;, 2], [&quot;a&quot;, 3]].

   Parameter names and values are NOT percent-encoded in an object.
   They must be encoded before transmission and decoded after reception.
   For example, this message object:
   {method: &quot;GET&quot;, action: &quot;http://server/path&quot;, parameters: {p: &quot;x y&quot;}}
   ... can be transmitted as an HTTP request that begins:
   GET /path?p=x%20y HTTP/1.0
   (This isn&apos;t a valid OAuth request, since it lacks a signature etc.)
   Note that the object &quot;x y&quot; is transmitted as x%20y.  To encode
   parameters, you can call OAuth.addToURL, OAuth.formEncode or
   OAuth.getAuthorization.

   This message object model harmonizes with the browser object model for
   input elements of an form, whose value property isn&apos;t percent encoded.
   The browser encodes each value before transmitting it. For example,
   see consumer.setInputs in example/consumer.js.
 */

/* This script needs to know what time it is. By default, it uses the local
   clock (new Date), which is apt to be inaccurate in browsers. To do
   better, you can load this script from a URL whose query string contains
   an oauth_timestamp parameter, whose value is a current Unix timestamp.
   For example, when generating the enclosing document using PHP:

   &lt;script src=&quot;oauth.js?oauth_timestamp=&lt;?=time()?&gt;&quot; ...

   Another option is to call OAuth.correctTimestamp with a Unix timestamp.
 */

var OAuth; if (OAuth == null) OAuth = {};

OAuth.setProperties = function setProperties(into, from) {
    if (into != null &amp;&amp; from != null) {
        for (var key in from) {
            into[key] = from[key];
        }
    }
    return into;
}

OAuth.setProperties(OAuth, // utility functions
{
    percentEncode: function percentEncode(s) {
        if (s == null) {
            return &quot;&quot;;
        }
        if (s instanceof Array) {
            var e = &quot;&quot;;
            for (var i = 0; i &lt; s.length; ++s) {
                if (e != &quot;&quot;) e += &apos;&amp;&apos;;
                e += OAuth.percentEncode(s[i]);
            }
            return e;
        }
        s = encodeURIComponent(s);
        // Now replace the values which encodeURIComponent doesn&apos;t do
        // encodeURIComponent ignores: - _ . ! ~ * &apos; ( )
        // OAuth dictates the only ones you can ignore are: - _ . ~
        // Source: http://developer.mozilla.org/en/docs/Core_JavaScript_1.5_Reference:Global_Functions:encodeURIComponent
        s = s.replace(/\!/g, &quot;%21&quot;);
        s = s.replace(/\*/g, &quot;%2A&quot;);
        s = s.replace(/\&apos;/g, &quot;%27&quot;);
        s = s.replace(/\(/g, &quot;%28&quot;);
        s = s.replace(/\)/g, &quot;%29&quot;);
        return s;
    }
,
    decodePercent: function decodePercent(s) {
        if (s != null) {
            // Handle application/x-www-form-urlencoded, which is defined by
            // http://www.w3.org/TR/html4/interact/forms.html#h-17.13.4.1
            s = s.replace(/\+/g, &quot; &quot;);
        }
        return decodeURIComponent(s);
    }
,
    /** Convert the given parameters to an Array of name-value pairs. */
    getParameterList: function getParameterList(parameters) {
        if (parameters == null) {
            return [];
        }
        if (typeof parameters != &quot;object&quot;) {
            return OAuth.decodeForm(parameters + &quot;&quot;);
        }
        if (parameters instanceof Array) {
            return parameters;
        }
        var list = [];
        for (var p in parameters) {
            list.push([p, parameters[p]]);
        }
        return list;
    }
,
    /** Convert the given parameters to a map from name to value. */
    getParameterMap: function getParameterMap(parameters) {
        if (parameters == null) {
            return {};
        }
        if (typeof parameters != &quot;object&quot;) {
            return OAuth.getParameterMap(OAuth.decodeForm(parameters + &quot;&quot;));
        }
        if (parameters instanceof Array) {
            var map = {};
            for (var p = 0; p &lt; parameters.length; ++p) {
                var key = parameters[p][0];
                if (map[key] === undefined) { // first value wins
                    map[key] = parameters[p][1];
                }
            }
            return map;
        }
        return parameters;
    }
,
    getParameter: function getParameter(parameters, name) {
        if (parameters instanceof Array) {
            for (var p = 0; p &lt; parameters.length; ++p) {
                if (parameters[p][0] == name) {
                    return parameters[p][1]; // first value wins
                }
            }
        } else {
            return OAuth.getParameterMap(parameters)[name];
        }
        return null;
    }
,
    formEncode: function formEncode(parameters) {
        var form = &quot;&quot;;
        var list = OAuth.getParameterList(parameters);
        for (var p = 0; p &lt; list.length; ++p) {
            var value = list[p][1];
            if (value == null) value = &quot;&quot;;
            if (form != &quot;&quot;) form += &apos;&amp;&apos;;
            form += OAuth.percentEncode(list[p][0])
              +&apos;=&apos;+ OAuth.percentEncode(value);
        }
        return form;
    }
,
    decodeForm: function decodeForm(form) {
        var list = [];
        var nvps = form.split(&apos;&amp;&apos;);
        for (var n = 0; n &lt; nvps.length; ++n) {
            var nvp = nvps[n];
            if (nvp == &quot;&quot;) {
                continue;
            }
            var equals = nvp.indexOf(&apos;=&apos;);
            var name;
            var value;
            if (equals &lt; 0) {
                name = OAuth.decodePercent(nvp);
                value = null;
            } else {
                name = OAuth.decodePercent(nvp.substring(0, equals));
                value = OAuth.decodePercent(nvp.substring(equals + 1));
            }
            list.push([name, value]);
        }
        return list;
    }
,
    setParameter: function setParameter(message, name, value) {
        var parameters = message.parameters;
        if (parameters instanceof Array) {
            for (var p = 0; p &lt; parameters.length; ++p) {
                if (parameters[p][0] == name) {
                    if (value === undefined) {
                        parameters.splice(p, 1);
                    } else {
                        parameters[p][1] = value;
                        value = undefined;
                    }
                }
            }
            if (value !== undefined) {
                parameters.push([name, value]);
            }
        } else {
            parameters = OAuth.getParameterMap(parameters);
            parameters[name] = value;
            message.parameters = parameters;
        }
    }
,
    setParameters: function setParameters(message, parameters) {
        var list = OAuth.getParameterList(parameters);
        for (var i = 0; i &lt; list.length; ++i) {
            OAuth.setParameter(message, list[i][0], list[i][1]);
        }
    }
,
    /** Fill in parameters to help construct a request message.
        This function doesn&apos;t fill in every parameter.
        The accessor object should be like:
        {consumerKey:&apos;foo&apos;, consumerSecret:&apos;bar&apos;, accessorSecret:&apos;nurn&apos;, token:&apos;krelm&apos;, tokenSecret:&apos;blah&apos;}
        The accessorSecret property is optional.
     */
    completeRequest: function completeRequest(message, accessor) {
        if (message.method == null) {
            message.method = &quot;GET&quot;;
        }
        var map = OAuth.getParameterMap(message.parameters);
        if (map.oauth_consumer_key == null) {
            OAuth.setParameter(message, &quot;oauth_consumer_key&quot;, accessor.consumerKey || &quot;&quot;);
        }
        if (map.oauth_token == null &amp;&amp; accessor.token != null) {
            OAuth.setParameter(message, &quot;oauth_token&quot;, accessor.token);
        }
        if (map.oauth_version == null) {
            OAuth.setParameter(message, &quot;oauth_version&quot;, &quot;1.0&quot;);
        }
        if (map.oauth_timestamp == null) {
            OAuth.setParameter(message, &quot;oauth_timestamp&quot;, OAuth.timestamp());
        }
        if (map.oauth_nonce == null) {
            OAuth.setParameter(message, &quot;oauth_nonce&quot;, OAuth.nonce(6));
        }
        OAuth.SignatureMethod.sign(message, accessor);
    }
,
    setTimestampAndNonce: function setTimestampAndNonce(message) {
        OAuth.setParameter(message, &quot;oauth_timestamp&quot;, OAuth.timestamp());
        OAuth.setParameter(message, &quot;oauth_nonce&quot;, OAuth.nonce(6));
    }
,
    addToURL: function addToURL(url, parameters) {
        newURL = url;
        if (parameters != null) {
            var toAdd = OAuth.formEncode(parameters);
            if (toAdd.length &gt; 0) {
                var q = url.indexOf(&apos;?&apos;);
                if (q &lt; 0) newURL += &apos;?&apos;;
                else       newURL += &apos;&amp;&apos;;
                newURL += toAdd;
            }
        }
        return newURL;
    }
,
    /** Construct the value of the Authorization header for an HTTP request. */
    getAuthorizationHeader: function getAuthorizationHeader(realm, parameters) {
        var header = &apos;OAuth realm=&quot;&apos; + OAuth.percentEncode(realm) + &apos;&quot;&apos;;
        var list = OAuth.getParameterList(parameters);
        for (var p = 0; p &lt; list.length; ++p) {
            var parameter = list[p];
            var name = parameter[0];
            if (name.indexOf(&quot;oauth_&quot;) == 0) {
                header += &apos;,&apos; + OAuth.percentEncode(name) + &apos;=&quot;&apos; + OAuth.percentEncode(parameter[1]) + &apos;&quot;&apos;;
            }
        }
        return header;
    }
,
    /** Correct the time using a parameter from the URL from which the last script was loaded. */
    correctTimestampFromSrc: function correctTimestampFromSrc(parameterName) {
        parameterName = parameterName || &quot;oauth_timestamp&quot;;
        var scripts = document.getElementsByTagName(&apos;script&apos;);
        if (scripts == null || !scripts.length) return;
        var src = scripts[scripts.length-1].src;
        if (!src) return;
        var q = src.indexOf(&quot;?&quot;);
        if (q &lt; 0) return;
        parameters = OAuth.getParameterMap(OAuth.decodeForm(src.substring(q+1)));
        var t = parameters[parameterName];
        if (t == null) return;
        OAuth.correctTimestamp(t);
    }
,
    /** Generate timestamps starting with the given value. */
    correctTimestamp: function correctTimestamp(timestamp) {
        OAuth.timeCorrectionMsec = (timestamp * 1000) - (new Date()).getTime();
    }
,
    /** The difference between the correct time and my clock. */
    timeCorrectionMsec: 0
,
    timestamp: function timestamp() {
        var t = (new Date()).getTime() + OAuth.timeCorrectionMsec;
        return Math.floor(t / 1000);
    }
,
    nonce: function nonce(length) {
        var chars = OAuth.nonce.CHARS;
        var result = &quot;&quot;;
        for (var i = 0; i &lt; length; ++i) {
            var rnum = Math.floor(Math.random() * chars.length);
            result += chars.substring(rnum, rnum+1);
        }
        return result;
    }
});

OAuth.nonce.CHARS = &quot;0123456789ABCDEFGHIJKLMNOPQRSTUVWXTZabcdefghiklmnopqrstuvwxyz&quot;;

/** Define a constructor function,
    without causing trouble to anyone who was using it as a namespace.
    That is, if parent[name] already existed and had properties,
    copy those properties into the new constructor.
 */
OAuth.declareClass = function declareClass(parent, name, newConstructor) {
    var previous = parent[name];
    parent[name] = newConstructor;
    if (newConstructor != null &amp;&amp; previous != null) {
        for (var key in previous) {
            if (key != &quot;prototype&quot;) {
                newConstructor[key] = previous[key];
            }
        }
    }
    return newConstructor;
}

/** An abstract algorithm for signing messages. */
OAuth.declareClass(OAuth, &quot;SignatureMethod&quot;, function OAuthSignatureMethod(){});

OAuth.setProperties(OAuth.SignatureMethod.prototype, // instance members
{
    /** Add a signature to the message. */
    sign: function sign(message) {
        var baseString = OAuth.SignatureMethod.getBaseString(message);
        var signature = this.getSignature(baseString);
        OAuth.setParameter(message, &quot;oauth_signature&quot;, signature);
        return signature; // just in case someone&apos;s interested
    }
,
    /** Set the key string for signing. */
    initialize: function initialize(name, accessor) {
        var consumerSecret;
        if (accessor.accessorSecret != null
            &amp;&amp; name.length &gt; 9
            &amp;&amp; name.substring(name.length-9) == &quot;-Accessor&quot;)
        {
            consumerSecret = accessor.accessorSecret;
        } else {
            consumerSecret = accessor.consumerSecret;
        }
        this.key = OAuth.percentEncode(consumerSecret)
             +&quot;&amp;&quot;+ OAuth.percentEncode(accessor.tokenSecret);
    }
});

/* SignatureMethod expects an accessor object to be like this:
   {tokenSecret: &quot;lakjsdflkj...&quot;, consumerSecret: &quot;QOUEWRI..&quot;, accessorSecret: &quot;xcmvzc...&quot;}
   The accessorSecret property is optional.
 */
// Class members:
OAuth.setProperties(OAuth.SignatureMethod, // class members
{
    sign: function sign(message, accessor) {
        var name = OAuth.getParameterMap(message.parameters).oauth_signature_method;
        if (name == null || name == &quot;&quot;) {
            name = &quot;HMAC-SHA1&quot;;
            OAuth.setParameter(message, &quot;oauth_signature_method&quot;, name);
        }
        OAuth.SignatureMethod.newMethod(name, accessor).sign(message);
    }
,
    /** Instantiate a SignatureMethod for the given method name. */
    newMethod: function newMethod(name, accessor) {
        var impl = OAuth.SignatureMethod.REGISTERED[name];
        if (impl != null) {
            var method = new impl();
            method.initialize(name, accessor);
            return method;
        }
        var err = new Error(&quot;signature_method_rejected&quot;);
        var acceptable = &quot;&quot;;
        for (var r in OAuth.SignatureMethod.REGISTERED) {
            if (acceptable != &quot;&quot;) acceptable += &apos;&amp;&apos;;
            acceptable += OAuth.percentEncode(r);
        }
        err.oauth_acceptable_signature_methods = acceptable;
        throw err;
    }
,
    /** A map from signature method name to constructor. */
    REGISTERED : {}
,
    /** Subsequently, the given constructor will be used for the named methods.
        The constructor will be called with no parameters.
        The resulting object should usually implement getSignature(baseString).
        You can easily define such a constructor by calling makeSubclass, below.
     */
    registerMethodClass: function registerMethodClass(names, classConstructor) {
        for (var n = 0; n &lt; names.length; ++n) {
            OAuth.SignatureMethod.REGISTERED[names[n]] = classConstructor;
        }
    }
,
    /** Create a subclass of OAuth.SignatureMethod, with the given getSignature function. */
    makeSubclass: function makeSubclass(getSignatureFunction) {
        var superClass = OAuth.SignatureMethod;
        var subClass = function() {
            superClass.call(this);
        };
        subClass.prototype = new superClass();
        // Delete instance variables from prototype:
        // delete subclass.prototype... There aren&apos;t any.
        subClass.prototype.getSignature = getSignatureFunction;
        subClass.prototype.constructor = subClass;
        return subClass;
    }
,
    getBaseString: function getBaseString(message) {
        var URL = message.action;
        var q = URL.indexOf(&apos;?&apos;);
        var parameters;
        if (q &lt; 0) {
            parameters = message.parameters;
        } else {
            // Combine the URL query string with the other parameters:
            parameters = OAuth.decodeForm(URL.substring(q + 1));
            var toAdd = OAuth.getParameterList(message.parameters);
            for (var a = 0; a &lt; toAdd.length; ++a) {
                parameters.push(toAdd[a]);
            }
        }
        return OAuth.percentEncode(message.method.toUpperCase())
         +&apos;&amp;&apos;+ OAuth.percentEncode(OAuth.SignatureMethod.normalizeUrl(URL))
         +&apos;&amp;&apos;+ OAuth.percentEncode(OAuth.SignatureMethod.normalizeParameters(parameters));
    }
,
    normalizeUrl: function normalizeUrl(url) {
        var uri = OAuth.SignatureMethod.parseUri(url);
        var scheme = uri.protocol.toLowerCase();
        var authority = uri.authority.toLowerCase();
        var dropPort = (scheme == &quot;http&quot; &amp;&amp; uri.port == 80)
                    || (scheme == &quot;https&quot; &amp;&amp; uri.port == 443);
        if (dropPort) {
            // find the last : in the authority
            var index = authority.lastIndexOf(&quot;:&quot;);
            if (index &gt;= 0) {
                authority = authority.substring(0, index);
            }
        }
        var path = uri.path;
        if (!path) {
            path = &quot;/&quot;; // conforms to RFC 2616 section 3.2.2
        }
        // we know that there is no query and no fragment here.
        return scheme + &quot;://&quot; + authority + path;
    }
,
    parseUri: function parseUri (str) {
        /* This function was adapted from parseUri 1.2.1
           http://stevenlevithan.com/demo/parseuri/js/assets/parseuri.js
         */
        var o = {key: [&quot;source&quot;,&quot;protocol&quot;,&quot;authority&quot;,&quot;userInfo&quot;,&quot;user&quot;,&quot;password&quot;,&quot;host&quot;,&quot;port&quot;,&quot;relative&quot;,&quot;path&quot;,&quot;directory&quot;,&quot;file&quot;,&quot;query&quot;,&quot;anchor&quot;],
                 parser: {strict: /^(?:([^:\/?#]+):)?(?:\/\/((?:(([^:@\/]*):?([^:@\/]*))?@)?([^:\/?#]*)(?::(\d*))?))?((((?:[^?#\/]*\/)*)([^?#]*))(?:\?([^#]*))?(?:#(.*))?)/ }};
        var m = o.parser.strict.exec(str);
        var uri = {};
        var i = 14;
        while (i--) uri[o.key[i]] = m[i] || &quot;&quot;;
        return uri;
    }
,
    normalizeParameters: function normalizeParameters(parameters) {
        if (parameters == null) {
            return &quot;&quot;;
        }
        var list = OAuth.getParameterList(parameters);
        var sortable = [];
        for (var p = 0; p &lt; list.length; ++p) {
            var nvp = list[p];
            if (nvp[0] != &quot;oauth_signature&quot;) {
                sortable.push([ OAuth.percentEncode(nvp[0])
                              + &quot; &quot; // because it comes before any character that can appear in a percentEncoded string.
                              + OAuth.percentEncode(nvp[1])
                              , nvp]);
            }
        }
        sortable.sort(function(a,b) {
                          if (a[0] &lt; b[0]) return  -1;
                          if (a[0] &gt; b[0]) return 1;
                          return 0;
                      });
        var sorted = [];
        for (var s = 0; s &lt; sortable.length; ++s) {
            sorted.push(sortable[s][1]);
        }
        return OAuth.formEncode(sorted);
    }
});

OAuth.SignatureMethod.registerMethodClass([&quot;PLAINTEXT&quot;, &quot;PLAINTEXT-Accessor&quot;],
    OAuth.SignatureMethod.makeSubclass(
        function getSignature(baseString) {
            return this.key;
        }
    ));

OAuth.SignatureMethod.registerMethodClass([&quot;HMAC-SHA1&quot;, &quot;HMAC-SHA1-Accessor&quot;],
    OAuth.SignatureMethod.makeSubclass(
        function getSignature(baseString) {
            b64pad = &apos;=&apos;;
            var signature = b64_hmac_sha1(this.key, baseString);
            return signature;
        }
    ));

try {
    OAuth.correctTimestampFromSrc();
} catch(e) {
}


//--------------------------------------------------

var consumerKey = &quot;${consumer_key}&quot;;
var consumerSecret = &quot;${consumer_secret}&quot;;
var params = [];
var query = [];
query.push(&apos;access_token&apos; + &apos;=&apos; + &apos;${access_token_before}&apos;);
query.push(&apos;id_token&apos; + &apos;=&apos; + &apos;${id_token_before}&apos;);
var url =  &quot;${protocol}://${misp_url}/marvelous/people/@me/@self&quot;;

if (query.length) {
    url += &apos;?&apos; + query.join(&apos;&amp;&apos;);
}

var message = {
    method: &apos;put&apos;,
    parameters: params, 
    action: url
};

log.info(url);
log.info(consumerSecret);

var accessor = {
    consumerKey: consumerKey,
    consumerSecret: consumerSecret,
    token:  &apos;${access_token_before}&apos;,
    tokenSecret: &apos;${id_token_before}&apos;
};

OAuth.completeRequest(message, accessor);
vars.put(&apos;put_auth_header&apos;, OAuth.getAuthorizationHeader(&apos;&apos;, params).replace(&apos;OAuth realm=&quot;&quot;,&apos;, &apos; OAuth &apos;));
</stringProp>
            <stringProp name="scriptLanguage">javascript</stringProp>
          </BSFPreProcessor>
          <hashTree/>
          <HeaderManager guiclass="HeaderPanel" testclass="HeaderManager" testname="HTTP ヘッダマネージャ" enabled="true">
            <collectionProp name="HeaderManager.headers">
              <elementProp name="" elementType="Header">
                <stringProp name="Header.name">Authorization</stringProp>
                <stringProp name="Header.value">${put_auth_header}</stringProp>
              </elementProp>
              <elementProp name="" elementType="Header">
                <stringProp name="Header.name">content-type</stringProp>
                <stringProp name="Header.value">application/json; charset=utf8</stringProp>
              </elementProp>
              <elementProp name="" elementType="Header">
                <stringProp name="Header.name">Connection</stringProp>
                <stringProp name="Header.value">close</stringProp>
              </elementProp>
              <elementProp name="" elementType="Header">
                <stringProp name="Header.name">Accept-encoding</stringProp>
                <stringProp name="Header.value">gzip, deflate</stringProp>
              </elementProp>
            </collectionProp>
          </HeaderManager>
          <hashTree/>
          <ResponseAssertion guiclass="AssertionGui" testclass="ResponseAssertion" testname="アサーション" enabled="true">
            <collectionProp name="Asserion.test_strings">
              <stringProp name="-820239147">&quot;password&quot;:&quot;&quot;</stringProp>
            </collectionProp>
            <stringProp name="TestPlan.comments">確認項目
パスワードが空になっていないか？</stringProp>
            <stringProp name="Assertion.test_field">Assertion.response_data</stringProp>
            <boolProp name="Assertion.assume_success">false</boolProp>
            <intProp name="Assertion.test_type">6</intProp>
          </ResponseAssertion>
          <hashTree/>
        </hashTree>
        <HTTPSamplerProxy guiclass="HttpTestSampleGui" testclass="HTTPSamplerProxy" testname="Basic.ID連携認証(Dummy2)" enabled="true">
          <elementProp name="HTTPsampler.Arguments" elementType="Arguments" guiclass="HTTPArgumentsPanel" testclass="Arguments" enabled="true">
            <collectionProp name="Arguments.arguments">
              <elementProp name="response_type" elementType="HTTPArgument">
                <boolProp name="HTTPArgument.always_encode">false</boolProp>
                <stringProp name="Argument.name">response_type</stringProp>
                <stringProp name="Argument.value">code</stringProp>
                <stringProp name="Argument.metadata">=</stringProp>
                <boolProp name="HTTPArgument.use_equals">true</boolProp>
              </elementProp>
              <elementProp name="client_id" elementType="HTTPArgument">
                <boolProp name="HTTPArgument.always_encode">false</boolProp>
                <stringProp name="Argument.name">client_id</stringProp>
                <stringProp name="Argument.value">00000</stringProp>
                <stringProp name="Argument.metadata">=</stringProp>
                <boolProp name="HTTPArgument.use_equals">true</boolProp>
              </elementProp>
              <elementProp name="redirect_uri" elementType="HTTPArgument">
                <boolProp name="HTTPArgument.always_encode">false</boolProp>
                <stringProp name="Argument.name">redirect_uri</stringProp>
                <stringProp name="Argument.value">${protocol}%3A%2F%2F${jmeter_path}%2Ftest%2Fmisp%2Fmisp-callback</stringProp>
                <stringProp name="Argument.metadata">=</stringProp>
                <boolProp name="HTTPArgument.use_equals">true</boolProp>
              </elementProp>
              <elementProp name="scope" elementType="HTTPArgument">
                <boolProp name="HTTPArgument.always_encode">false</boolProp>
                <stringProp name="Argument.name">scope</stringProp>
                <stringProp name="Argument.value">openid</stringProp>
                <stringProp name="Argument.metadata">=</stringProp>
                <boolProp name="HTTPArgument.use_equals">true</boolProp>
              </elementProp>
              <elementProp name="state" elementType="HTTPArgument">
                <boolProp name="HTTPArgument.always_encode">false</boolProp>
                <stringProp name="Argument.name">state</stringProp>
                <stringProp name="Argument.value">ddd</stringProp>
                <stringProp name="Argument.metadata">=</stringProp>
                <boolProp name="HTTPArgument.use_equals">true</boolProp>
              </elementProp>
              <elementProp name="platform_id" elementType="HTTPArgument">
                <boolProp name="HTTPArgument.always_encode">false</boolProp>
                <stringProp name="Argument.name">platform_id</stringProp>
                <stringProp name="Argument.value">Dummy2</stringProp>
                <stringProp name="Argument.metadata">=</stringProp>
                <boolProp name="HTTPArgument.use_equals">true</boolProp>
              </elementProp>
            </collectionProp>
          </elementProp>
          <stringProp name="HTTPSampler.domain"></stringProp>
          <stringProp name="HTTPSampler.port"></stringProp>
          <stringProp name="HTTPSampler.connect_timeout"></stringProp>
          <stringProp name="HTTPSampler.response_timeout"></stringProp>
          <stringProp name="HTTPSampler.protocol"></stringProp>
          <stringProp name="HTTPSampler.contentEncoding"></stringProp>
          <stringProp name="HTTPSampler.path">/marvelous/federation</stringProp>
          <stringProp name="HTTPSampler.method">GET</stringProp>
          <boolProp name="HTTPSampler.follow_redirects">true</boolProp>
          <boolProp name="HTTPSampler.auto_redirects">false</boolProp>
          <boolProp name="HTTPSampler.use_keepalive">true</boolProp>
          <boolProp name="HTTPSampler.DO_MULTIPART_POST">false</boolProp>
          <boolProp name="HTTPSampler.monitor">false</boolProp>
          <stringProp name="HTTPSampler.embedded_url_re"></stringProp>
          <stringProp name="TestPlan.comments">Detected the start of a redirect chain</stringProp>
        </HTTPSamplerProxy>
        <hashTree>
          <RegexExtractor guiclass="RegexExtractorGui" testclass="RegexExtractor" testname="code" enabled="true">
            <stringProp name="RegexExtractor.useHeaders">false</stringProp>
            <stringProp name="RegexExtractor.refname">code</stringProp>
            <stringProp name="RegexExtractor.regex">code=(.*?)&lt;br&gt;</stringProp>
            <stringProp name="RegexExtractor.template">$1$</stringProp>
            <stringProp name="RegexExtractor.default"></stringProp>
            <stringProp name="RegexExtractor.match_number">1</stringProp>
          </RegexExtractor>
          <hashTree/>
        </hashTree>
        <HTTPSamplerProxy guiclass="HttpTestSampleGui" testclass="HTTPSamplerProxy" testname="Basic.トークン取得(Dummy2)" enabled="true">
          <elementProp name="HTTPsampler.Arguments" elementType="Arguments" guiclass="HTTPArgumentsPanel" testclass="Arguments" enabled="true">
            <collectionProp name="Arguments.arguments">
              <elementProp name="grant_type" elementType="HTTPArgument">
                <boolProp name="HTTPArgument.always_encode">false</boolProp>
                <stringProp name="Argument.value">authorization_code</stringProp>
                <stringProp name="Argument.metadata">=</stringProp>
                <boolProp name="HTTPArgument.use_equals">true</boolProp>
                <stringProp name="Argument.name">grant_type</stringProp>
              </elementProp>
              <elementProp name="code" elementType="HTTPArgument">
                <boolProp name="HTTPArgument.always_encode">false</boolProp>
                <stringProp name="Argument.value">${code}</stringProp>
                <stringProp name="Argument.metadata">=</stringProp>
                <boolProp name="HTTPArgument.use_equals">true</boolProp>
                <stringProp name="Argument.name">code</stringProp>
              </elementProp>
              <elementProp name="redirect_uri" elementType="HTTPArgument">
                <boolProp name="HTTPArgument.always_encode">false</boolProp>
                <stringProp name="Argument.value">${protocol}%3A%2F%2F${jmeter_path}%2Ftest%2Fmisp%2Fmisp-callback</stringProp>
                <stringProp name="Argument.metadata">=</stringProp>
                <boolProp name="HTTPArgument.use_equals">true</boolProp>
                <stringProp name="Argument.name">redirect_uri</stringProp>
              </elementProp>
            </collectionProp>
          </elementProp>
          <stringProp name="HTTPSampler.domain">${misp_url}</stringProp>
          <stringProp name="HTTPSampler.port"></stringProp>
          <stringProp name="HTTPSampler.connect_timeout"></stringProp>
          <stringProp name="HTTPSampler.response_timeout"></stringProp>
          <stringProp name="HTTPSampler.protocol">${protocol}</stringProp>
          <stringProp name="HTTPSampler.contentEncoding"></stringProp>
          <stringProp name="HTTPSampler.path">/marvelous/token</stringProp>
          <stringProp name="HTTPSampler.method">POST</stringProp>
          <boolProp name="HTTPSampler.follow_redirects">true</boolProp>
          <boolProp name="HTTPSampler.auto_redirects">false</boolProp>
          <boolProp name="HTTPSampler.use_keepalive">true</boolProp>
          <boolProp name="HTTPSampler.DO_MULTIPART_POST">false</boolProp>
          <boolProp name="HTTPSampler.monitor">false</boolProp>
          <stringProp name="HTTPSampler.embedded_url_re"></stringProp>
        </HTTPSamplerProxy>
        <hashTree>
          <BSFPreProcessor guiclass="TestBeanGUI" testclass="BSFPreProcessor" testname="BSF PreProcessor" enabled="true">
            <stringProp name="filename"></stringProp>
            <stringProp name="parameters"></stringProp>
            <stringProp name="script">/*
 * A JavaScript implementation of the Secure Hash Algorithm, SHA-1, as defined
 * in FIPS PUB 180-1
 * Version 2.1a Copyright Paul Johnston 2000 - 2002.
 * Other contributors: Greg Holt, Andrew Kepert, Ydnar, Lostinet
 * Distributed under the BSD License
 * See http://pajhome.org.uk/crypt/md5 for details.
 */

/*
 * Configurable variables. You may need to tweak these to be compatible with
 * the server-side, but the defaults work in most cases.
 */
var hexcase = 0;  /* hex output format. 0 - lowercase; 1 - uppercase        */
var b64pad  = &quot;&quot;; /* base-64 pad character. &quot;=&quot; for strict RFC compliance   */
var chrsz   = 8;  /* bits per input character. 8 - ASCII; 16 - Unicode      */

/*
 * These are the functions you&apos;ll usually want to call
 * They take string arguments and return either hex or base-64 encoded strings
 */
function hex_sha1(s){return binb2hex(core_sha1(str2binb(s),s.length * chrsz));}
function b64_sha1(s){return binb2b64(core_sha1(str2binb(s),s.length * chrsz));}
function str_sha1(s){return binb2str(core_sha1(str2binb(s),s.length * chrsz));}
function hex_hmac_sha1(key, data){ return binb2hex(core_hmac_sha1(key, data));}
function b64_hmac_sha1(key, data){ return binb2b64(core_hmac_sha1(key, data));}
function str_hmac_sha1(key, data){ return binb2str(core_hmac_sha1(key, data));}

/*
 * Perform a simple self-test to see if the VM is working
 */
function sha1_vm_test()
{
  return hex_sha1(&quot;abc&quot;) == &quot;a9993e364706816aba3e25717850c26c9cd0d89d&quot;;
}

/*
 * Calculate the SHA-1 of an array of big-endian words, and a bit length
 */
function core_sha1(x, len)
{
  /* append padding */
  x[len &gt;&gt; 5] |= 0x80 &lt;&lt; (24 - len % 32);
  x[((len + 64 &gt;&gt; 9) &lt;&lt; 4) + 15] = len;

  var w = Array(80);
  var a =  1732584193;
  var b = -271733879;
  var c = -1732584194;
  var d =  271733878;
  var e = -1009589776;

  for(var i = 0; i &lt; x.length; i += 16)
  {
    var olda = a;
    var oldb = b;
    var oldc = c;
    var oldd = d;
    var olde = e;

    for(var j = 0; j &lt; 80; j++)
    {
      if(j &lt; 16) w[j] = x[i + j];
      else w[j] = rol(w[j-3] ^ w[j-8] ^ w[j-14] ^ w[j-16], 1);
      var t = safe_add(safe_add(rol(a, 5), sha1_ft(j, b, c, d)),
                       safe_add(safe_add(e, w[j]), sha1_kt(j)));
      e = d;
      d = c;
      c = rol(b, 30);
      b = a;
      a = t;
    }

    a = safe_add(a, olda);
    b = safe_add(b, oldb);
    c = safe_add(c, oldc);
    d = safe_add(d, oldd);
    e = safe_add(e, olde);
  }
  return Array(a, b, c, d, e);

}

/*
 * Perform the appropriate triplet combination function for the current
 * iteration
 */
function sha1_ft(t, b, c, d)
{
  if(t &lt; 20) return (b &amp; c) | ((~b) &amp; d);
  if(t &lt; 40) return b ^ c ^ d;
  if(t &lt; 60) return (b &amp; c) | (b &amp; d) | (c &amp; d);
  return b ^ c ^ d;
}

/*
 * Determine the appropriate additive constant for the current iteration
 */
function sha1_kt(t)
{
  return (t &lt; 20) ?  1518500249 : (t &lt; 40) ?  1859775393 :
         (t &lt; 60) ? -1894007588 : -899497514;
}

/*
 * Calculate the HMAC-SHA1 of a key and some data
 */
function core_hmac_sha1(key, data)
{
  var bkey = str2binb(key);
  if(bkey.length &gt; 16) bkey = core_sha1(bkey, key.length * chrsz);

  var ipad = Array(16), opad = Array(16);
  for(var i = 0; i &lt; 16; i++)
  {
    ipad[i] = bkey[i] ^ 0x36363636;
    opad[i] = bkey[i] ^ 0x5C5C5C5C;
  }

  var hash = core_sha1(ipad.concat(str2binb(data)), 512 + data.length * chrsz);
  return core_sha1(opad.concat(hash), 512 + 160);
}

/*
 * Add integers, wrapping at 2^32. This uses 16-bit operations internally
 * to work around bugs in some JS interpreters.
 */
function safe_add(x, y)
{
  var lsw = (x &amp; 0xFFFF) + (y &amp; 0xFFFF);
  var msw = (x &gt;&gt; 16) + (y &gt;&gt; 16) + (lsw &gt;&gt; 16);
  return (msw &lt;&lt; 16) | (lsw &amp; 0xFFFF);
}

/*
 * Bitwise rotate a 32-bit number to the left.
 */
function rol(num, cnt)
{
  return (num &lt;&lt; cnt) | (num &gt;&gt;&gt; (32 - cnt));
}

/*
 * Convert an 8-bit or 16-bit string to an array of big-endian words
 * In 8-bit function, characters &gt;255 have their hi-byte silently ignored.
 */
function str2binb(str)
{
  var bin = Array();
  var mask = (1 &lt;&lt; chrsz) - 1;
  for(var i = 0; i &lt; str.length * chrsz; i += chrsz)
    bin[i&gt;&gt;5] |= (str.charCodeAt(i / chrsz) &amp; mask) &lt;&lt; (32 - chrsz - i%32);
  return bin;
}

/*
 * Convert an array of big-endian words to a string
 */
function binb2str(bin)
{
  var str = &quot;&quot;;
  var mask = (1 &lt;&lt; chrsz) - 1;
  for(var i = 0; i &lt; bin.length * 32; i += chrsz)
    str += String.fromCharCode((bin[i&gt;&gt;5] &gt;&gt;&gt; (32 - chrsz - i%32)) &amp; mask);
  return str;
}

/*
 * Convert an array of big-endian words to a hex string.
 */
function binb2hex(binarray)
{
  var hex_tab = hexcase ? &quot;0123456789ABCDEF&quot; : &quot;0123456789abcdef&quot;;
  var str = &quot;&quot;;
  for(var i = 0; i &lt; binarray.length * 4; i++)
  {
    str += hex_tab.charAt((binarray[i&gt;&gt;2] &gt;&gt; ((3 - i%4)*8+4)) &amp; 0xF) +
           hex_tab.charAt((binarray[i&gt;&gt;2] &gt;&gt; ((3 - i%4)*8  )) &amp; 0xF);
  }
  return str;
}

/*
 * Convert an array of big-endian words to a base-64 string
 */
function binb2b64(binarray)
{
  var tab = &quot;ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/&quot;;
  var str = &quot;&quot;;
  for(var i = 0; i &lt; binarray.length * 4; i += 3)
  {
    var triplet = (((binarray[i   &gt;&gt; 2] &gt;&gt; 8 * (3 -  i   %4)) &amp; 0xFF) &lt;&lt; 16)
                | (((binarray[i+1 &gt;&gt; 2] &gt;&gt; 8 * (3 - (i+1)%4)) &amp; 0xFF) &lt;&lt; 8 )
                |  ((binarray[i+2 &gt;&gt; 2] &gt;&gt; 8 * (3 - (i+2)%4)) &amp; 0xFF);
    for(var j = 0; j &lt; 4; j++)
    {
      if(i * 8 + j * 6 &gt; binarray.length * 32) str += b64pad;
      else str += tab.charAt((triplet &gt;&gt; 6*(3-j)) &amp; 0x3F);
    }
  }
  return str;
}

/*
 * Copyright 2008 Netflix, Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/* Here&apos;s some JavaScript software for implementing OAuth.

   This isn&apos;t as useful as you might hope.  OAuth is based around
   allowing tools and websites to talk to each other.  However,
   JavaScript running in web browsers is hampered by security
   restrictions that prevent code running on one website from
   accessing data stored or served on another.

   Before you start hacking, make sure you understand the limitations
   posed by cross-domain XMLHttpRequest.

   On the bright side, some platforms use JavaScript as their
   language, but enable the programmer to access other web sites.
   Examples include Google Gadgets, and Microsoft Vista Sidebar.
   For those platforms, this library should come in handy.
*/

// The HMAC-SHA1 signature method calls b64_hmac_sha1, defined by
// http://pajhome.org.uk/crypt/md5/sha1.js

/* An OAuth message is represented as an object like this:
   {method: &quot;GET&quot;, action: &quot;http://server.com/path&quot;, parameters: ...}

   The parameters may be either a map {name: value, name2: value2}
   or an Array of name-value pairs [[name, value], [name2, value2]].
   The latter representation is more powerful: it supports parameters
   in a specific sequence, or several parameters with the same name;
   for example [[&quot;a&quot;, 1], [&quot;b&quot;, 2], [&quot;a&quot;, 3]].

   Parameter names and values are NOT percent-encoded in an object.
   They must be encoded before transmission and decoded after reception.
   For example, this message object:
   {method: &quot;GET&quot;, action: &quot;http://server/path&quot;, parameters: {p: &quot;x y&quot;}}
   ... can be transmitted as an HTTP request that begins:
   GET /path?p=x%20y HTTP/1.0
   (This isn&apos;t a valid OAuth request, since it lacks a signature etc.)
   Note that the object &quot;x y&quot; is transmitted as x%20y.  To encode
   parameters, you can call OAuth.addToURL, OAuth.formEncode or
   OAuth.getAuthorization.

   This message object model harmonizes with the browser object model for
   input elements of an form, whose value property isn&apos;t percent encoded.
   The browser encodes each value before transmitting it. For example,
   see consumer.setInputs in example/consumer.js.
 */

/* This script needs to know what time it is. By default, it uses the local
   clock (new Date), which is apt to be inaccurate in browsers. To do
   better, you can load this script from a URL whose query string contains
   an oauth_timestamp parameter, whose value is a current Unix timestamp.
   For example, when generating the enclosing document using PHP:

   &lt;script src=&quot;oauth.js?oauth_timestamp=&lt;?=time()?&gt;&quot; ...

   Another option is to call OAuth.correctTimestamp with a Unix timestamp.
 */

var OAuth; if (OAuth == null) OAuth = {};

OAuth.setProperties = function setProperties(into, from) {
    if (into != null &amp;&amp; from != null) {
        for (var key in from) {
            into[key] = from[key];
        }
    }
    return into;
}

OAuth.setProperties(OAuth, // utility functions
{
    percentEncode: function percentEncode(s) {
        if (s == null) {
            return &quot;&quot;;
        }
        if (s instanceof Array) {
            var e = &quot;&quot;;
            for (var i = 0; i &lt; s.length; ++s) {
                if (e != &quot;&quot;) e += &apos;&amp;&apos;;
                e += OAuth.percentEncode(s[i]);
            }
            return e;
        }
        s = encodeURIComponent(s);
        // Now replace the values which encodeURIComponent doesn&apos;t do
        // encodeURIComponent ignores: - _ . ! ~ * &apos; ( )
        // OAuth dictates the only ones you can ignore are: - _ . ~
        // Source: http://developer.mozilla.org/en/docs/Core_JavaScript_1.5_Reference:Global_Functions:encodeURIComponent
        s = s.replace(/\!/g, &quot;%21&quot;);
        s = s.replace(/\*/g, &quot;%2A&quot;);
        s = s.replace(/\&apos;/g, &quot;%27&quot;);
        s = s.replace(/\(/g, &quot;%28&quot;);
        s = s.replace(/\)/g, &quot;%29&quot;);
        return s;
    }
,
    decodePercent: function decodePercent(s) {
        if (s != null) {
            // Handle application/x-www-form-urlencoded, which is defined by
            // http://www.w3.org/TR/html4/interact/forms.html#h-17.13.4.1
            s = s.replace(/\+/g, &quot; &quot;);
        }
        return decodeURIComponent(s);
    }
,
    /** Convert the given parameters to an Array of name-value pairs. */
    getParameterList: function getParameterList(parameters) {
        if (parameters == null) {
            return [];
        }
        if (typeof parameters != &quot;object&quot;) {
            return OAuth.decodeForm(parameters + &quot;&quot;);
        }
        if (parameters instanceof Array) {
            return parameters;
        }
        var list = [];
        for (var p in parameters) {
            list.push([p, parameters[p]]);
        }
        return list;
    }
,
    /** Convert the given parameters to a map from name to value. */
    getParameterMap: function getParameterMap(parameters) {
        if (parameters == null) {
            return {};
        }
        if (typeof parameters != &quot;object&quot;) {
            return OAuth.getParameterMap(OAuth.decodeForm(parameters + &quot;&quot;));
        }
        if (parameters instanceof Array) {
            var map = {};
            for (var p = 0; p &lt; parameters.length; ++p) {
                var key = parameters[p][0];
                if (map[key] === undefined) { // first value wins
                    map[key] = parameters[p][1];
                }
            }
            return map;
        }
        return parameters;
    }
,
    getParameter: function getParameter(parameters, name) {
        if (parameters instanceof Array) {
            for (var p = 0; p &lt; parameters.length; ++p) {
                if (parameters[p][0] == name) {
                    return parameters[p][1]; // first value wins
                }
            }
        } else {
            return OAuth.getParameterMap(parameters)[name];
        }
        return null;
    }
,
    formEncode: function formEncode(parameters) {
        var form = &quot;&quot;;
        var list = OAuth.getParameterList(parameters);
        for (var p = 0; p &lt; list.length; ++p) {
            var value = list[p][1];
            if (value == null) value = &quot;&quot;;
            if (form != &quot;&quot;) form += &apos;&amp;&apos;;
            form += OAuth.percentEncode(list[p][0])
              +&apos;=&apos;+ OAuth.percentEncode(value);
        }
        return form;
    }
,
    decodeForm: function decodeForm(form) {
        var list = [];
        var nvps = form.split(&apos;&amp;&apos;);
        for (var n = 0; n &lt; nvps.length; ++n) {
            var nvp = nvps[n];
            if (nvp == &quot;&quot;) {
                continue;
            }
            var equals = nvp.indexOf(&apos;=&apos;);
            var name;
            var value;
            if (equals &lt; 0) {
                name = OAuth.decodePercent(nvp);
                value = null;
            } else {
                name = OAuth.decodePercent(nvp.substring(0, equals));
                value = OAuth.decodePercent(nvp.substring(equals + 1));
            }
            list.push([name, value]);
        }
        return list;
    }
,
    setParameter: function setParameter(message, name, value) {
        var parameters = message.parameters;
        if (parameters instanceof Array) {
            for (var p = 0; p &lt; parameters.length; ++p) {
                if (parameters[p][0] == name) {
                    if (value === undefined) {
                        parameters.splice(p, 1);
                    } else {
                        parameters[p][1] = value;
                        value = undefined;
                    }
                }
            }
            if (value !== undefined) {
                parameters.push([name, value]);
            }
        } else {
            parameters = OAuth.getParameterMap(parameters);
            parameters[name] = value;
            message.parameters = parameters;
        }
    }
,
    setParameters: function setParameters(message, parameters) {
        var list = OAuth.getParameterList(parameters);
        for (var i = 0; i &lt; list.length; ++i) {
            OAuth.setParameter(message, list[i][0], list[i][1]);
        }
    }
,
    /** Fill in parameters to help construct a request message.
        This function doesn&apos;t fill in every parameter.
        The accessor object should be like:
        {consumerKey:&apos;foo&apos;, consumerSecret:&apos;bar&apos;, accessorSecret:&apos;nurn&apos;, token:&apos;krelm&apos;, tokenSecret:&apos;blah&apos;}
        The accessorSecret property is optional.
     */
    completeRequest: function completeRequest(message, accessor) {
        if (message.method == null) {
            message.method = &quot;GET&quot;;
        }
        var map = OAuth.getParameterMap(message.parameters);
        if (map.oauth_consumer_key == null) {
            OAuth.setParameter(message, &quot;oauth_consumer_key&quot;, accessor.consumerKey || &quot;&quot;);
        }
        if (map.oauth_token == null &amp;&amp; accessor.token != null) {
            OAuth.setParameter(message, &quot;oauth_token&quot;, accessor.token);
        }
        if (map.oauth_version == null) {
            OAuth.setParameter(message, &quot;oauth_version&quot;, &quot;1.0&quot;);
        }
        if (map.oauth_timestamp == null) {
            OAuth.setParameter(message, &quot;oauth_timestamp&quot;, OAuth.timestamp());
        }
        if (map.oauth_nonce == null) {
            OAuth.setParameter(message, &quot;oauth_nonce&quot;, OAuth.nonce(6));
        }
        OAuth.SignatureMethod.sign(message, accessor);
    }
,
    setTimestampAndNonce: function setTimestampAndNonce(message) {
        OAuth.setParameter(message, &quot;oauth_timestamp&quot;, OAuth.timestamp());
        OAuth.setParameter(message, &quot;oauth_nonce&quot;, OAuth.nonce(6));
    }
,
    addToURL: function addToURL(url, parameters) {
        newURL = url;
        if (parameters != null) {
            var toAdd = OAuth.formEncode(parameters);
            if (toAdd.length &gt; 0) {
                var q = url.indexOf(&apos;?&apos;);
                if (q &lt; 0) newURL += &apos;?&apos;;
                else       newURL += &apos;&amp;&apos;;
                newURL += toAdd;
            }
        }
        return newURL;
    }
,
    /** Construct the value of the Authorization header for an HTTP request. */
    getAuthorizationHeader: function getAuthorizationHeader(realm, parameters) {
        var header = &apos;OAuth realm=&quot;&apos; + OAuth.percentEncode(realm) + &apos;&quot;&apos;;
        var list = OAuth.getParameterList(parameters);
        for (var p = 0; p &lt; list.length; ++p) {
            var parameter = list[p];
            var name = parameter[0];
            if (name.indexOf(&quot;oauth_&quot;) == 0) {
                header += &apos;,&apos; + OAuth.percentEncode(name) + &apos;=&quot;&apos; + OAuth.percentEncode(parameter[1]) + &apos;&quot;&apos;;
            }
        }
        return header;
    }
,
    /** Correct the time using a parameter from the URL from which the last script was loaded. */
    correctTimestampFromSrc: function correctTimestampFromSrc(parameterName) {
        parameterName = parameterName || &quot;oauth_timestamp&quot;;
        var scripts = document.getElementsByTagName(&apos;script&apos;);
        if (scripts == null || !scripts.length) return;
        var src = scripts[scripts.length-1].src;
        if (!src) return;
        var q = src.indexOf(&quot;?&quot;);
        if (q &lt; 0) return;
        parameters = OAuth.getParameterMap(OAuth.decodeForm(src.substring(q+1)));
        var t = parameters[parameterName];
        if (t == null) return;
        OAuth.correctTimestamp(t);
    }
,
    /** Generate timestamps starting with the given value. */
    correctTimestamp: function correctTimestamp(timestamp) {
        OAuth.timeCorrectionMsec = (timestamp * 1000) - (new Date()).getTime();
    }
,
    /** The difference between the correct time and my clock. */
    timeCorrectionMsec: 0
,
    timestamp: function timestamp() {
        var t = (new Date()).getTime() + OAuth.timeCorrectionMsec;
        return Math.floor(t / 1000);
    }
,
    nonce: function nonce(length) {
        var chars = OAuth.nonce.CHARS;
        var result = &quot;&quot;;
        for (var i = 0; i &lt; length; ++i) {
            var rnum = Math.floor(Math.random() * chars.length);
            result += chars.substring(rnum, rnum+1);
        }
        return result;
    }
});

OAuth.nonce.CHARS = &quot;0123456789ABCDEFGHIJKLMNOPQRSTUVWXTZabcdefghiklmnopqrstuvwxyz&quot;;

/** Define a constructor function,
    without causing trouble to anyone who was using it as a namespace.
    That is, if parent[name] already existed and had properties,
    copy those properties into the new constructor.
 */
OAuth.declareClass = function declareClass(parent, name, newConstructor) {
    var previous = parent[name];
    parent[name] = newConstructor;
    if (newConstructor != null &amp;&amp; previous != null) {
        for (var key in previous) {
            if (key != &quot;prototype&quot;) {
                newConstructor[key] = previous[key];
            }
        }
    }
    return newConstructor;
}

/** An abstract algorithm for signing messages. */
OAuth.declareClass(OAuth, &quot;SignatureMethod&quot;, function OAuthSignatureMethod(){});

OAuth.setProperties(OAuth.SignatureMethod.prototype, // instance members
{
    /** Add a signature to the message. */
    sign: function sign(message) {
        var baseString = OAuth.SignatureMethod.getBaseString(message);
        var signature = this.getSignature(baseString);
        OAuth.setParameter(message, &quot;oauth_signature&quot;, signature);
        return signature; // just in case someone&apos;s interested
    }
,
    /** Set the key string for signing. */
    initialize: function initialize(name, accessor) {
        var consumerSecret;
        if (accessor.accessorSecret != null
            &amp;&amp; name.length &gt; 9
            &amp;&amp; name.substring(name.length-9) == &quot;-Accessor&quot;)
        {
            consumerSecret = accessor.accessorSecret;
        } else {
            consumerSecret = accessor.consumerSecret;
        }
        this.key = OAuth.percentEncode(consumerSecret)
             +&quot;&amp;&quot;+ OAuth.percentEncode(accessor.tokenSecret);
    }
});

/* SignatureMethod expects an accessor object to be like this:
   {tokenSecret: &quot;lakjsdflkj...&quot;, consumerSecret: &quot;QOUEWRI..&quot;, accessorSecret: &quot;xcmvzc...&quot;}
   The accessorSecret property is optional.
 */
// Class members:
OAuth.setProperties(OAuth.SignatureMethod, // class members
{
    sign: function sign(message, accessor) {
        var name = OAuth.getParameterMap(message.parameters).oauth_signature_method;
        if (name == null || name == &quot;&quot;) {
            name = &quot;HMAC-SHA1&quot;;
            OAuth.setParameter(message, &quot;oauth_signature_method&quot;, name);
        }
        OAuth.SignatureMethod.newMethod(name, accessor).sign(message);
    }
,
    /** Instantiate a SignatureMethod for the given method name. */
    newMethod: function newMethod(name, accessor) {
        var impl = OAuth.SignatureMethod.REGISTERED[name];
        if (impl != null) {
            var method = new impl();
            method.initialize(name, accessor);
            return method;
        }
        var err = new Error(&quot;signature_method_rejected&quot;);
        var acceptable = &quot;&quot;;
        for (var r in OAuth.SignatureMethod.REGISTERED) {
            if (acceptable != &quot;&quot;) acceptable += &apos;&amp;&apos;;
            acceptable += OAuth.percentEncode(r);
        }
        err.oauth_acceptable_signature_methods = acceptable;
        throw err;
    }
,
    /** A map from signature method name to constructor. */
    REGISTERED : {}
,
    /** Subsequently, the given constructor will be used for the named methods.
        The constructor will be called with no parameters.
        The resulting object should usually implement getSignature(baseString).
        You can easily define such a constructor by calling makeSubclass, below.
     */
    registerMethodClass: function registerMethodClass(names, classConstructor) {
        for (var n = 0; n &lt; names.length; ++n) {
            OAuth.SignatureMethod.REGISTERED[names[n]] = classConstructor;
        }
    }
,
    /** Create a subclass of OAuth.SignatureMethod, with the given getSignature function. */
    makeSubclass: function makeSubclass(getSignatureFunction) {
        var superClass = OAuth.SignatureMethod;
        var subClass = function() {
            superClass.call(this);
        };
        subClass.prototype = new superClass();
        // Delete instance variables from prototype:
        // delete subclass.prototype... There aren&apos;t any.
        subClass.prototype.getSignature = getSignatureFunction;
        subClass.prototype.constructor = subClass;
        return subClass;
    }
,
    getBaseString: function getBaseString(message) {
        var URL = message.action;
        var q = URL.indexOf(&apos;?&apos;);
        var parameters;
        if (q &lt; 0) {
            parameters = message.parameters;
        } else {
            // Combine the URL query string with the other parameters:
            parameters = OAuth.decodeForm(URL.substring(q + 1));
            var toAdd = OAuth.getParameterList(message.parameters);
            for (var a = 0; a &lt; toAdd.length; ++a) {
                parameters.push(toAdd[a]);
            }
        }
        return OAuth.percentEncode(message.method.toUpperCase())
         +&apos;&amp;&apos;+ OAuth.percentEncode(OAuth.SignatureMethod.normalizeUrl(URL))
         +&apos;&amp;&apos;+ OAuth.percentEncode(OAuth.SignatureMethod.normalizeParameters(parameters));
    }
,
    normalizeUrl: function normalizeUrl(url) {
        var uri = OAuth.SignatureMethod.parseUri(url);
        var scheme = uri.protocol.toLowerCase();
        var authority = uri.authority.toLowerCase();
        var dropPort = (scheme == &quot;http&quot; &amp;&amp; uri.port == 80)
                    || (scheme == &quot;https&quot; &amp;&amp; uri.port == 443);
        if (dropPort) {
            // find the last : in the authority
            var index = authority.lastIndexOf(&quot;:&quot;);
            if (index &gt;= 0) {
                authority = authority.substring(0, index);
            }
        }
        var path = uri.path;
        if (!path) {
            path = &quot;/&quot;; // conforms to RFC 2616 section 3.2.2
        }
        // we know that there is no query and no fragment here.
        return scheme + &quot;://&quot; + authority + path;
    }
,
    parseUri: function parseUri (str) {
        /* This function was adapted from parseUri 1.2.1
           http://stevenlevithan.com/demo/parseuri/js/assets/parseuri.js
         */
        var o = {key: [&quot;source&quot;,&quot;protocol&quot;,&quot;authority&quot;,&quot;userInfo&quot;,&quot;user&quot;,&quot;password&quot;,&quot;host&quot;,&quot;port&quot;,&quot;relative&quot;,&quot;path&quot;,&quot;directory&quot;,&quot;file&quot;,&quot;query&quot;,&quot;anchor&quot;],
                 parser: {strict: /^(?:([^:\/?#]+):)?(?:\/\/((?:(([^:@\/]*):?([^:@\/]*))?@)?([^:\/?#]*)(?::(\d*))?))?((((?:[^?#\/]*\/)*)([^?#]*))(?:\?([^#]*))?(?:#(.*))?)/ }};
        var m = o.parser.strict.exec(str);
        var uri = {};
        var i = 14;
        while (i--) uri[o.key[i]] = m[i] || &quot;&quot;;
        return uri;
    }
,
    normalizeParameters: function normalizeParameters(parameters) {
        if (parameters == null) {
            return &quot;&quot;;
        }
        var list = OAuth.getParameterList(parameters);
        var sortable = [];
        for (var p = 0; p &lt; list.length; ++p) {
            var nvp = list[p];
            if (nvp[0] != &quot;oauth_signature&quot;) {
                sortable.push([ OAuth.percentEncode(nvp[0])
                              + &quot; &quot; // because it comes before any character that can appear in a percentEncoded string.
                              + OAuth.percentEncode(nvp[1])
                              , nvp]);
            }
        }
        sortable.sort(function(a,b) {
                          if (a[0] &lt; b[0]) return  -1;
                          if (a[0] &gt; b[0]) return 1;
                          return 0;
                      });
        var sorted = [];
        for (var s = 0; s &lt; sortable.length; ++s) {
            sorted.push(sortable[s][1]);
        }
        return OAuth.formEncode(sorted);
    }
});

OAuth.SignatureMethod.registerMethodClass([&quot;PLAINTEXT&quot;, &quot;PLAINTEXT-Accessor&quot;],
    OAuth.SignatureMethod.makeSubclass(
        function getSignature(baseString) {
            return this.key;
        }
    ));

OAuth.SignatureMethod.registerMethodClass([&quot;HMAC-SHA1&quot;, &quot;HMAC-SHA1-Accessor&quot;],
    OAuth.SignatureMethod.makeSubclass(
        function getSignature(baseString) {
            b64pad = &apos;=&apos;;
            var signature = b64_hmac_sha1(this.key, baseString);
            return signature;
        }
    ));

try {
    OAuth.correctTimestampFromSrc();
} catch(e) {
}


//--------------------------------------------------

var consumerKey = &quot;${consumer_key}&quot;;
var consumerSecret = &quot;${consumer_secret}&quot;;
var params = [];
var query = [];
query.push(&apos;grant_type&apos; + &apos;=&apos; + &apos;authorization_code&apos;);
query.push(&apos;code&apos; + &apos;=&apos; + &apos;${code}&apos;);
query.push(&apos;redirect_uri&apos; + &apos;=&apos; + &apos;${protocol}%3A%2F%2F${jmeter_path}%2Ftest%2Fmisp%2Fmisp-callback&apos;);
var url =  &quot;${protocol}://${misp_url}/marvelous/token&quot;;

if (query.length) {
    url += &apos;?&apos; + query.join(&apos;&amp;&apos;);
}

var message = {
    method: &apos;post&apos;,
    parameters: params, 
    action: url
};
       
var accessor = {
    consumerKey: consumerKey,
    consumerSecret: consumerSecret,
    token: null,
    tokenSecret: null
};

OAuth.completeRequest(message, accessor);
vars.put(&apos;token_auth_header&apos;, OAuth.getAuthorizationHeader(&apos;&apos;, params).replace(&apos;OAuth realm=&quot;&quot;,&apos;, &apos; OAuth &apos;));
</stringProp>
            <stringProp name="scriptLanguage">javascript</stringProp>
          </BSFPreProcessor>
          <hashTree/>
          <HeaderManager guiclass="HeaderPanel" testclass="HeaderManager" testname="HTTP ヘッダマネージャ" enabled="true">
            <collectionProp name="HeaderManager.headers">
              <elementProp name="" elementType="Header">
                <stringProp name="Header.name">Authorization</stringProp>
                <stringProp name="Header.value">${token_auth_header}</stringProp>
              </elementProp>
              <elementProp name="" elementType="Header">
                <stringProp name="Header.name">content-type</stringProp>
                <stringProp name="Header.value">application/x-www-form-urlencoded</stringProp>
              </elementProp>
            </collectionProp>
          </HeaderManager>
          <hashTree/>
          <RegexExtractor guiclass="RegexExtractorGui" testclass="RegexExtractor" testname="access_token" enabled="true">
            <stringProp name="RegexExtractor.useHeaders">false</stringProp>
            <stringProp name="RegexExtractor.refname">access_token</stringProp>
            <stringProp name="RegexExtractor.regex">&quot;access_token&quot;:&quot;(.*?)&quot;,</stringProp>
            <stringProp name="RegexExtractor.template">$1$</stringProp>
            <stringProp name="RegexExtractor.default"></stringProp>
            <stringProp name="RegexExtractor.match_number">1</stringProp>
          </RegexExtractor>
          <hashTree/>
          <RegexExtractor guiclass="RegexExtractorGui" testclass="RegexExtractor" testname="id_token" enabled="true">
            <stringProp name="RegexExtractor.useHeaders">false</stringProp>
            <stringProp name="RegexExtractor.refname">id_token</stringProp>
            <stringProp name="RegexExtractor.regex">&quot;id_token&quot;:&quot;(.*?)&quot;</stringProp>
            <stringProp name="RegexExtractor.template">$1$</stringProp>
            <stringProp name="RegexExtractor.default"></stringProp>
            <stringProp name="RegexExtractor.match_number">1</stringProp>
          </RegexExtractor>
          <hashTree/>
        </hashTree>
        <HTTPSamplerProxy guiclass="HttpTestSampleGui" testclass="HTTPSamplerProxy" testname="Basic.ユーザ更新(ID連携)(Dummy2)" enabled="true">
          <boolProp name="HTTPSampler.postBodyRaw">true</boolProp>
          <elementProp name="HTTPsampler.Arguments" elementType="Arguments">
            <collectionProp name="Arguments.arguments">
              <elementProp name="" elementType="HTTPArgument">
                <boolProp name="HTTPArgument.always_encode">false</boolProp>
                <stringProp name="Argument.value">{&#xd;
  &quot;entry&quot;: [&#xd;
    {&#xd;
      &quot;apps&quot;: [&#xd;
        {&#xd;
          &quot;value&quot;: {&#xd;
            &quot;appId&quot;: &quot;00000&quot;,&#xd;
            &quot;userId&quot;: &quot;basic_3&quot;,&#xd;
            &quot;username&quot;: &quot;basic_the_SUN&quot;&#xd;
          }&#xd;
        }&#xd;
      ]&#xd;
    }&#xd;
  ]&#xd;
}</stringProp>
                <stringProp name="Argument.metadata">=</stringProp>
              </elementProp>
            </collectionProp>
          </elementProp>
          <stringProp name="HTTPSampler.domain"></stringProp>
          <stringProp name="HTTPSampler.port"></stringProp>
          <stringProp name="HTTPSampler.connect_timeout"></stringProp>
          <stringProp name="HTTPSampler.response_timeout"></stringProp>
          <stringProp name="HTTPSampler.protocol"></stringProp>
          <stringProp name="HTTPSampler.contentEncoding"></stringProp>
          <stringProp name="HTTPSampler.path">/marvelous/people/@me/@self?access_token=${access_token}&amp;id_token=${id_token}</stringProp>
          <stringProp name="HTTPSampler.method">PUT</stringProp>
          <boolProp name="HTTPSampler.follow_redirects">true</boolProp>
          <boolProp name="HTTPSampler.auto_redirects">false</boolProp>
          <boolProp name="HTTPSampler.use_keepalive">true</boolProp>
          <boolProp name="HTTPSampler.DO_MULTIPART_POST">false</boolProp>
          <boolProp name="HTTPSampler.monitor">false</boolProp>
          <stringProp name="HTTPSampler.embedded_url_re"></stringProp>
        </HTTPSamplerProxy>
        <hashTree>
          <BSFPreProcessor guiclass="TestBeanGUI" testclass="BSFPreProcessor" testname="BSF PreProcessor" enabled="true">
            <stringProp name="filename"></stringProp>
            <stringProp name="parameters"></stringProp>
            <stringProp name="script">/*
 * A JavaScript implementation of the Secure Hash Algorithm, SHA-1, as defined
 * in FIPS PUB 180-1
 * Version 2.1a Copyright Paul Johnston 2000 - 2002.
 * Other contributors: Greg Holt, Andrew Kepert, Ydnar, Lostinet
 * Distributed under the BSD License
 * See http://pajhome.org.uk/crypt/md5 for details.
 */

/*
 * Configurable variables. You may need to tweak these to be compatible with
 * the server-side, but the defaults work in most cases.
 */
var hexcase = 0;  /* hex output format. 0 - lowercase; 1 - uppercase        */
var b64pad  = &quot;&quot;; /* base-64 pad character. &quot;=&quot; for strict RFC compliance   */
var chrsz   = 8;  /* bits per input character. 8 - ASCII; 16 - Unicode      */

/*
 * These are the functions you&apos;ll usually want to call
 * They take string arguments and return either hex or base-64 encoded strings
 */
function hex_sha1(s){return binb2hex(core_sha1(str2binb(s),s.length * chrsz));}
function b64_sha1(s){return binb2b64(core_sha1(str2binb(s),s.length * chrsz));}
function str_sha1(s){return binb2str(core_sha1(str2binb(s),s.length * chrsz));}
function hex_hmac_sha1(key, data){ return binb2hex(core_hmac_sha1(key, data));}
function b64_hmac_sha1(key, data){ return binb2b64(core_hmac_sha1(key, data));}
function str_hmac_sha1(key, data){ return binb2str(core_hmac_sha1(key, data));}

/*
 * Perform a simple self-test to see if the VM is working
 */
function sha1_vm_test()
{
  return hex_sha1(&quot;abc&quot;) == &quot;a9993e364706816aba3e25717850c26c9cd0d89d&quot;;
}

/*
 * Calculate the SHA-1 of an array of big-endian words, and a bit length
 */
function core_sha1(x, len)
{
  /* append padding */
  x[len &gt;&gt; 5] |= 0x80 &lt;&lt; (24 - len % 32);
  x[((len + 64 &gt;&gt; 9) &lt;&lt; 4) + 15] = len;

  var w = Array(80);
  var a =  1732584193;
  var b = -271733879;
  var c = -1732584194;
  var d =  271733878;
  var e = -1009589776;

  for(var i = 0; i &lt; x.length; i += 16)
  {
    var olda = a;
    var oldb = b;
    var oldc = c;
    var oldd = d;
    var olde = e;

    for(var j = 0; j &lt; 80; j++)
    {
      if(j &lt; 16) w[j] = x[i + j];
      else w[j] = rol(w[j-3] ^ w[j-8] ^ w[j-14] ^ w[j-16], 1);
      var t = safe_add(safe_add(rol(a, 5), sha1_ft(j, b, c, d)),
                       safe_add(safe_add(e, w[j]), sha1_kt(j)));
      e = d;
      d = c;
      c = rol(b, 30);
      b = a;
      a = t;
    }

    a = safe_add(a, olda);
    b = safe_add(b, oldb);
    c = safe_add(c, oldc);
    d = safe_add(d, oldd);
    e = safe_add(e, olde);
  }
  return Array(a, b, c, d, e);

}

/*
 * Perform the appropriate triplet combination function for the current
 * iteration
 */
function sha1_ft(t, b, c, d)
{
  if(t &lt; 20) return (b &amp; c) | ((~b) &amp; d);
  if(t &lt; 40) return b ^ c ^ d;
  if(t &lt; 60) return (b &amp; c) | (b &amp; d) | (c &amp; d);
  return b ^ c ^ d;
}

/*
 * Determine the appropriate additive constant for the current iteration
 */
function sha1_kt(t)
{
  return (t &lt; 20) ?  1518500249 : (t &lt; 40) ?  1859775393 :
         (t &lt; 60) ? -1894007588 : -899497514;
}

/*
 * Calculate the HMAC-SHA1 of a key and some data
 */
function core_hmac_sha1(key, data)
{
  var bkey = str2binb(key);
  if(bkey.length &gt; 16) bkey = core_sha1(bkey, key.length * chrsz);

  var ipad = Array(16), opad = Array(16);
  for(var i = 0; i &lt; 16; i++)
  {
    ipad[i] = bkey[i] ^ 0x36363636;
    opad[i] = bkey[i] ^ 0x5C5C5C5C;
  }

  var hash = core_sha1(ipad.concat(str2binb(data)), 512 + data.length * chrsz);
  return core_sha1(opad.concat(hash), 512 + 160);
}

/*
 * Add integers, wrapping at 2^32. This uses 16-bit operations internally
 * to work around bugs in some JS interpreters.
 */
function safe_add(x, y)
{
  var lsw = (x &amp; 0xFFFF) + (y &amp; 0xFFFF);
  var msw = (x &gt;&gt; 16) + (y &gt;&gt; 16) + (lsw &gt;&gt; 16);
  return (msw &lt;&lt; 16) | (lsw &amp; 0xFFFF);
}

/*
 * Bitwise rotate a 32-bit number to the left.
 */
function rol(num, cnt)
{
  return (num &lt;&lt; cnt) | (num &gt;&gt;&gt; (32 - cnt));
}

/*
 * Convert an 8-bit or 16-bit string to an array of big-endian words
 * In 8-bit function, characters &gt;255 have their hi-byte silently ignored.
 */
function str2binb(str)
{
  var bin = Array();
  var mask = (1 &lt;&lt; chrsz) - 1;
  for(var i = 0; i &lt; str.length * chrsz; i += chrsz)
    bin[i&gt;&gt;5] |= (str.charCodeAt(i / chrsz) &amp; mask) &lt;&lt; (32 - chrsz - i%32);
  return bin;
}

/*
 * Convert an array of big-endian words to a string
 */
function binb2str(bin)
{
  var str = &quot;&quot;;
  var mask = (1 &lt;&lt; chrsz) - 1;
  for(var i = 0; i &lt; bin.length * 32; i += chrsz)
    str += String.fromCharCode((bin[i&gt;&gt;5] &gt;&gt;&gt; (32 - chrsz - i%32)) &amp; mask);
  return str;
}

/*
 * Convert an array of big-endian words to a hex string.
 */
function binb2hex(binarray)
{
  var hex_tab = hexcase ? &quot;0123456789ABCDEF&quot; : &quot;0123456789abcdef&quot;;
  var str = &quot;&quot;;
  for(var i = 0; i &lt; binarray.length * 4; i++)
  {
    str += hex_tab.charAt((binarray[i&gt;&gt;2] &gt;&gt; ((3 - i%4)*8+4)) &amp; 0xF) +
           hex_tab.charAt((binarray[i&gt;&gt;2] &gt;&gt; ((3 - i%4)*8  )) &amp; 0xF);
  }
  return str;
}

/*
 * Convert an array of big-endian words to a base-64 string
 */
function binb2b64(binarray)
{
  var tab = &quot;ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/&quot;;
  var str = &quot;&quot;;
  for(var i = 0; i &lt; binarray.length * 4; i += 3)
  {
    var triplet = (((binarray[i   &gt;&gt; 2] &gt;&gt; 8 * (3 -  i   %4)) &amp; 0xFF) &lt;&lt; 16)
                | (((binarray[i+1 &gt;&gt; 2] &gt;&gt; 8 * (3 - (i+1)%4)) &amp; 0xFF) &lt;&lt; 8 )
                |  ((binarray[i+2 &gt;&gt; 2] &gt;&gt; 8 * (3 - (i+2)%4)) &amp; 0xFF);
    for(var j = 0; j &lt; 4; j++)
    {
      if(i * 8 + j * 6 &gt; binarray.length * 32) str += b64pad;
      else str += tab.charAt((triplet &gt;&gt; 6*(3-j)) &amp; 0x3F);
    }
  }
  return str;
}

/*
 * Copyright 2008 Netflix, Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/* Here&apos;s some JavaScript software for implementing OAuth.

   This isn&apos;t as useful as you might hope.  OAuth is based around
   allowing tools and websites to talk to each other.  However,
   JavaScript running in web browsers is hampered by security
   restrictions that prevent code running on one website from
   accessing data stored or served on another.

   Before you start hacking, make sure you understand the limitations
   posed by cross-domain XMLHttpRequest.

   On the bright side, some platforms use JavaScript as their
   language, but enable the programmer to access other web sites.
   Examples include Google Gadgets, and Microsoft Vista Sidebar.
   For those platforms, this library should come in handy.
*/

// The HMAC-SHA1 signature method calls b64_hmac_sha1, defined by
// http://pajhome.org.uk/crypt/md5/sha1.js

/* An OAuth message is represented as an object like this:
   {method: &quot;GET&quot;, action: &quot;http://server.com/path&quot;, parameters: ...}

   The parameters may be either a map {name: value, name2: value2}
   or an Array of name-value pairs [[name, value], [name2, value2]].
   The latter representation is more powerful: it supports parameters
   in a specific sequence, or several parameters with the same name;
   for example [[&quot;a&quot;, 1], [&quot;b&quot;, 2], [&quot;a&quot;, 3]].

   Parameter names and values are NOT percent-encoded in an object.
   They must be encoded before transmission and decoded after reception.
   For example, this message object:
   {method: &quot;GET&quot;, action: &quot;http://server/path&quot;, parameters: {p: &quot;x y&quot;}}
   ... can be transmitted as an HTTP request that begins:
   GET /path?p=x%20y HTTP/1.0
   (This isn&apos;t a valid OAuth request, since it lacks a signature etc.)
   Note that the object &quot;x y&quot; is transmitted as x%20y.  To encode
   parameters, you can call OAuth.addToURL, OAuth.formEncode or
   OAuth.getAuthorization.

   This message object model harmonizes with the browser object model for
   input elements of an form, whose value property isn&apos;t percent encoded.
   The browser encodes each value before transmitting it. For example,
   see consumer.setInputs in example/consumer.js.
 */

/* This script needs to know what time it is. By default, it uses the local
   clock (new Date), which is apt to be inaccurate in browsers. To do
   better, you can load this script from a URL whose query string contains
   an oauth_timestamp parameter, whose value is a current Unix timestamp.
   For example, when generating the enclosing document using PHP:

   &lt;script src=&quot;oauth.js?oauth_timestamp=&lt;?=time()?&gt;&quot; ...

   Another option is to call OAuth.correctTimestamp with a Unix timestamp.
 */

var OAuth; if (OAuth == null) OAuth = {};

OAuth.setProperties = function setProperties(into, from) {
    if (into != null &amp;&amp; from != null) {
        for (var key in from) {
            into[key] = from[key];
        }
    }
    return into;
}

OAuth.setProperties(OAuth, // utility functions
{
    percentEncode: function percentEncode(s) {
        if (s == null) {
            return &quot;&quot;;
        }
        if (s instanceof Array) {
            var e = &quot;&quot;;
            for (var i = 0; i &lt; s.length; ++s) {
                if (e != &quot;&quot;) e += &apos;&amp;&apos;;
                e += OAuth.percentEncode(s[i]);
            }
            return e;
        }
        s = encodeURIComponent(s);
        // Now replace the values which encodeURIComponent doesn&apos;t do
        // encodeURIComponent ignores: - _ . ! ~ * &apos; ( )
        // OAuth dictates the only ones you can ignore are: - _ . ~
        // Source: http://developer.mozilla.org/en/docs/Core_JavaScript_1.5_Reference:Global_Functions:encodeURIComponent
        s = s.replace(/\!/g, &quot;%21&quot;);
        s = s.replace(/\*/g, &quot;%2A&quot;);
        s = s.replace(/\&apos;/g, &quot;%27&quot;);
        s = s.replace(/\(/g, &quot;%28&quot;);
        s = s.replace(/\)/g, &quot;%29&quot;);
        return s;
    }
,
    decodePercent: function decodePercent(s) {
        if (s != null) {
            // Handle application/x-www-form-urlencoded, which is defined by
            // http://www.w3.org/TR/html4/interact/forms.html#h-17.13.4.1
            s = s.replace(/\+/g, &quot; &quot;);
        }
        return decodeURIComponent(s);
    }
,
    /** Convert the given parameters to an Array of name-value pairs. */
    getParameterList: function getParameterList(parameters) {
        if (parameters == null) {
            return [];
        }
        if (typeof parameters != &quot;object&quot;) {
            return OAuth.decodeForm(parameters + &quot;&quot;);
        }
        if (parameters instanceof Array) {
            return parameters;
        }
        var list = [];
        for (var p in parameters) {
            list.push([p, parameters[p]]);
        }
        return list;
    }
,
    /** Convert the given parameters to a map from name to value. */
    getParameterMap: function getParameterMap(parameters) {
        if (parameters == null) {
            return {};
        }
        if (typeof parameters != &quot;object&quot;) {
            return OAuth.getParameterMap(OAuth.decodeForm(parameters + &quot;&quot;));
        }
        if (parameters instanceof Array) {
            var map = {};
            for (var p = 0; p &lt; parameters.length; ++p) {
                var key = parameters[p][0];
                if (map[key] === undefined) { // first value wins
                    map[key] = parameters[p][1];
                }
            }
            return map;
        }
        return parameters;
    }
,
    getParameter: function getParameter(parameters, name) {
        if (parameters instanceof Array) {
            for (var p = 0; p &lt; parameters.length; ++p) {
                if (parameters[p][0] == name) {
                    return parameters[p][1]; // first value wins
                }
            }
        } else {
            return OAuth.getParameterMap(parameters)[name];
        }
        return null;
    }
,
    formEncode: function formEncode(parameters) {
        var form = &quot;&quot;;
        var list = OAuth.getParameterList(parameters);
        for (var p = 0; p &lt; list.length; ++p) {
            var value = list[p][1];
            if (value == null) value = &quot;&quot;;
            if (form != &quot;&quot;) form += &apos;&amp;&apos;;
            form += OAuth.percentEncode(list[p][0])
              +&apos;=&apos;+ OAuth.percentEncode(value);
        }
        return form;
    }
,
    decodeForm: function decodeForm(form) {
        var list = [];
        var nvps = form.split(&apos;&amp;&apos;);
        for (var n = 0; n &lt; nvps.length; ++n) {
            var nvp = nvps[n];
            if (nvp == &quot;&quot;) {
                continue;
            }
            var equals = nvp.indexOf(&apos;=&apos;);
            var name;
            var value;
            if (equals &lt; 0) {
                name = OAuth.decodePercent(nvp);
                value = null;
            } else {
                name = OAuth.decodePercent(nvp.substring(0, equals));
                value = OAuth.decodePercent(nvp.substring(equals + 1));
            }
            list.push([name, value]);
        }
        return list;
    }
,
    setParameter: function setParameter(message, name, value) {
        var parameters = message.parameters;
        if (parameters instanceof Array) {
            for (var p = 0; p &lt; parameters.length; ++p) {
                if (parameters[p][0] == name) {
                    if (value === undefined) {
                        parameters.splice(p, 1);
                    } else {
                        parameters[p][1] = value;
                        value = undefined;
                    }
                }
            }
            if (value !== undefined) {
                parameters.push([name, value]);
            }
        } else {
            parameters = OAuth.getParameterMap(parameters);
            parameters[name] = value;
            message.parameters = parameters;
        }
    }
,
    setParameters: function setParameters(message, parameters) {
        var list = OAuth.getParameterList(parameters);
        for (var i = 0; i &lt; list.length; ++i) {
            OAuth.setParameter(message, list[i][0], list[i][1]);
        }
    }
,
    /** Fill in parameters to help construct a request message.
        This function doesn&apos;t fill in every parameter.
        The accessor object should be like:
        {consumerKey:&apos;foo&apos;, consumerSecret:&apos;bar&apos;, accessorSecret:&apos;nurn&apos;, token:&apos;krelm&apos;, tokenSecret:&apos;blah&apos;}
        The accessorSecret property is optional.
     */
    completeRequest: function completeRequest(message, accessor) {
        if (message.method == null) {
            message.method = &quot;GET&quot;;
        }
        var map = OAuth.getParameterMap(message.parameters);
        if (map.oauth_consumer_key == null) {
            OAuth.setParameter(message, &quot;oauth_consumer_key&quot;, accessor.consumerKey || &quot;&quot;);
        }
        if (map.oauth_token == null &amp;&amp; accessor.token != null) {
            OAuth.setParameter(message, &quot;oauth_token&quot;, accessor.token);
        }
        if (map.oauth_version == null) {
            OAuth.setParameter(message, &quot;oauth_version&quot;, &quot;1.0&quot;);
        }
        if (map.oauth_timestamp == null) {
            OAuth.setParameter(message, &quot;oauth_timestamp&quot;, OAuth.timestamp());
        }
        if (map.oauth_nonce == null) {
            OAuth.setParameter(message, &quot;oauth_nonce&quot;, OAuth.nonce(6));
        }
        OAuth.SignatureMethod.sign(message, accessor);
    }
,
    setTimestampAndNonce: function setTimestampAndNonce(message) {
        OAuth.setParameter(message, &quot;oauth_timestamp&quot;, OAuth.timestamp());
        OAuth.setParameter(message, &quot;oauth_nonce&quot;, OAuth.nonce(6));
    }
,
    addToURL: function addToURL(url, parameters) {
        newURL = url;
        if (parameters != null) {
            var toAdd = OAuth.formEncode(parameters);
            if (toAdd.length &gt; 0) {
                var q = url.indexOf(&apos;?&apos;);
                if (q &lt; 0) newURL += &apos;?&apos;;
                else       newURL += &apos;&amp;&apos;;
                newURL += toAdd;
            }
        }
        return newURL;
    }
,
    /** Construct the value of the Authorization header for an HTTP request. */
    getAuthorizationHeader: function getAuthorizationHeader(realm, parameters) {
        var header = &apos;OAuth realm=&quot;&apos; + OAuth.percentEncode(realm) + &apos;&quot;&apos;;
        var list = OAuth.getParameterList(parameters);
        for (var p = 0; p &lt; list.length; ++p) {
            var parameter = list[p];
            var name = parameter[0];
            if (name.indexOf(&quot;oauth_&quot;) == 0) {
                header += &apos;,&apos; + OAuth.percentEncode(name) + &apos;=&quot;&apos; + OAuth.percentEncode(parameter[1]) + &apos;&quot;&apos;;
            }
        }
        return header;
    }
,
    /** Correct the time using a parameter from the URL from which the last script was loaded. */
    correctTimestampFromSrc: function correctTimestampFromSrc(parameterName) {
        parameterName = parameterName || &quot;oauth_timestamp&quot;;
        var scripts = document.getElementsByTagName(&apos;script&apos;);
        if (scripts == null || !scripts.length) return;
        var src = scripts[scripts.length-1].src;
        if (!src) return;
        var q = src.indexOf(&quot;?&quot;);
        if (q &lt; 0) return;
        parameters = OAuth.getParameterMap(OAuth.decodeForm(src.substring(q+1)));
        var t = parameters[parameterName];
        if (t == null) return;
        OAuth.correctTimestamp(t);
    }
,
    /** Generate timestamps starting with the given value. */
    correctTimestamp: function correctTimestamp(timestamp) {
        OAuth.timeCorrectionMsec = (timestamp * 1000) - (new Date()).getTime();
    }
,
    /** The difference between the correct time and my clock. */
    timeCorrectionMsec: 0
,
    timestamp: function timestamp() {
        var t = (new Date()).getTime() + OAuth.timeCorrectionMsec;
        return Math.floor(t / 1000);
    }
,
    nonce: function nonce(length) {
        var chars = OAuth.nonce.CHARS;
        var result = &quot;&quot;;
        for (var i = 0; i &lt; length; ++i) {
            var rnum = Math.floor(Math.random() * chars.length);
            result += chars.substring(rnum, rnum+1);
        }
        return result;
    }
});

OAuth.nonce.CHARS = &quot;0123456789ABCDEFGHIJKLMNOPQRSTUVWXTZabcdefghiklmnopqrstuvwxyz&quot;;

/** Define a constructor function,
    without causing trouble to anyone who was using it as a namespace.
    That is, if parent[name] already existed and had properties,
    copy those properties into the new constructor.
 */
OAuth.declareClass = function declareClass(parent, name, newConstructor) {
    var previous = parent[name];
    parent[name] = newConstructor;
    if (newConstructor != null &amp;&amp; previous != null) {
        for (var key in previous) {
            if (key != &quot;prototype&quot;) {
                newConstructor[key] = previous[key];
            }
        }
    }
    return newConstructor;
}

/** An abstract algorithm for signing messages. */
OAuth.declareClass(OAuth, &quot;SignatureMethod&quot;, function OAuthSignatureMethod(){});

OAuth.setProperties(OAuth.SignatureMethod.prototype, // instance members
{
    /** Add a signature to the message. */
    sign: function sign(message) {
        var baseString = OAuth.SignatureMethod.getBaseString(message);
        var signature = this.getSignature(baseString);
        OAuth.setParameter(message, &quot;oauth_signature&quot;, signature);
        return signature; // just in case someone&apos;s interested
    }
,
    /** Set the key string for signing. */
    initialize: function initialize(name, accessor) {
        var consumerSecret;
        if (accessor.accessorSecret != null
            &amp;&amp; name.length &gt; 9
            &amp;&amp; name.substring(name.length-9) == &quot;-Accessor&quot;)
        {
            consumerSecret = accessor.accessorSecret;
        } else {
            consumerSecret = accessor.consumerSecret;
        }
        this.key = OAuth.percentEncode(consumerSecret)
             +&quot;&amp;&quot;+ OAuth.percentEncode(accessor.tokenSecret);
    }
});

/* SignatureMethod expects an accessor object to be like this:
   {tokenSecret: &quot;lakjsdflkj...&quot;, consumerSecret: &quot;QOUEWRI..&quot;, accessorSecret: &quot;xcmvzc...&quot;}
   The accessorSecret property is optional.
 */
// Class members:
OAuth.setProperties(OAuth.SignatureMethod, // class members
{
    sign: function sign(message, accessor) {
        var name = OAuth.getParameterMap(message.parameters).oauth_signature_method;
        if (name == null || name == &quot;&quot;) {
            name = &quot;HMAC-SHA1&quot;;
            OAuth.setParameter(message, &quot;oauth_signature_method&quot;, name);
        }
        OAuth.SignatureMethod.newMethod(name, accessor).sign(message);
    }
,
    /** Instantiate a SignatureMethod for the given method name. */
    newMethod: function newMethod(name, accessor) {
        var impl = OAuth.SignatureMethod.REGISTERED[name];
        if (impl != null) {
            var method = new impl();
            method.initialize(name, accessor);
            return method;
        }
        var err = new Error(&quot;signature_method_rejected&quot;);
        var acceptable = &quot;&quot;;
        for (var r in OAuth.SignatureMethod.REGISTERED) {
            if (acceptable != &quot;&quot;) acceptable += &apos;&amp;&apos;;
            acceptable += OAuth.percentEncode(r);
        }
        err.oauth_acceptable_signature_methods = acceptable;
        throw err;
    }
,
    /** A map from signature method name to constructor. */
    REGISTERED : {}
,
    /** Subsequently, the given constructor will be used for the named methods.
        The constructor will be called with no parameters.
        The resulting object should usually implement getSignature(baseString).
        You can easily define such a constructor by calling makeSubclass, below.
     */
    registerMethodClass: function registerMethodClass(names, classConstructor) {
        for (var n = 0; n &lt; names.length; ++n) {
            OAuth.SignatureMethod.REGISTERED[names[n]] = classConstructor;
        }
    }
,
    /** Create a subclass of OAuth.SignatureMethod, with the given getSignature function. */
    makeSubclass: function makeSubclass(getSignatureFunction) {
        var superClass = OAuth.SignatureMethod;
        var subClass = function() {
            superClass.call(this);
        };
        subClass.prototype = new superClass();
        // Delete instance variables from prototype:
        // delete subclass.prototype... There aren&apos;t any.
        subClass.prototype.getSignature = getSignatureFunction;
        subClass.prototype.constructor = subClass;
        return subClass;
    }
,
    getBaseString: function getBaseString(message) {
        var URL = message.action;
        var q = URL.indexOf(&apos;?&apos;);
        var parameters;
        if (q &lt; 0) {
            parameters = message.parameters;
        } else {
            // Combine the URL query string with the other parameters:
            parameters = OAuth.decodeForm(URL.substring(q + 1));
            var toAdd = OAuth.getParameterList(message.parameters);
            for (var a = 0; a &lt; toAdd.length; ++a) {
                parameters.push(toAdd[a]);
            }
        }
        return OAuth.percentEncode(message.method.toUpperCase())
         +&apos;&amp;&apos;+ OAuth.percentEncode(OAuth.SignatureMethod.normalizeUrl(URL))
         +&apos;&amp;&apos;+ OAuth.percentEncode(OAuth.SignatureMethod.normalizeParameters(parameters));
    }
,
    normalizeUrl: function normalizeUrl(url) {
        var uri = OAuth.SignatureMethod.parseUri(url);
        var scheme = uri.protocol.toLowerCase();
        var authority = uri.authority.toLowerCase();
        var dropPort = (scheme == &quot;http&quot; &amp;&amp; uri.port == 80)
                    || (scheme == &quot;https&quot; &amp;&amp; uri.port == 443);
        if (dropPort) {
            // find the last : in the authority
            var index = authority.lastIndexOf(&quot;:&quot;);
            if (index &gt;= 0) {
                authority = authority.substring(0, index);
            }
        }
        var path = uri.path;
        if (!path) {
            path = &quot;/&quot;; // conforms to RFC 2616 section 3.2.2
        }
        // we know that there is no query and no fragment here.
        return scheme + &quot;://&quot; + authority + path;
    }
,
    parseUri: function parseUri (str) {
        /* This function was adapted from parseUri 1.2.1
           http://stevenlevithan.com/demo/parseuri/js/assets/parseuri.js
         */
        var o = {key: [&quot;source&quot;,&quot;protocol&quot;,&quot;authority&quot;,&quot;userInfo&quot;,&quot;user&quot;,&quot;password&quot;,&quot;host&quot;,&quot;port&quot;,&quot;relative&quot;,&quot;path&quot;,&quot;directory&quot;,&quot;file&quot;,&quot;query&quot;,&quot;anchor&quot;],
                 parser: {strict: /^(?:([^:\/?#]+):)?(?:\/\/((?:(([^:@\/]*):?([^:@\/]*))?@)?([^:\/?#]*)(?::(\d*))?))?((((?:[^?#\/]*\/)*)([^?#]*))(?:\?([^#]*))?(?:#(.*))?)/ }};
        var m = o.parser.strict.exec(str);
        var uri = {};
        var i = 14;
        while (i--) uri[o.key[i]] = m[i] || &quot;&quot;;
        return uri;
    }
,
    normalizeParameters: function normalizeParameters(parameters) {
        if (parameters == null) {
            return &quot;&quot;;
        }
        var list = OAuth.getParameterList(parameters);
        var sortable = [];
        for (var p = 0; p &lt; list.length; ++p) {
            var nvp = list[p];
            if (nvp[0] != &quot;oauth_signature&quot;) {
                sortable.push([ OAuth.percentEncode(nvp[0])
                              + &quot; &quot; // because it comes before any character that can appear in a percentEncoded string.
                              + OAuth.percentEncode(nvp[1])
                              , nvp]);
            }
        }
        sortable.sort(function(a,b) {
                          if (a[0] &lt; b[0]) return  -1;
                          if (a[0] &gt; b[0]) return 1;
                          return 0;
                      });
        var sorted = [];
        for (var s = 0; s &lt; sortable.length; ++s) {
            sorted.push(sortable[s][1]);
        }
        return OAuth.formEncode(sorted);
    }
});

OAuth.SignatureMethod.registerMethodClass([&quot;PLAINTEXT&quot;, &quot;PLAINTEXT-Accessor&quot;],
    OAuth.SignatureMethod.makeSubclass(
        function getSignature(baseString) {
            return this.key;
        }
    ));

OAuth.SignatureMethod.registerMethodClass([&quot;HMAC-SHA1&quot;, &quot;HMAC-SHA1-Accessor&quot;],
    OAuth.SignatureMethod.makeSubclass(
        function getSignature(baseString) {
            b64pad = &apos;=&apos;;
            var signature = b64_hmac_sha1(this.key, baseString);
            return signature;
        }
    ));

try {
    OAuth.correctTimestampFromSrc();
} catch(e) {
}


//--------------------------------------------------

var consumerKey = &quot;${consumer_key}&quot;;
var consumerSecret = &quot;${consumer_secret}&quot;;
var params = [];
var query = [];
query.push(&apos;access_token&apos; + &apos;=&apos; + &apos;${access_token}&apos;);
query.push(&apos;id_token&apos; + &apos;=&apos; + &apos;${id_token}&apos;);
var url =  &quot;${protocol}://${misp_url}/marvelous/people/@me/@self&quot;;

if (query.length) {
    url += &apos;?&apos; + query.join(&apos;&amp;&apos;);
}

var message = {
    method: &apos;put&apos;,
    parameters: params, 
    action: url
};

log.info(url);
log.info(consumerSecret);

var accessor = {
    consumerKey: consumerKey,
    consumerSecret: consumerSecret,
    token:  &apos;${access_token}&apos;,
    tokenSecret: &apos;${id_token}&apos;
};

OAuth.completeRequest(message, accessor);
vars.put(&apos;put_auth_header&apos;, OAuth.getAuthorizationHeader(&apos;&apos;, params).replace(&apos;OAuth realm=&quot;&quot;,&apos;, &apos; OAuth &apos;));
</stringProp>
            <stringProp name="scriptLanguage">javascript</stringProp>
          </BSFPreProcessor>
          <hashTree/>
          <HeaderManager guiclass="HeaderPanel" testclass="HeaderManager" testname="HTTP ヘッダマネージャ" enabled="true">
            <collectionProp name="HeaderManager.headers">
              <elementProp name="" elementType="Header">
                <stringProp name="Header.name">Authorization</stringProp>
                <stringProp name="Header.value">${put_auth_header}</stringProp>
              </elementProp>
              <elementProp name="" elementType="Header">
                <stringProp name="Header.name">content-type</stringProp>
                <stringProp name="Header.value">application/json; charset=utf8</stringProp>
              </elementProp>
              <elementProp name="" elementType="Header">
                <stringProp name="Header.name">Connection</stringProp>
                <stringProp name="Header.value">close</stringProp>
              </elementProp>
              <elementProp name="" elementType="Header">
                <stringProp name="Header.name">Accept-encoding</stringProp>
                <stringProp name="Header.value">gzip, deflate</stringProp>
              </elementProp>
            </collectionProp>
          </HeaderManager>
          <hashTree/>
          <ResponseAssertion guiclass="AssertionGui" testclass="ResponseAssertion" testname="アサーション" enabled="true">
            <collectionProp name="Asserion.test_strings">
              <stringProp name="-820239147">&quot;password&quot;:&quot;&quot;</stringProp>
            </collectionProp>
            <stringProp name="TestPlan.comments">確認項目
パスワードが空になっていないか？</stringProp>
            <stringProp name="Assertion.test_field">Assertion.response_data</stringProp>
            <boolProp name="Assertion.assume_success">false</boolProp>
            <intProp name="Assertion.test_type">6</intProp>
          </ResponseAssertion>
          <hashTree/>
          <RegexExtractor guiclass="RegexExtractorGui" testclass="RegexExtractor" testname="access_token" enabled="true">
            <stringProp name="RegexExtractor.useHeaders">false</stringProp>
            <stringProp name="RegexExtractor.refname">access_token</stringProp>
            <stringProp name="RegexExtractor.regex">&quot;accessToken&quot;:&quot;(.*?)&quot;</stringProp>
            <stringProp name="RegexExtractor.template">$1$</stringProp>
            <stringProp name="RegexExtractor.default"></stringProp>
            <stringProp name="RegexExtractor.match_number">1</stringProp>
          </RegexExtractor>
          <hashTree/>
          <RegexExtractor guiclass="RegexExtractorGui" testclass="RegexExtractor" testname="id_token" enabled="true">
            <stringProp name="RegexExtractor.useHeaders">false</stringProp>
            <stringProp name="RegexExtractor.refname">id_token</stringProp>
            <stringProp name="RegexExtractor.regex">&quot;idToken&quot;:&quot;(.*?)&quot;</stringProp>
            <stringProp name="RegexExtractor.template">$1$</stringProp>
            <stringProp name="RegexExtractor.default"></stringProp>
            <stringProp name="RegexExtractor.match_number">1</stringProp>
          </RegexExtractor>
          <hashTree/>
        </hashTree>
        <HTTPSamplerProxy guiclass="HttpTestSampleGui" testclass="HTTPSamplerProxy" testname="Basic.MISP連携一覧画面(Dummy2のアクセストークンで連携)" enabled="true">
          <elementProp name="HTTPsampler.Arguments" elementType="Arguments" guiclass="HTTPArgumentsPanel" testclass="Arguments" enabled="true">
            <collectionProp name="Arguments.arguments">
              <elementProp name="response_type" elementType="HTTPArgument">
                <boolProp name="HTTPArgument.always_encode">false</boolProp>
                <stringProp name="Argument.name">response_type</stringProp>
                <stringProp name="Argument.value">code</stringProp>
                <stringProp name="Argument.metadata">=</stringProp>
                <boolProp name="HTTPArgument.use_equals">true</boolProp>
              </elementProp>
              <elementProp name="client_id" elementType="HTTPArgument">
                <boolProp name="HTTPArgument.always_encode">false</boolProp>
                <stringProp name="Argument.name">client_id</stringProp>
                <stringProp name="Argument.value">00000</stringProp>
                <stringProp name="Argument.metadata">=</stringProp>
                <boolProp name="HTTPArgument.use_equals">true</boolProp>
              </elementProp>
              <elementProp name="redirect_uri" elementType="HTTPArgument">
                <boolProp name="HTTPArgument.always_encode">false</boolProp>
                <stringProp name="Argument.name">redirect_uri</stringProp>
                <stringProp name="Argument.value">${protocol}%3A%2F%2F${jmeter_path}%2Ftest%2Fmisp%2Fmisp-callback</stringProp>
                <stringProp name="Argument.metadata">=</stringProp>
                <boolProp name="HTTPArgument.use_equals">true</boolProp>
              </elementProp>
              <elementProp name="scope" elementType="HTTPArgument">
                <boolProp name="HTTPArgument.always_encode">false</boolProp>
                <stringProp name="Argument.name">scope</stringProp>
                <stringProp name="Argument.value">openid</stringProp>
                <stringProp name="Argument.metadata">=</stringProp>
                <boolProp name="HTTPArgument.use_equals">true</boolProp>
              </elementProp>
              <elementProp name="state" elementType="HTTPArgument">
                <boolProp name="HTTPArgument.always_encode">false</boolProp>
                <stringProp name="Argument.name">state</stringProp>
                <stringProp name="Argument.value">ddd</stringProp>
                <stringProp name="Argument.metadata">=</stringProp>
                <boolProp name="HTTPArgument.use_equals">true</boolProp>
              </elementProp>
              <elementProp name="nonce" elementType="HTTPArgument">
                <boolProp name="HTTPArgument.always_encode">false</boolProp>
                <stringProp name="Argument.name">nonce</stringProp>
                <stringProp name="Argument.value">nnnnonce</stringProp>
                <stringProp name="Argument.metadata">=</stringProp>
                <boolProp name="HTTPArgument.use_equals">true</boolProp>
              </elementProp>
              <elementProp name="access_token" elementType="HTTPArgument">
                <boolProp name="HTTPArgument.always_encode">false</boolProp>
                <stringProp name="Argument.value">${access_token}</stringProp>
                <stringProp name="Argument.metadata">=</stringProp>
                <boolProp name="HTTPArgument.use_equals">true</boolProp>
                <stringProp name="Argument.name">access_token</stringProp>
              </elementProp>
              <elementProp name="id_token" elementType="HTTPArgument">
                <boolProp name="HTTPArgument.always_encode">false</boolProp>
                <stringProp name="Argument.value">${id_token}</stringProp>
                <stringProp name="Argument.metadata">=</stringProp>
                <boolProp name="HTTPArgument.use_equals">true</boolProp>
                <stringProp name="Argument.name">id_token</stringProp>
              </elementProp>
            </collectionProp>
          </elementProp>
          <stringProp name="HTTPSampler.domain"></stringProp>
          <stringProp name="HTTPSampler.port"></stringProp>
          <stringProp name="HTTPSampler.connect_timeout"></stringProp>
          <stringProp name="HTTPSampler.response_timeout"></stringProp>
          <stringProp name="HTTPSampler.protocol"></stringProp>
          <stringProp name="HTTPSampler.contentEncoding"></stringProp>
          <stringProp name="HTTPSampler.path">/marvelous/authorization/login</stringProp>
          <stringProp name="HTTPSampler.method">GET</stringProp>
          <boolProp name="HTTPSampler.follow_redirects">true</boolProp>
          <boolProp name="HTTPSampler.auto_redirects">false</boolProp>
          <boolProp name="HTTPSampler.use_keepalive">true</boolProp>
          <boolProp name="HTTPSampler.DO_MULTIPART_POST">false</boolProp>
          <boolProp name="HTTPSampler.monitor">false</boolProp>
          <stringProp name="HTTPSampler.embedded_url_re"></stringProp>
          <stringProp name="TestPlan.comments">Dummy1はDummy2連携時に連携は解除されている</stringProp>
        </HTTPSamplerProxy>
        <hashTree>
          <RegexExtractor guiclass="RegexExtractorGui" testclass="RegexExtractor" testname="response_type_params1" enabled="true">
            <stringProp name="RegexExtractor.useHeaders">false</stringProp>
            <stringProp name="RegexExtractor.refname">response_type_params1</stringProp>
            <stringProp name="RegexExtractor.regex">response_type=(.*?)&quot; data-cancelidfederation</stringProp>
            <stringProp name="RegexExtractor.template">$1$</stringProp>
            <stringProp name="RegexExtractor.default"></stringProp>
            <stringProp name="RegexExtractor.match_number">1</stringProp>
          </RegexExtractor>
          <hashTree/>
          <RegexExtractor guiclass="RegexExtractorGui" testclass="RegexExtractor" testname="response_type_params2" enabled="true">
            <stringProp name="RegexExtractor.useHeaders">false</stringProp>
            <stringProp name="RegexExtractor.refname">response_type_params2</stringProp>
            <stringProp name="RegexExtractor.regex">response_type=(.*?)&quot; data-cancelidfederation</stringProp>
            <stringProp name="RegexExtractor.template">$1$</stringProp>
            <stringProp name="RegexExtractor.default"></stringProp>
            <stringProp name="RegexExtractor.match_number">2</stringProp>
          </RegexExtractor>
          <hashTree/>
          <ResponseAssertion guiclass="AssertionGui" testclass="ResponseAssertion" testname="アサーション" enabled="true">
            <collectionProp name="Asserion.test_strings">
              <stringProp name="249363884">platform_id=Dummy2&quot; data-login=&quot;true&quot; checked&gt;</stringProp>
              <stringProp name="1417515813">platform_id=Dummy1&quot; data-login=&quot;false&quot; &gt;</stringProp>
            </collectionProp>
            <stringProp name="TestPlan.comments">確認項目
1.ユーザID統合された画面が表示されているか
2.最終ログインのプラットフォームに、ログイン状態のフラグが立っているか
3.複数プラットフォームが選択されているか</stringProp>
            <stringProp name="Assertion.test_field">Assertion.response_data</stringProp>
            <boolProp name="Assertion.assume_success">false</boolProp>
            <intProp name="Assertion.test_type">2</intProp>
          </ResponseAssertion>
          <hashTree/>
        </hashTree>
        <HTTPSamplerProxy guiclass="HttpTestSampleGui" testclass="HTTPSamplerProxy" testname="Implicit.MISP連携一覧画面(Dummy2のアクセストークンで連携)" enabled="true">
          <elementProp name="HTTPsampler.Arguments" elementType="Arguments" guiclass="HTTPArgumentsPanel" testclass="Arguments" enabled="true">
            <collectionProp name="Arguments.arguments">
              <elementProp name="response_type" elementType="HTTPArgument">
                <boolProp name="HTTPArgument.always_encode">false</boolProp>
                <stringProp name="Argument.name">response_type</stringProp>
                <stringProp name="Argument.value">id_token+token</stringProp>
                <stringProp name="Argument.metadata">=</stringProp>
                <boolProp name="HTTPArgument.use_equals">true</boolProp>
              </elementProp>
              <elementProp name="client_id" elementType="HTTPArgument">
                <boolProp name="HTTPArgument.always_encode">false</boolProp>
                <stringProp name="Argument.name">client_id</stringProp>
                <stringProp name="Argument.value">00000</stringProp>
                <stringProp name="Argument.metadata">=</stringProp>
                <boolProp name="HTTPArgument.use_equals">true</boolProp>
              </elementProp>
              <elementProp name="redirect_uri" elementType="HTTPArgument">
                <boolProp name="HTTPArgument.always_encode">false</boolProp>
                <stringProp name="Argument.name">redirect_uri</stringProp>
                <stringProp name="Argument.value">${protocol}%3A%2F%2F${jmeter_path}%2Ftest%2Fmisp%2Fmisp-callback</stringProp>
                <stringProp name="Argument.metadata">=</stringProp>
                <boolProp name="HTTPArgument.use_equals">true</boolProp>
              </elementProp>
              <elementProp name="scope" elementType="HTTPArgument">
                <boolProp name="HTTPArgument.always_encode">false</boolProp>
                <stringProp name="Argument.name">scope</stringProp>
                <stringProp name="Argument.value">openid</stringProp>
                <stringProp name="Argument.metadata">=</stringProp>
                <boolProp name="HTTPArgument.use_equals">true</boolProp>
              </elementProp>
              <elementProp name="state" elementType="HTTPArgument">
                <boolProp name="HTTPArgument.always_encode">false</boolProp>
                <stringProp name="Argument.name">state</stringProp>
                <stringProp name="Argument.value">ddd</stringProp>
                <stringProp name="Argument.metadata">=</stringProp>
                <boolProp name="HTTPArgument.use_equals">true</boolProp>
              </elementProp>
              <elementProp name="nonce" elementType="HTTPArgument">
                <boolProp name="HTTPArgument.always_encode">false</boolProp>
                <stringProp name="Argument.name">nonce</stringProp>
                <stringProp name="Argument.value">213</stringProp>
                <stringProp name="Argument.metadata">=</stringProp>
                <boolProp name="HTTPArgument.use_equals">true</boolProp>
              </elementProp>
              <elementProp name="access_token" elementType="HTTPArgument">
                <boolProp name="HTTPArgument.always_encode">false</boolProp>
                <stringProp name="Argument.value">${access_token}</stringProp>
                <stringProp name="Argument.metadata">=</stringProp>
                <boolProp name="HTTPArgument.use_equals">true</boolProp>
                <stringProp name="Argument.name">access_token</stringProp>
              </elementProp>
              <elementProp name="id_token" elementType="HTTPArgument">
                <boolProp name="HTTPArgument.always_encode">false</boolProp>
                <stringProp name="Argument.value">${id_token}</stringProp>
                <stringProp name="Argument.metadata">=</stringProp>
                <boolProp name="HTTPArgument.use_equals">true</boolProp>
                <stringProp name="Argument.name">id_token</stringProp>
              </elementProp>
            </collectionProp>
          </elementProp>
          <stringProp name="HTTPSampler.domain"></stringProp>
          <stringProp name="HTTPSampler.port"></stringProp>
          <stringProp name="HTTPSampler.connect_timeout"></stringProp>
          <stringProp name="HTTPSampler.response_timeout"></stringProp>
          <stringProp name="HTTPSampler.protocol"></stringProp>
          <stringProp name="HTTPSampler.contentEncoding"></stringProp>
          <stringProp name="HTTPSampler.path">/marvelous/authorization/login</stringProp>
          <stringProp name="HTTPSampler.method">GET</stringProp>
          <boolProp name="HTTPSampler.follow_redirects">true</boolProp>
          <boolProp name="HTTPSampler.auto_redirects">false</boolProp>
          <boolProp name="HTTPSampler.use_keepalive">true</boolProp>
          <boolProp name="HTTPSampler.DO_MULTIPART_POST">false</boolProp>
          <boolProp name="HTTPSampler.monitor">false</boolProp>
          <stringProp name="HTTPSampler.embedded_url_re"></stringProp>
        </HTTPSamplerProxy>
        <hashTree>
          <ResponseAssertion guiclass="AssertionGui" testclass="ResponseAssertion" testname="アサーション" enabled="true">
            <collectionProp name="Asserion.test_strings">
              <stringProp name="249363884">platform_id=Dummy2&quot; data-login=&quot;true&quot; checked&gt;</stringProp>
              <stringProp name="1417515813">platform_id=Dummy1&quot; data-login=&quot;false&quot; &gt;</stringProp>
            </collectionProp>
            <stringProp name="TestPlan.comments">確認項目
1.ユーザID統合された画面が表示されているか
2.最終ログインのプラットフォームに、ログイン状態のフラグが立っているか
3.複数プラットフォームが選択されているか</stringProp>
            <stringProp name="Assertion.test_field">Assertion.response_data</stringProp>
            <boolProp name="Assertion.assume_success">false</boolProp>
            <intProp name="Assertion.test_type">2</intProp>
          </ResponseAssertion>
          <hashTree/>
          <RegexExtractor guiclass="RegexExtractorGui" testclass="RegexExtractor" testname="response_type_params1" enabled="true">
            <stringProp name="RegexExtractor.useHeaders">false</stringProp>
            <stringProp name="RegexExtractor.refname">response_type_params1</stringProp>
            <stringProp name="RegexExtractor.regex">response_type=(.*?)&quot; data-cancelidfederation</stringProp>
            <stringProp name="RegexExtractor.template">$1$</stringProp>
            <stringProp name="RegexExtractor.default"></stringProp>
            <stringProp name="RegexExtractor.match_number">1</stringProp>
          </RegexExtractor>
          <hashTree/>
          <RegexExtractor guiclass="RegexExtractorGui" testclass="RegexExtractor" testname="response_type_params2" enabled="true">
            <stringProp name="RegexExtractor.useHeaders">false</stringProp>
            <stringProp name="RegexExtractor.refname">response_type_params2</stringProp>
            <stringProp name="RegexExtractor.regex">response_type=(.*?)&quot; data-cancelidfederation</stringProp>
            <stringProp name="RegexExtractor.template">$1$</stringProp>
            <stringProp name="RegexExtractor.default"></stringProp>
            <stringProp name="RegexExtractor.match_number">2</stringProp>
          </RegexExtractor>
          <hashTree/>
        </hashTree>
        <HTTPSamplerProxy guiclass="HttpTestSampleGui" testclass="HTTPSamplerProxy" testname="Basic.連携解除(Dummy2)" enabled="true">
          <elementProp name="HTTPsampler.Arguments" elementType="Arguments" guiclass="HTTPArgumentsPanel" testclass="Arguments" enabled="true">
            <collectionProp name="Arguments.arguments">
              <elementProp name="response_type" elementType="HTTPArgument">
                <boolProp name="HTTPArgument.always_encode">false</boolProp>
                <stringProp name="Argument.value">${response_type_params2}</stringProp>
                <stringProp name="Argument.metadata">=</stringProp>
                <boolProp name="HTTPArgument.use_equals">true</boolProp>
                <stringProp name="Argument.name">response_type</stringProp>
              </elementProp>
            </collectionProp>
          </elementProp>
          <stringProp name="HTTPSampler.domain"></stringProp>
          <stringProp name="HTTPSampler.port"></stringProp>
          <stringProp name="HTTPSampler.connect_timeout"></stringProp>
          <stringProp name="HTTPSampler.response_timeout"></stringProp>
          <stringProp name="HTTPSampler.protocol"></stringProp>
          <stringProp name="HTTPSampler.contentEncoding"></stringProp>
          <stringProp name="HTTPSampler.path">/marvelous/federation/cancel-application-user-federation</stringProp>
          <stringProp name="HTTPSampler.method">GET</stringProp>
          <boolProp name="HTTPSampler.follow_redirects">true</boolProp>
          <boolProp name="HTTPSampler.auto_redirects">false</boolProp>
          <boolProp name="HTTPSampler.use_keepalive">true</boolProp>
          <boolProp name="HTTPSampler.DO_MULTIPART_POST">false</boolProp>
          <boolProp name="HTTPSampler.monitor">false</boolProp>
          <stringProp name="HTTPSampler.embedded_url_re"></stringProp>
          <stringProp name="TestPlan.comments">Detected the start of a redirect chain</stringProp>
        </HTTPSamplerProxy>
        <hashTree>
          <ResponseAssertion guiclass="AssertionGui" testclass="ResponseAssertion" testname="アサーション" enabled="true">
            <collectionProp name="Asserion.test_strings">
              <stringProp name="249363884">platform_id=Dummy2&quot; data-login=&quot;true&quot; checked&gt;</stringProp>
            </collectionProp>
            <stringProp name="TestPlan.comments">確認項目
初回ログイン画面が表示されているか</stringProp>
            <stringProp name="Assertion.test_field">Assertion.response_data</stringProp>
            <boolProp name="Assertion.assume_success">false</boolProp>
            <intProp name="Assertion.test_type">6</intProp>
          </ResponseAssertion>
          <hashTree/>
          <ResponseAssertion guiclass="AssertionGui" testclass="ResponseAssertion" testname="アサーション" enabled="true">
            <collectionProp name="Asserion.test_strings">
              <stringProp name="1826218673">Privacy Protection</stringProp>
            </collectionProp>
            <stringProp name="Assertion.test_field">Assertion.response_data</stringProp>
            <boolProp name="Assertion.assume_success">false</boolProp>
            <intProp name="Assertion.test_type">2</intProp>
          </ResponseAssertion>
          <hashTree/>
        </hashTree>
        <HTTPSamplerProxy guiclass="HttpTestSampleGui" testclass="HTTPSamplerProxy" testname="Basic.MISP連携一覧画面(Dummy1のアクセストークンで連携)" enabled="true">
          <elementProp name="HTTPsampler.Arguments" elementType="Arguments" guiclass="HTTPArgumentsPanel" testclass="Arguments" enabled="true">
            <collectionProp name="Arguments.arguments">
              <elementProp name="response_type" elementType="HTTPArgument">
                <boolProp name="HTTPArgument.always_encode">false</boolProp>
                <stringProp name="Argument.name">response_type</stringProp>
                <stringProp name="Argument.value">code</stringProp>
                <stringProp name="Argument.metadata">=</stringProp>
                <boolProp name="HTTPArgument.use_equals">true</boolProp>
              </elementProp>
              <elementProp name="client_id" elementType="HTTPArgument">
                <boolProp name="HTTPArgument.always_encode">false</boolProp>
                <stringProp name="Argument.name">client_id</stringProp>
                <stringProp name="Argument.value">00000</stringProp>
                <stringProp name="Argument.metadata">=</stringProp>
                <boolProp name="HTTPArgument.use_equals">true</boolProp>
              </elementProp>
              <elementProp name="redirect_uri" elementType="HTTPArgument">
                <boolProp name="HTTPArgument.always_encode">false</boolProp>
                <stringProp name="Argument.name">redirect_uri</stringProp>
                <stringProp name="Argument.value">${protocol}%3A%2F%2F${jmeter_path}%2Ftest%2Fmisp%2Fmisp-callback</stringProp>
                <stringProp name="Argument.metadata">=</stringProp>
                <boolProp name="HTTPArgument.use_equals">true</boolProp>
              </elementProp>
              <elementProp name="scope" elementType="HTTPArgument">
                <boolProp name="HTTPArgument.always_encode">false</boolProp>
                <stringProp name="Argument.name">scope</stringProp>
                <stringProp name="Argument.value">openid</stringProp>
                <stringProp name="Argument.metadata">=</stringProp>
                <boolProp name="HTTPArgument.use_equals">true</boolProp>
              </elementProp>
              <elementProp name="state" elementType="HTTPArgument">
                <boolProp name="HTTPArgument.always_encode">false</boolProp>
                <stringProp name="Argument.name">state</stringProp>
                <stringProp name="Argument.value">ddd</stringProp>
                <stringProp name="Argument.metadata">=</stringProp>
                <boolProp name="HTTPArgument.use_equals">true</boolProp>
              </elementProp>
              <elementProp name="nonce" elementType="HTTPArgument">
                <boolProp name="HTTPArgument.always_encode">false</boolProp>
                <stringProp name="Argument.name">nonce</stringProp>
                <stringProp name="Argument.value">nnnnonce</stringProp>
                <stringProp name="Argument.metadata">=</stringProp>
                <boolProp name="HTTPArgument.use_equals">true</boolProp>
              </elementProp>
              <elementProp name="access_token" elementType="HTTPArgument">
                <boolProp name="HTTPArgument.always_encode">false</boolProp>
                <stringProp name="Argument.value">${access_token_before}</stringProp>
                <stringProp name="Argument.metadata">=</stringProp>
                <boolProp name="HTTPArgument.use_equals">true</boolProp>
                <stringProp name="Argument.name">access_token</stringProp>
              </elementProp>
              <elementProp name="id_token" elementType="HTTPArgument">
                <boolProp name="HTTPArgument.always_encode">false</boolProp>
                <stringProp name="Argument.value">${id_token_before}</stringProp>
                <stringProp name="Argument.metadata">=</stringProp>
                <boolProp name="HTTPArgument.use_equals">true</boolProp>
                <stringProp name="Argument.name">id_token</stringProp>
              </elementProp>
            </collectionProp>
          </elementProp>
          <stringProp name="HTTPSampler.domain"></stringProp>
          <stringProp name="HTTPSampler.port"></stringProp>
          <stringProp name="HTTPSampler.connect_timeout"></stringProp>
          <stringProp name="HTTPSampler.response_timeout"></stringProp>
          <stringProp name="HTTPSampler.protocol"></stringProp>
          <stringProp name="HTTPSampler.contentEncoding"></stringProp>
          <stringProp name="HTTPSampler.path">/marvelous/authorization/login</stringProp>
          <stringProp name="HTTPSampler.method">GET</stringProp>
          <boolProp name="HTTPSampler.follow_redirects">true</boolProp>
          <boolProp name="HTTPSampler.auto_redirects">false</boolProp>
          <boolProp name="HTTPSampler.use_keepalive">true</boolProp>
          <boolProp name="HTTPSampler.DO_MULTIPART_POST">false</boolProp>
          <boolProp name="HTTPSampler.monitor">false</boolProp>
          <stringProp name="HTTPSampler.embedded_url_re"></stringProp>
          <stringProp name="TestPlan.comments">Dummy1はDummy2連携時に連携は解除されている</stringProp>
        </HTTPSamplerProxy>
        <hashTree>
          <RegexExtractor guiclass="RegexExtractorGui" testclass="RegexExtractor" testname="response_type_params1" enabled="true">
            <stringProp name="RegexExtractor.useHeaders">false</stringProp>
            <stringProp name="RegexExtractor.refname">response_type_params1</stringProp>
            <stringProp name="RegexExtractor.regex">response_type=(.*?)&quot; data-cancelidfederation</stringProp>
            <stringProp name="RegexExtractor.template">$1$</stringProp>
            <stringProp name="RegexExtractor.default"></stringProp>
            <stringProp name="RegexExtractor.match_number">1</stringProp>
          </RegexExtractor>
          <hashTree/>
          <RegexExtractor guiclass="RegexExtractorGui" testclass="RegexExtractor" testname="response_type_params2" enabled="true">
            <stringProp name="RegexExtractor.useHeaders">false</stringProp>
            <stringProp name="RegexExtractor.refname">response_type_params2</stringProp>
            <stringProp name="RegexExtractor.regex">response_type=(.*?)&quot; data-cancelidfederation</stringProp>
            <stringProp name="RegexExtractor.template">$1$</stringProp>
            <stringProp name="RegexExtractor.default"></stringProp>
            <stringProp name="RegexExtractor.match_number">2</stringProp>
          </RegexExtractor>
          <hashTree/>
          <ResponseAssertion guiclass="AssertionGui" testclass="ResponseAssertion" testname="アサーション" enabled="true">
            <collectionProp name="Asserion.test_strings">
              <stringProp name="-1632687002">platform_id=Dummy2&quot; data-login=&quot;false&quot; &gt;</stringProp>
              <stringProp name="-443737813">platform_id=Dummy1&quot; data-login=&quot;true&quot; checked&gt;</stringProp>
            </collectionProp>
            <stringProp name="TestPlan.comments">確認項目
1.ユーザID統合された画面が表示されているか
2.最終ログインのプラットフォームに、ログイン状態のフラグが立っているか
3.複数プラットフォームが選択されているか</stringProp>
            <stringProp name="Assertion.test_field">Assertion.response_data</stringProp>
            <boolProp name="Assertion.assume_success">false</boolProp>
            <intProp name="Assertion.test_type">2</intProp>
          </ResponseAssertion>
          <hashTree/>
        </hashTree>
        <HTTPSamplerProxy guiclass="HttpTestSampleGui" testclass="HTTPSamplerProxy" testname="Basic.連携解除(Dummy1)" enabled="true">
          <elementProp name="HTTPsampler.Arguments" elementType="Arguments" guiclass="HTTPArgumentsPanel" testclass="Arguments" enabled="true">
            <collectionProp name="Arguments.arguments">
              <elementProp name="response_type" elementType="HTTPArgument">
                <boolProp name="HTTPArgument.always_encode">false</boolProp>
                <stringProp name="Argument.value">${response_type_params1}</stringProp>
                <stringProp name="Argument.metadata">=</stringProp>
                <boolProp name="HTTPArgument.use_equals">true</boolProp>
                <stringProp name="Argument.name">response_type</stringProp>
              </elementProp>
            </collectionProp>
          </elementProp>
          <stringProp name="HTTPSampler.domain"></stringProp>
          <stringProp name="HTTPSampler.port"></stringProp>
          <stringProp name="HTTPSampler.connect_timeout"></stringProp>
          <stringProp name="HTTPSampler.response_timeout"></stringProp>
          <stringProp name="HTTPSampler.protocol"></stringProp>
          <stringProp name="HTTPSampler.contentEncoding"></stringProp>
          <stringProp name="HTTPSampler.path">/marvelous/federation/cancel-application-user-federation</stringProp>
          <stringProp name="HTTPSampler.method">GET</stringProp>
          <boolProp name="HTTPSampler.follow_redirects">true</boolProp>
          <boolProp name="HTTPSampler.auto_redirects">false</boolProp>
          <boolProp name="HTTPSampler.use_keepalive">true</boolProp>
          <boolProp name="HTTPSampler.DO_MULTIPART_POST">false</boolProp>
          <boolProp name="HTTPSampler.monitor">false</boolProp>
          <stringProp name="HTTPSampler.embedded_url_re"></stringProp>
          <stringProp name="TestPlan.comments">Detected the start of a redirect chain</stringProp>
        </HTTPSamplerProxy>
        <hashTree>
          <ResponseAssertion guiclass="AssertionGui" testclass="ResponseAssertion" testname="アサーション" enabled="true">
            <collectionProp name="Asserion.test_strings">
              <stringProp name="-443737813">platform_id=Dummy1&quot; data-login=&quot;true&quot; checked&gt;</stringProp>
            </collectionProp>
            <stringProp name="TestPlan.comments">確認項目
初回ログイン画面が表示されているか</stringProp>
            <stringProp name="Assertion.test_field">Assertion.response_data</stringProp>
            <boolProp name="Assertion.assume_success">false</boolProp>
            <intProp name="Assertion.test_type">6</intProp>
          </ResponseAssertion>
          <hashTree/>
          <ResponseAssertion guiclass="AssertionGui" testclass="ResponseAssertion" testname="アサーション" enabled="true">
            <collectionProp name="Asserion.test_strings">
              <stringProp name="1826218673">Privacy Protection</stringProp>
            </collectionProp>
            <stringProp name="Assertion.test_field">Assertion.response_data</stringProp>
            <boolProp name="Assertion.assume_success">false</boolProp>
            <intProp name="Assertion.test_type">2</intProp>
          </ResponseAssertion>
          <hashTree/>
        </hashTree>
      </hashTree>
      <ThreadGroup guiclass="ThreadGroupGui" testclass="ThreadGroup" testname="Basic_3.トークンをリフレッシュする" enabled="true">
        <stringProp name="ThreadGroup.on_sample_error">continue</stringProp>
        <elementProp name="ThreadGroup.main_controller" elementType="LoopController" guiclass="LoopControlPanel" testclass="LoopController" testname="ループコントローラ" enabled="true">
          <boolProp name="LoopController.continue_forever">false</boolProp>
          <stringProp name="LoopController.loops">1</stringProp>
        </elementProp>
        <stringProp name="ThreadGroup.num_threads">1</stringProp>
        <stringProp name="ThreadGroup.ramp_time">1</stringProp>
        <longProp name="ThreadGroup.start_time">1386654990000</longProp>
        <longProp name="ThreadGroup.end_time">1386654990000</longProp>
        <boolProp name="ThreadGroup.scheduler">false</boolProp>
        <stringProp name="ThreadGroup.duration"></stringProp>
        <stringProp name="ThreadGroup.delay"></stringProp>
      </ThreadGroup>
      <hashTree>
        <HTTPSamplerProxy guiclass="HttpTestSampleGui" testclass="HTTPSamplerProxy" testname="Basic.ID連携認証" enabled="true">
          <elementProp name="HTTPsampler.Arguments" elementType="Arguments" guiclass="HTTPArgumentsPanel" testclass="Arguments" enabled="true">
            <collectionProp name="Arguments.arguments">
              <elementProp name="response_type" elementType="HTTPArgument">
                <boolProp name="HTTPArgument.always_encode">false</boolProp>
                <stringProp name="Argument.name">response_type</stringProp>
                <stringProp name="Argument.value">code</stringProp>
                <stringProp name="Argument.metadata">=</stringProp>
                <boolProp name="HTTPArgument.use_equals">true</boolProp>
              </elementProp>
              <elementProp name="client_id" elementType="HTTPArgument">
                <boolProp name="HTTPArgument.always_encode">false</boolProp>
                <stringProp name="Argument.name">client_id</stringProp>
                <stringProp name="Argument.value">00000</stringProp>
                <stringProp name="Argument.metadata">=</stringProp>
                <boolProp name="HTTPArgument.use_equals">true</boolProp>
              </elementProp>
              <elementProp name="redirect_uri" elementType="HTTPArgument">
                <boolProp name="HTTPArgument.always_encode">false</boolProp>
                <stringProp name="Argument.name">redirect_uri</stringProp>
                <stringProp name="Argument.value">${protocol}%3A%2F%2F${jmeter_path}%2Ftest%2Fmisp%2Fmisp-callback</stringProp>
                <stringProp name="Argument.metadata">=</stringProp>
                <boolProp name="HTTPArgument.use_equals">true</boolProp>
              </elementProp>
              <elementProp name="scope" elementType="HTTPArgument">
                <boolProp name="HTTPArgument.always_encode">false</boolProp>
                <stringProp name="Argument.name">scope</stringProp>
                <stringProp name="Argument.value">openid</stringProp>
                <stringProp name="Argument.metadata">=</stringProp>
                <boolProp name="HTTPArgument.use_equals">true</boolProp>
              </elementProp>
              <elementProp name="state" elementType="HTTPArgument">
                <boolProp name="HTTPArgument.always_encode">false</boolProp>
                <stringProp name="Argument.name">state</stringProp>
                <stringProp name="Argument.value">ddd</stringProp>
                <stringProp name="Argument.metadata">=</stringProp>
                <boolProp name="HTTPArgument.use_equals">true</boolProp>
              </elementProp>
              <elementProp name="platform_id" elementType="HTTPArgument">
                <boolProp name="HTTPArgument.always_encode">false</boolProp>
                <stringProp name="Argument.name">platform_id</stringProp>
                <stringProp name="Argument.value">Dummy1</stringProp>
                <stringProp name="Argument.metadata">=</stringProp>
                <boolProp name="HTTPArgument.use_equals">true</boolProp>
              </elementProp>
            </collectionProp>
          </elementProp>
          <stringProp name="HTTPSampler.domain"></stringProp>
          <stringProp name="HTTPSampler.port"></stringProp>
          <stringProp name="HTTPSampler.connect_timeout"></stringProp>
          <stringProp name="HTTPSampler.response_timeout"></stringProp>
          <stringProp name="HTTPSampler.protocol"></stringProp>
          <stringProp name="HTTPSampler.contentEncoding"></stringProp>
          <stringProp name="HTTPSampler.path">/marvelous/federation</stringProp>
          <stringProp name="HTTPSampler.method">GET</stringProp>
          <boolProp name="HTTPSampler.follow_redirects">true</boolProp>
          <boolProp name="HTTPSampler.auto_redirects">false</boolProp>
          <boolProp name="HTTPSampler.use_keepalive">true</boolProp>
          <boolProp name="HTTPSampler.DO_MULTIPART_POST">false</boolProp>
          <boolProp name="HTTPSampler.monitor">false</boolProp>
          <stringProp name="HTTPSampler.embedded_url_re"></stringProp>
        </HTTPSamplerProxy>
        <hashTree>
          <RegexExtractor guiclass="RegexExtractorGui" testclass="RegexExtractor" testname="code" enabled="true">
            <stringProp name="RegexExtractor.useHeaders">false</stringProp>
            <stringProp name="RegexExtractor.refname">code</stringProp>
            <stringProp name="RegexExtractor.regex">code=(.*?)&lt;br&gt;</stringProp>
            <stringProp name="RegexExtractor.template">$1$</stringProp>
            <stringProp name="RegexExtractor.default"></stringProp>
            <stringProp name="RegexExtractor.match_number">1</stringProp>
          </RegexExtractor>
          <hashTree/>
        </hashTree>
        <HTTPSamplerProxy guiclass="HttpTestSampleGui" testclass="HTTPSamplerProxy" testname="Basic トークン取得" enabled="true">
          <elementProp name="HTTPsampler.Arguments" elementType="Arguments" guiclass="HTTPArgumentsPanel" testclass="Arguments" enabled="true">
            <collectionProp name="Arguments.arguments">
              <elementProp name="grant_type" elementType="HTTPArgument">
                <boolProp name="HTTPArgument.always_encode">false</boolProp>
                <stringProp name="Argument.value">authorization_code</stringProp>
                <stringProp name="Argument.metadata">=</stringProp>
                <boolProp name="HTTPArgument.use_equals">true</boolProp>
                <stringProp name="Argument.name">grant_type</stringProp>
              </elementProp>
              <elementProp name="code" elementType="HTTPArgument">
                <boolProp name="HTTPArgument.always_encode">false</boolProp>
                <stringProp name="Argument.value">${code}</stringProp>
                <stringProp name="Argument.metadata">=</stringProp>
                <boolProp name="HTTPArgument.use_equals">true</boolProp>
                <stringProp name="Argument.name">code</stringProp>
              </elementProp>
              <elementProp name="redirect_uri" elementType="HTTPArgument">
                <boolProp name="HTTPArgument.always_encode">false</boolProp>
                <stringProp name="Argument.value">${protocol}%3A%2F%2F${jmeter_path}%2Ftest%2Fmisp%2Fmisp-callback</stringProp>
                <stringProp name="Argument.metadata">=</stringProp>
                <boolProp name="HTTPArgument.use_equals">true</boolProp>
                <stringProp name="Argument.name">redirect_uri</stringProp>
              </elementProp>
            </collectionProp>
          </elementProp>
          <stringProp name="HTTPSampler.domain">${misp_url}</stringProp>
          <stringProp name="HTTPSampler.port"></stringProp>
          <stringProp name="HTTPSampler.connect_timeout"></stringProp>
          <stringProp name="HTTPSampler.response_timeout"></stringProp>
          <stringProp name="HTTPSampler.protocol">${protocol}</stringProp>
          <stringProp name="HTTPSampler.contentEncoding"></stringProp>
          <stringProp name="HTTPSampler.path">/marvelous/token</stringProp>
          <stringProp name="HTTPSampler.method">POST</stringProp>
          <boolProp name="HTTPSampler.follow_redirects">true</boolProp>
          <boolProp name="HTTPSampler.auto_redirects">false</boolProp>
          <boolProp name="HTTPSampler.use_keepalive">true</boolProp>
          <boolProp name="HTTPSampler.DO_MULTIPART_POST">false</boolProp>
          <boolProp name="HTTPSampler.monitor">false</boolProp>
          <stringProp name="HTTPSampler.embedded_url_re"></stringProp>
        </HTTPSamplerProxy>
        <hashTree>
          <BSFPreProcessor guiclass="TestBeanGUI" testclass="BSFPreProcessor" testname="BSF PreProcessor" enabled="true">
            <stringProp name="filename"></stringProp>
            <stringProp name="parameters"></stringProp>
            <stringProp name="script">/*
 * A JavaScript implementation of the Secure Hash Algorithm, SHA-1, as defined
 * in FIPS PUB 180-1
 * Version 2.1a Copyright Paul Johnston 2000 - 2002.
 * Other contributors: Greg Holt, Andrew Kepert, Ydnar, Lostinet
 * Distributed under the BSD License
 * See http://pajhome.org.uk/crypt/md5 for details.
 */

/*
 * Configurable variables. You may need to tweak these to be compatible with
 * the server-side, but the defaults work in most cases.
 */
var hexcase = 0;  /* hex output format. 0 - lowercase; 1 - uppercase        */
var b64pad  = &quot;&quot;; /* base-64 pad character. &quot;=&quot; for strict RFC compliance   */
var chrsz   = 8;  /* bits per input character. 8 - ASCII; 16 - Unicode      */

/*
 * These are the functions you&apos;ll usually want to call
 * They take string arguments and return either hex or base-64 encoded strings
 */
function hex_sha1(s){return binb2hex(core_sha1(str2binb(s),s.length * chrsz));}
function b64_sha1(s){return binb2b64(core_sha1(str2binb(s),s.length * chrsz));}
function str_sha1(s){return binb2str(core_sha1(str2binb(s),s.length * chrsz));}
function hex_hmac_sha1(key, data){ return binb2hex(core_hmac_sha1(key, data));}
function b64_hmac_sha1(key, data){ return binb2b64(core_hmac_sha1(key, data));}
function str_hmac_sha1(key, data){ return binb2str(core_hmac_sha1(key, data));}

/*
 * Perform a simple self-test to see if the VM is working
 */
function sha1_vm_test()
{
  return hex_sha1(&quot;abc&quot;) == &quot;a9993e364706816aba3e25717850c26c9cd0d89d&quot;;
}

/*
 * Calculate the SHA-1 of an array of big-endian words, and a bit length
 */
function core_sha1(x, len)
{
  /* append padding */
  x[len &gt;&gt; 5] |= 0x80 &lt;&lt; (24 - len % 32);
  x[((len + 64 &gt;&gt; 9) &lt;&lt; 4) + 15] = len;

  var w = Array(80);
  var a =  1732584193;
  var b = -271733879;
  var c = -1732584194;
  var d =  271733878;
  var e = -1009589776;

  for(var i = 0; i &lt; x.length; i += 16)
  {
    var olda = a;
    var oldb = b;
    var oldc = c;
    var oldd = d;
    var olde = e;

    for(var j = 0; j &lt; 80; j++)
    {
      if(j &lt; 16) w[j] = x[i + j];
      else w[j] = rol(w[j-3] ^ w[j-8] ^ w[j-14] ^ w[j-16], 1);
      var t = safe_add(safe_add(rol(a, 5), sha1_ft(j, b, c, d)),
                       safe_add(safe_add(e, w[j]), sha1_kt(j)));
      e = d;
      d = c;
      c = rol(b, 30);
      b = a;
      a = t;
    }

    a = safe_add(a, olda);
    b = safe_add(b, oldb);
    c = safe_add(c, oldc);
    d = safe_add(d, oldd);
    e = safe_add(e, olde);
  }
  return Array(a, b, c, d, e);

}

/*
 * Perform the appropriate triplet combination function for the current
 * iteration
 */
function sha1_ft(t, b, c, d)
{
  if(t &lt; 20) return (b &amp; c) | ((~b) &amp; d);
  if(t &lt; 40) return b ^ c ^ d;
  if(t &lt; 60) return (b &amp; c) | (b &amp; d) | (c &amp; d);
  return b ^ c ^ d;
}

/*
 * Determine the appropriate additive constant for the current iteration
 */
function sha1_kt(t)
{
  return (t &lt; 20) ?  1518500249 : (t &lt; 40) ?  1859775393 :
         (t &lt; 60) ? -1894007588 : -899497514;
}

/*
 * Calculate the HMAC-SHA1 of a key and some data
 */
function core_hmac_sha1(key, data)
{
  var bkey = str2binb(key);
  if(bkey.length &gt; 16) bkey = core_sha1(bkey, key.length * chrsz);

  var ipad = Array(16), opad = Array(16);
  for(var i = 0; i &lt; 16; i++)
  {
    ipad[i] = bkey[i] ^ 0x36363636;
    opad[i] = bkey[i] ^ 0x5C5C5C5C;
  }

  var hash = core_sha1(ipad.concat(str2binb(data)), 512 + data.length * chrsz);
  return core_sha1(opad.concat(hash), 512 + 160);
}

/*
 * Add integers, wrapping at 2^32. This uses 16-bit operations internally
 * to work around bugs in some JS interpreters.
 */
function safe_add(x, y)
{
  var lsw = (x &amp; 0xFFFF) + (y &amp; 0xFFFF);
  var msw = (x &gt;&gt; 16) + (y &gt;&gt; 16) + (lsw &gt;&gt; 16);
  return (msw &lt;&lt; 16) | (lsw &amp; 0xFFFF);
}

/*
 * Bitwise rotate a 32-bit number to the left.
 */
function rol(num, cnt)
{
  return (num &lt;&lt; cnt) | (num &gt;&gt;&gt; (32 - cnt));
}

/*
 * Convert an 8-bit or 16-bit string to an array of big-endian words
 * In 8-bit function, characters &gt;255 have their hi-byte silently ignored.
 */
function str2binb(str)
{
  var bin = Array();
  var mask = (1 &lt;&lt; chrsz) - 1;
  for(var i = 0; i &lt; str.length * chrsz; i += chrsz)
    bin[i&gt;&gt;5] |= (str.charCodeAt(i / chrsz) &amp; mask) &lt;&lt; (32 - chrsz - i%32);
  return bin;
}

/*
 * Convert an array of big-endian words to a string
 */
function binb2str(bin)
{
  var str = &quot;&quot;;
  var mask = (1 &lt;&lt; chrsz) - 1;
  for(var i = 0; i &lt; bin.length * 32; i += chrsz)
    str += String.fromCharCode((bin[i&gt;&gt;5] &gt;&gt;&gt; (32 - chrsz - i%32)) &amp; mask);
  return str;
}

/*
 * Convert an array of big-endian words to a hex string.
 */
function binb2hex(binarray)
{
  var hex_tab = hexcase ? &quot;0123456789ABCDEF&quot; : &quot;0123456789abcdef&quot;;
  var str = &quot;&quot;;
  for(var i = 0; i &lt; binarray.length * 4; i++)
  {
    str += hex_tab.charAt((binarray[i&gt;&gt;2] &gt;&gt; ((3 - i%4)*8+4)) &amp; 0xF) +
           hex_tab.charAt((binarray[i&gt;&gt;2] &gt;&gt; ((3 - i%4)*8  )) &amp; 0xF);
  }
  return str;
}

/*
 * Convert an array of big-endian words to a base-64 string
 */
function binb2b64(binarray)
{
  var tab = &quot;ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/&quot;;
  var str = &quot;&quot;;
  for(var i = 0; i &lt; binarray.length * 4; i += 3)
  {
    var triplet = (((binarray[i   &gt;&gt; 2] &gt;&gt; 8 * (3 -  i   %4)) &amp; 0xFF) &lt;&lt; 16)
                | (((binarray[i+1 &gt;&gt; 2] &gt;&gt; 8 * (3 - (i+1)%4)) &amp; 0xFF) &lt;&lt; 8 )
                |  ((binarray[i+2 &gt;&gt; 2] &gt;&gt; 8 * (3 - (i+2)%4)) &amp; 0xFF);
    for(var j = 0; j &lt; 4; j++)
    {
      if(i * 8 + j * 6 &gt; binarray.length * 32) str += b64pad;
      else str += tab.charAt((triplet &gt;&gt; 6*(3-j)) &amp; 0x3F);
    }
  }
  return str;
}

/*
 * Copyright 2008 Netflix, Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/* Here&apos;s some JavaScript software for implementing OAuth.

   This isn&apos;t as useful as you might hope.  OAuth is based around
   allowing tools and websites to talk to each other.  However,
   JavaScript running in web browsers is hampered by security
   restrictions that prevent code running on one website from
   accessing data stored or served on another.

   Before you start hacking, make sure you understand the limitations
   posed by cross-domain XMLHttpRequest.

   On the bright side, some platforms use JavaScript as their
   language, but enable the programmer to access other web sites.
   Examples include Google Gadgets, and Microsoft Vista Sidebar.
   For those platforms, this library should come in handy.
*/

// The HMAC-SHA1 signature method calls b64_hmac_sha1, defined by
// http://pajhome.org.uk/crypt/md5/sha1.js

/* An OAuth message is represented as an object like this:
   {method: &quot;GET&quot;, action: &quot;http://server.com/path&quot;, parameters: ...}

   The parameters may be either a map {name: value, name2: value2}
   or an Array of name-value pairs [[name, value], [name2, value2]].
   The latter representation is more powerful: it supports parameters
   in a specific sequence, or several parameters with the same name;
   for example [[&quot;a&quot;, 1], [&quot;b&quot;, 2], [&quot;a&quot;, 3]].

   Parameter names and values are NOT percent-encoded in an object.
   They must be encoded before transmission and decoded after reception.
   For example, this message object:
   {method: &quot;GET&quot;, action: &quot;http://server/path&quot;, parameters: {p: &quot;x y&quot;}}
   ... can be transmitted as an HTTP request that begins:
   GET /path?p=x%20y HTTP/1.0
   (This isn&apos;t a valid OAuth request, since it lacks a signature etc.)
   Note that the object &quot;x y&quot; is transmitted as x%20y.  To encode
   parameters, you can call OAuth.addToURL, OAuth.formEncode or
   OAuth.getAuthorization.

   This message object model harmonizes with the browser object model for
   input elements of an form, whose value property isn&apos;t percent encoded.
   The browser encodes each value before transmitting it. For example,
   see consumer.setInputs in example/consumer.js.
 */

/* This script needs to know what time it is. By default, it uses the local
   clock (new Date), which is apt to be inaccurate in browsers. To do
   better, you can load this script from a URL whose query string contains
   an oauth_timestamp parameter, whose value is a current Unix timestamp.
   For example, when generating the enclosing document using PHP:

   &lt;script src=&quot;oauth.js?oauth_timestamp=&lt;?=time()?&gt;&quot; ...

   Another option is to call OAuth.correctTimestamp with a Unix timestamp.
 */

var OAuth; if (OAuth == null) OAuth = {};

OAuth.setProperties = function setProperties(into, from) {
    if (into != null &amp;&amp; from != null) {
        for (var key in from) {
            into[key] = from[key];
        }
    }
    return into;
}

OAuth.setProperties(OAuth, // utility functions
{
    percentEncode: function percentEncode(s) {
        if (s == null) {
            return &quot;&quot;;
        }
        if (s instanceof Array) {
            var e = &quot;&quot;;
            for (var i = 0; i &lt; s.length; ++s) {
                if (e != &quot;&quot;) e += &apos;&amp;&apos;;
                e += OAuth.percentEncode(s[i]);
            }
            return e;
        }
        s = encodeURIComponent(s);
        // Now replace the values which encodeURIComponent doesn&apos;t do
        // encodeURIComponent ignores: - _ . ! ~ * &apos; ( )
        // OAuth dictates the only ones you can ignore are: - _ . ~
        // Source: http://developer.mozilla.org/en/docs/Core_JavaScript_1.5_Reference:Global_Functions:encodeURIComponent
        s = s.replace(/\!/g, &quot;%21&quot;);
        s = s.replace(/\*/g, &quot;%2A&quot;);
        s = s.replace(/\&apos;/g, &quot;%27&quot;);
        s = s.replace(/\(/g, &quot;%28&quot;);
        s = s.replace(/\)/g, &quot;%29&quot;);
        return s;
    }
,
    decodePercent: function decodePercent(s) {
        if (s != null) {
            // Handle application/x-www-form-urlencoded, which is defined by
            // http://www.w3.org/TR/html4/interact/forms.html#h-17.13.4.1
            s = s.replace(/\+/g, &quot; &quot;);
        }
        return decodeURIComponent(s);
    }
,
    /** Convert the given parameters to an Array of name-value pairs. */
    getParameterList: function getParameterList(parameters) {
        if (parameters == null) {
            return [];
        }
        if (typeof parameters != &quot;object&quot;) {
            return OAuth.decodeForm(parameters + &quot;&quot;);
        }
        if (parameters instanceof Array) {
            return parameters;
        }
        var list = [];
        for (var p in parameters) {
            list.push([p, parameters[p]]);
        }
        return list;
    }
,
    /** Convert the given parameters to a map from name to value. */
    getParameterMap: function getParameterMap(parameters) {
        if (parameters == null) {
            return {};
        }
        if (typeof parameters != &quot;object&quot;) {
            return OAuth.getParameterMap(OAuth.decodeForm(parameters + &quot;&quot;));
        }
        if (parameters instanceof Array) {
            var map = {};
            for (var p = 0; p &lt; parameters.length; ++p) {
                var key = parameters[p][0];
                if (map[key] === undefined) { // first value wins
                    map[key] = parameters[p][1];
                }
            }
            return map;
        }
        return parameters;
    }
,
    getParameter: function getParameter(parameters, name) {
        if (parameters instanceof Array) {
            for (var p = 0; p &lt; parameters.length; ++p) {
                if (parameters[p][0] == name) {
                    return parameters[p][1]; // first value wins
                }
            }
        } else {
            return OAuth.getParameterMap(parameters)[name];
        }
        return null;
    }
,
    formEncode: function formEncode(parameters) {
        var form = &quot;&quot;;
        var list = OAuth.getParameterList(parameters);
        for (var p = 0; p &lt; list.length; ++p) {
            var value = list[p][1];
            if (value == null) value = &quot;&quot;;
            if (form != &quot;&quot;) form += &apos;&amp;&apos;;
            form += OAuth.percentEncode(list[p][0])
              +&apos;=&apos;+ OAuth.percentEncode(value);
        }
        return form;
    }
,
    decodeForm: function decodeForm(form) {
        var list = [];
        var nvps = form.split(&apos;&amp;&apos;);
        for (var n = 0; n &lt; nvps.length; ++n) {
            var nvp = nvps[n];
            if (nvp == &quot;&quot;) {
                continue;
            }
            var equals = nvp.indexOf(&apos;=&apos;);
            var name;
            var value;
            if (equals &lt; 0) {
                name = OAuth.decodePercent(nvp);
                value = null;
            } else {
                name = OAuth.decodePercent(nvp.substring(0, equals));
                value = OAuth.decodePercent(nvp.substring(equals + 1));
            }
            list.push([name, value]);
        }
        return list;
    }
,
    setParameter: function setParameter(message, name, value) {
        var parameters = message.parameters;
        if (parameters instanceof Array) {
            for (var p = 0; p &lt; parameters.length; ++p) {
                if (parameters[p][0] == name) {
                    if (value === undefined) {
                        parameters.splice(p, 1);
                    } else {
                        parameters[p][1] = value;
                        value = undefined;
                    }
                }
            }
            if (value !== undefined) {
                parameters.push([name, value]);
            }
        } else {
            parameters = OAuth.getParameterMap(parameters);
            parameters[name] = value;
            message.parameters = parameters;
        }
    }
,
    setParameters: function setParameters(message, parameters) {
        var list = OAuth.getParameterList(parameters);
        for (var i = 0; i &lt; list.length; ++i) {
            OAuth.setParameter(message, list[i][0], list[i][1]);
        }
    }
,
    /** Fill in parameters to help construct a request message.
        This function doesn&apos;t fill in every parameter.
        The accessor object should be like:
        {consumerKey:&apos;foo&apos;, consumerSecret:&apos;bar&apos;, accessorSecret:&apos;nurn&apos;, token:&apos;krelm&apos;, tokenSecret:&apos;blah&apos;}
        The accessorSecret property is optional.
     */
    completeRequest: function completeRequest(message, accessor) {
        if (message.method == null) {
            message.method = &quot;GET&quot;;
        }
        var map = OAuth.getParameterMap(message.parameters);
        if (map.oauth_consumer_key == null) {
            OAuth.setParameter(message, &quot;oauth_consumer_key&quot;, accessor.consumerKey || &quot;&quot;);
        }
        if (map.oauth_token == null &amp;&amp; accessor.token != null) {
            OAuth.setParameter(message, &quot;oauth_token&quot;, accessor.token);
        }
        if (map.oauth_version == null) {
            OAuth.setParameter(message, &quot;oauth_version&quot;, &quot;1.0&quot;);
        }
        if (map.oauth_timestamp == null) {
            OAuth.setParameter(message, &quot;oauth_timestamp&quot;, OAuth.timestamp());
        }
        if (map.oauth_nonce == null) {
            OAuth.setParameter(message, &quot;oauth_nonce&quot;, OAuth.nonce(6));
        }
        OAuth.SignatureMethod.sign(message, accessor);
    }
,
    setTimestampAndNonce: function setTimestampAndNonce(message) {
        OAuth.setParameter(message, &quot;oauth_timestamp&quot;, OAuth.timestamp());
        OAuth.setParameter(message, &quot;oauth_nonce&quot;, OAuth.nonce(6));
    }
,
    addToURL: function addToURL(url, parameters) {
        newURL = url;
        if (parameters != null) {
            var toAdd = OAuth.formEncode(parameters);
            if (toAdd.length &gt; 0) {
                var q = url.indexOf(&apos;?&apos;);
                if (q &lt; 0) newURL += &apos;?&apos;;
                else       newURL += &apos;&amp;&apos;;
                newURL += toAdd;
            }
        }
        return newURL;
    }
,
    /** Construct the value of the Authorization header for an HTTP request. */
    getAuthorizationHeader: function getAuthorizationHeader(realm, parameters) {
        var header = &apos;OAuth realm=&quot;&apos; + OAuth.percentEncode(realm) + &apos;&quot;&apos;;
        var list = OAuth.getParameterList(parameters);
        for (var p = 0; p &lt; list.length; ++p) {
            var parameter = list[p];
            var name = parameter[0];
            if (name.indexOf(&quot;oauth_&quot;) == 0) {
                header += &apos;,&apos; + OAuth.percentEncode(name) + &apos;=&quot;&apos; + OAuth.percentEncode(parameter[1]) + &apos;&quot;&apos;;
            }
        }
        return header;
    }
,
    /** Correct the time using a parameter from the URL from which the last script was loaded. */
    correctTimestampFromSrc: function correctTimestampFromSrc(parameterName) {
        parameterName = parameterName || &quot;oauth_timestamp&quot;;
        var scripts = document.getElementsByTagName(&apos;script&apos;);
        if (scripts == null || !scripts.length) return;
        var src = scripts[scripts.length-1].src;
        if (!src) return;
        var q = src.indexOf(&quot;?&quot;);
        if (q &lt; 0) return;
        parameters = OAuth.getParameterMap(OAuth.decodeForm(src.substring(q+1)));
        var t = parameters[parameterName];
        if (t == null) return;
        OAuth.correctTimestamp(t);
    }
,
    /** Generate timestamps starting with the given value. */
    correctTimestamp: function correctTimestamp(timestamp) {
        OAuth.timeCorrectionMsec = (timestamp * 1000) - (new Date()).getTime();
    }
,
    /** The difference between the correct time and my clock. */
    timeCorrectionMsec: 0
,
    timestamp: function timestamp() {
        var t = (new Date()).getTime() + OAuth.timeCorrectionMsec;
        return Math.floor(t / 1000);
    }
,
    nonce: function nonce(length) {
        var chars = OAuth.nonce.CHARS;
        var result = &quot;&quot;;
        for (var i = 0; i &lt; length; ++i) {
            var rnum = Math.floor(Math.random() * chars.length);
            result += chars.substring(rnum, rnum+1);
        }
        return result;
    }
});

OAuth.nonce.CHARS = &quot;0123456789ABCDEFGHIJKLMNOPQRSTUVWXTZabcdefghiklmnopqrstuvwxyz&quot;;

/** Define a constructor function,
    without causing trouble to anyone who was using it as a namespace.
    That is, if parent[name] already existed and had properties,
    copy those properties into the new constructor.
 */
OAuth.declareClass = function declareClass(parent, name, newConstructor) {
    var previous = parent[name];
    parent[name] = newConstructor;
    if (newConstructor != null &amp;&amp; previous != null) {
        for (var key in previous) {
            if (key != &quot;prototype&quot;) {
                newConstructor[key] = previous[key];
            }
        }
    }
    return newConstructor;
}

/** An abstract algorithm for signing messages. */
OAuth.declareClass(OAuth, &quot;SignatureMethod&quot;, function OAuthSignatureMethod(){});

OAuth.setProperties(OAuth.SignatureMethod.prototype, // instance members
{
    /** Add a signature to the message. */
    sign: function sign(message) {
        var baseString = OAuth.SignatureMethod.getBaseString(message);
        var signature = this.getSignature(baseString);
        OAuth.setParameter(message, &quot;oauth_signature&quot;, signature);
        return signature; // just in case someone&apos;s interested
    }
,
    /** Set the key string for signing. */
    initialize: function initialize(name, accessor) {
        var consumerSecret;
        if (accessor.accessorSecret != null
            &amp;&amp; name.length &gt; 9
            &amp;&amp; name.substring(name.length-9) == &quot;-Accessor&quot;)
        {
            consumerSecret = accessor.accessorSecret;
        } else {
            consumerSecret = accessor.consumerSecret;
        }
        this.key = OAuth.percentEncode(consumerSecret)
             +&quot;&amp;&quot;+ OAuth.percentEncode(accessor.tokenSecret);
    }
});

/* SignatureMethod expects an accessor object to be like this:
   {tokenSecret: &quot;lakjsdflkj...&quot;, consumerSecret: &quot;QOUEWRI..&quot;, accessorSecret: &quot;xcmvzc...&quot;}
   The accessorSecret property is optional.
 */
// Class members:
OAuth.setProperties(OAuth.SignatureMethod, // class members
{
    sign: function sign(message, accessor) {
        var name = OAuth.getParameterMap(message.parameters).oauth_signature_method;
        if (name == null || name == &quot;&quot;) {
            name = &quot;HMAC-SHA1&quot;;
            OAuth.setParameter(message, &quot;oauth_signature_method&quot;, name);
        }
        OAuth.SignatureMethod.newMethod(name, accessor).sign(message);
    }
,
    /** Instantiate a SignatureMethod for the given method name. */
    newMethod: function newMethod(name, accessor) {
        var impl = OAuth.SignatureMethod.REGISTERED[name];
        if (impl != null) {
            var method = new impl();
            method.initialize(name, accessor);
            return method;
        }
        var err = new Error(&quot;signature_method_rejected&quot;);
        var acceptable = &quot;&quot;;
        for (var r in OAuth.SignatureMethod.REGISTERED) {
            if (acceptable != &quot;&quot;) acceptable += &apos;&amp;&apos;;
            acceptable += OAuth.percentEncode(r);
        }
        err.oauth_acceptable_signature_methods = acceptable;
        throw err;
    }
,
    /** A map from signature method name to constructor. */
    REGISTERED : {}
,
    /** Subsequently, the given constructor will be used for the named methods.
        The constructor will be called with no parameters.
        The resulting object should usually implement getSignature(baseString).
        You can easily define such a constructor by calling makeSubclass, below.
     */
    registerMethodClass: function registerMethodClass(names, classConstructor) {
        for (var n = 0; n &lt; names.length; ++n) {
            OAuth.SignatureMethod.REGISTERED[names[n]] = classConstructor;
        }
    }
,
    /** Create a subclass of OAuth.SignatureMethod, with the given getSignature function. */
    makeSubclass: function makeSubclass(getSignatureFunction) {
        var superClass = OAuth.SignatureMethod;
        var subClass = function() {
            superClass.call(this);
        };
        subClass.prototype = new superClass();
        // Delete instance variables from prototype:
        // delete subclass.prototype... There aren&apos;t any.
        subClass.prototype.getSignature = getSignatureFunction;
        subClass.prototype.constructor = subClass;
        return subClass;
    }
,
    getBaseString: function getBaseString(message) {
        var URL = message.action;
        var q = URL.indexOf(&apos;?&apos;);
        var parameters;
        if (q &lt; 0) {
            parameters = message.parameters;
        } else {
            // Combine the URL query string with the other parameters:
            parameters = OAuth.decodeForm(URL.substring(q + 1));
            var toAdd = OAuth.getParameterList(message.parameters);
            for (var a = 0; a &lt; toAdd.length; ++a) {
                parameters.push(toAdd[a]);
            }
        }
        return OAuth.percentEncode(message.method.toUpperCase())
         +&apos;&amp;&apos;+ OAuth.percentEncode(OAuth.SignatureMethod.normalizeUrl(URL))
         +&apos;&amp;&apos;+ OAuth.percentEncode(OAuth.SignatureMethod.normalizeParameters(parameters));
    }
,
    normalizeUrl: function normalizeUrl(url) {
        var uri = OAuth.SignatureMethod.parseUri(url);
        var scheme = uri.protocol.toLowerCase();
        var authority = uri.authority.toLowerCase();
        var dropPort = (scheme == &quot;http&quot; &amp;&amp; uri.port == 80)
                    || (scheme == &quot;https&quot; &amp;&amp; uri.port == 443);
        if (dropPort) {
            // find the last : in the authority
            var index = authority.lastIndexOf(&quot;:&quot;);
            if (index &gt;= 0) {
                authority = authority.substring(0, index);
            }
        }
        var path = uri.path;
        if (!path) {
            path = &quot;/&quot;; // conforms to RFC 2616 section 3.2.2
        }
        // we know that there is no query and no fragment here.
        return scheme + &quot;://&quot; + authority + path;
    }
,
    parseUri: function parseUri (str) {
        /* This function was adapted from parseUri 1.2.1
           http://stevenlevithan.com/demo/parseuri/js/assets/parseuri.js
         */
        var o = {key: [&quot;source&quot;,&quot;protocol&quot;,&quot;authority&quot;,&quot;userInfo&quot;,&quot;user&quot;,&quot;password&quot;,&quot;host&quot;,&quot;port&quot;,&quot;relative&quot;,&quot;path&quot;,&quot;directory&quot;,&quot;file&quot;,&quot;query&quot;,&quot;anchor&quot;],
                 parser: {strict: /^(?:([^:\/?#]+):)?(?:\/\/((?:(([^:@\/]*):?([^:@\/]*))?@)?([^:\/?#]*)(?::(\d*))?))?((((?:[^?#\/]*\/)*)([^?#]*))(?:\?([^#]*))?(?:#(.*))?)/ }};
        var m = o.parser.strict.exec(str);
        var uri = {};
        var i = 14;
        while (i--) uri[o.key[i]] = m[i] || &quot;&quot;;
        return uri;
    }
,
    normalizeParameters: function normalizeParameters(parameters) {
        if (parameters == null) {
            return &quot;&quot;;
        }
        var list = OAuth.getParameterList(parameters);
        var sortable = [];
        for (var p = 0; p &lt; list.length; ++p) {
            var nvp = list[p];
            if (nvp[0] != &quot;oauth_signature&quot;) {
                sortable.push([ OAuth.percentEncode(nvp[0])
                              + &quot; &quot; // because it comes before any character that can appear in a percentEncoded string.
                              + OAuth.percentEncode(nvp[1])
                              , nvp]);
            }
        }
        sortable.sort(function(a,b) {
                          if (a[0] &lt; b[0]) return  -1;
                          if (a[0] &gt; b[0]) return 1;
                          return 0;
                      });
        var sorted = [];
        for (var s = 0; s &lt; sortable.length; ++s) {
            sorted.push(sortable[s][1]);
        }
        return OAuth.formEncode(sorted);
    }
});

OAuth.SignatureMethod.registerMethodClass([&quot;PLAINTEXT&quot;, &quot;PLAINTEXT-Accessor&quot;],
    OAuth.SignatureMethod.makeSubclass(
        function getSignature(baseString) {
            return this.key;
        }
    ));

OAuth.SignatureMethod.registerMethodClass([&quot;HMAC-SHA1&quot;, &quot;HMAC-SHA1-Accessor&quot;],
    OAuth.SignatureMethod.makeSubclass(
        function getSignature(baseString) {
            b64pad = &apos;=&apos;;
            var signature = b64_hmac_sha1(this.key, baseString);
            return signature;
        }
    ));

try {
    OAuth.correctTimestampFromSrc();
} catch(e) {
}


//--------------------------------------------------

var consumerKey = &quot;${consumer_key}&quot;;
var consumerSecret = &quot;${consumer_secret}&quot;;
var params = [];
var query = [];
query.push(&apos;grant_type&apos; + &apos;=&apos; + &apos;authorization_code&apos;);
query.push(&apos;code&apos; + &apos;=&apos; + &apos;${code}&apos;);
query.push(&apos;redirect_uri&apos; + &apos;=&apos; + &apos;${protocol}%3A%2F%2F${jmeter_path}%2Ftest%2Fmisp%2Fmisp-callback&apos;);
var url =  &quot;${protocol}://${misp_url}/marvelous/token&quot;;

if (query.length) {
    url += &apos;?&apos; + query.join(&apos;&amp;&apos;);
}

var message = {
    method: &apos;post&apos;,
    parameters: params, 
    action: url
};
       
var accessor = {
    consumerKey: consumerKey,
    consumerSecret: consumerSecret,
    token: null,
    tokenSecret: null
};

OAuth.completeRequest(message, accessor);
vars.put(&apos;token_auth_header&apos;, OAuth.getAuthorizationHeader(&apos;&apos;, params).replace(&apos;OAuth realm=&quot;&quot;,&apos;, &apos; OAuth &apos;));
</stringProp>
            <stringProp name="scriptLanguage">javascript</stringProp>
          </BSFPreProcessor>
          <hashTree/>
          <HeaderManager guiclass="HeaderPanel" testclass="HeaderManager" testname="HTTP ヘッダマネージャ" enabled="true">
            <collectionProp name="HeaderManager.headers">
              <elementProp name="" elementType="Header">
                <stringProp name="Header.name">Authorization</stringProp>
                <stringProp name="Header.value">${token_auth_header}</stringProp>
              </elementProp>
              <elementProp name="" elementType="Header">
                <stringProp name="Header.name">content-type</stringProp>
                <stringProp name="Header.value">application/x-www-form-urlencoded</stringProp>
              </elementProp>
            </collectionProp>
          </HeaderManager>
          <hashTree/>
          <RegexExtractor guiclass="RegexExtractorGui" testclass="RegexExtractor" testname="access_token" enabled="true">
            <stringProp name="RegexExtractor.useHeaders">false</stringProp>
            <stringProp name="RegexExtractor.refname">access_token</stringProp>
            <stringProp name="RegexExtractor.regex">&quot;access_token&quot;:&quot;(.*?)&quot;,</stringProp>
            <stringProp name="RegexExtractor.template">$1$</stringProp>
            <stringProp name="RegexExtractor.default"></stringProp>
            <stringProp name="RegexExtractor.match_number">1</stringProp>
          </RegexExtractor>
          <hashTree/>
          <RegexExtractor guiclass="RegexExtractorGui" testclass="RegexExtractor" testname="id_token" enabled="true">
            <stringProp name="RegexExtractor.useHeaders">false</stringProp>
            <stringProp name="RegexExtractor.refname">id_token</stringProp>
            <stringProp name="RegexExtractor.regex">&quot;id_token&quot;:&quot;(.*?)&quot;</stringProp>
            <stringProp name="RegexExtractor.template">$1$</stringProp>
            <stringProp name="RegexExtractor.default"></stringProp>
            <stringProp name="RegexExtractor.match_number">1</stringProp>
          </RegexExtractor>
          <hashTree/>
          <RegexExtractor guiclass="RegexExtractorGui" testclass="RegexExtractor" testname="refresh_token" enabled="true">
            <stringProp name="RegexExtractor.useHeaders">false</stringProp>
            <stringProp name="RegexExtractor.refname">refresh_token</stringProp>
            <stringProp name="RegexExtractor.regex">&quot;refresh_token&quot;:&quot;(.*?)&quot;,</stringProp>
            <stringProp name="RegexExtractor.template">$1$</stringProp>
            <stringProp name="RegexExtractor.default"></stringProp>
            <stringProp name="RegexExtractor.match_number">1</stringProp>
          </RegexExtractor>
          <hashTree/>
        </hashTree>
        <HTTPSamplerProxy guiclass="HttpTestSampleGui" testclass="HTTPSamplerProxy" testname="Basic.ユーザ更新(ID連携)" enabled="true">
          <boolProp name="HTTPSampler.postBodyRaw">true</boolProp>
          <elementProp name="HTTPsampler.Arguments" elementType="Arguments">
            <collectionProp name="Arguments.arguments">
              <elementProp name="" elementType="HTTPArgument">
                <boolProp name="HTTPArgument.always_encode">false</boolProp>
                <stringProp name="Argument.value">{&#xd;
  &quot;entry&quot;: [&#xd;
    {&#xd;
      &quot;apps&quot;: [&#xd;
        {&#xd;
          &quot;value&quot;: {&#xd;
            &quot;appId&quot;: &quot;00000&quot;,&#xd;
            &quot;userId&quot;: &quot;basic_test_5&quot;,&#xd;
            &quot;username&quot;: &quot;trustedproxy_basic_5&quot;,&#xd;
            &quot;password&quot;: &quot;gesuno&quot;&#xd;
          }&#xd;
        }&#xd;
      ]&#xd;
    }&#xd;
  ]&#xd;
}</stringProp>
                <stringProp name="Argument.metadata">=</stringProp>
              </elementProp>
            </collectionProp>
          </elementProp>
          <stringProp name="HTTPSampler.domain"></stringProp>
          <stringProp name="HTTPSampler.port"></stringProp>
          <stringProp name="HTTPSampler.connect_timeout"></stringProp>
          <stringProp name="HTTPSampler.response_timeout"></stringProp>
          <stringProp name="HTTPSampler.protocol"></stringProp>
          <stringProp name="HTTPSampler.contentEncoding"></stringProp>
          <stringProp name="HTTPSampler.path">/marvelous/people/@me/@self?access_token=${access_token}&amp;id_token=${id_token}</stringProp>
          <stringProp name="HTTPSampler.method">PUT</stringProp>
          <boolProp name="HTTPSampler.follow_redirects">true</boolProp>
          <boolProp name="HTTPSampler.auto_redirects">false</boolProp>
          <boolProp name="HTTPSampler.use_keepalive">true</boolProp>
          <boolProp name="HTTPSampler.DO_MULTIPART_POST">false</boolProp>
          <boolProp name="HTTPSampler.monitor">false</boolProp>
          <stringProp name="HTTPSampler.embedded_url_re"></stringProp>
        </HTTPSamplerProxy>
        <hashTree>
          <BSFPreProcessor guiclass="TestBeanGUI" testclass="BSFPreProcessor" testname="BSF PreProcessor" enabled="true">
            <stringProp name="filename"></stringProp>
            <stringProp name="parameters"></stringProp>
            <stringProp name="script">/*
 * A JavaScript implementation of the Secure Hash Algorithm, SHA-1, as defined
 * in FIPS PUB 180-1
 * Version 2.1a Copyright Paul Johnston 2000 - 2002.
 * Other contributors: Greg Holt, Andrew Kepert, Ydnar, Lostinet
 * Distributed under the BSD License
 * See http://pajhome.org.uk/crypt/md5 for details.
 */

/*
 * Configurable variables. You may need to tweak these to be compatible with
 * the server-side, but the defaults work in most cases.
 */
var hexcase = 0;  /* hex output format. 0 - lowercase; 1 - uppercase        */
var b64pad  = &quot;&quot;; /* base-64 pad character. &quot;=&quot; for strict RFC compliance   */
var chrsz   = 8;  /* bits per input character. 8 - ASCII; 16 - Unicode      */

/*
 * These are the functions you&apos;ll usually want to call
 * They take string arguments and return either hex or base-64 encoded strings
 */
function hex_sha1(s){return binb2hex(core_sha1(str2binb(s),s.length * chrsz));}
function b64_sha1(s){return binb2b64(core_sha1(str2binb(s),s.length * chrsz));}
function str_sha1(s){return binb2str(core_sha1(str2binb(s),s.length * chrsz));}
function hex_hmac_sha1(key, data){ return binb2hex(core_hmac_sha1(key, data));}
function b64_hmac_sha1(key, data){ return binb2b64(core_hmac_sha1(key, data));}
function str_hmac_sha1(key, data){ return binb2str(core_hmac_sha1(key, data));}

/*
 * Perform a simple self-test to see if the VM is working
 */
function sha1_vm_test()
{
  return hex_sha1(&quot;abc&quot;) == &quot;a9993e364706816aba3e25717850c26c9cd0d89d&quot;;
}

/*
 * Calculate the SHA-1 of an array of big-endian words, and a bit length
 */
function core_sha1(x, len)
{
  /* append padding */
  x[len &gt;&gt; 5] |= 0x80 &lt;&lt; (24 - len % 32);
  x[((len + 64 &gt;&gt; 9) &lt;&lt; 4) + 15] = len;

  var w = Array(80);
  var a =  1732584193;
  var b = -271733879;
  var c = -1732584194;
  var d =  271733878;
  var e = -1009589776;

  for(var i = 0; i &lt; x.length; i += 16)
  {
    var olda = a;
    var oldb = b;
    var oldc = c;
    var oldd = d;
    var olde = e;

    for(var j = 0; j &lt; 80; j++)
    {
      if(j &lt; 16) w[j] = x[i + j];
      else w[j] = rol(w[j-3] ^ w[j-8] ^ w[j-14] ^ w[j-16], 1);
      var t = safe_add(safe_add(rol(a, 5), sha1_ft(j, b, c, d)),
                       safe_add(safe_add(e, w[j]), sha1_kt(j)));
      e = d;
      d = c;
      c = rol(b, 30);
      b = a;
      a = t;
    }

    a = safe_add(a, olda);
    b = safe_add(b, oldb);
    c = safe_add(c, oldc);
    d = safe_add(d, oldd);
    e = safe_add(e, olde);
  }
  return Array(a, b, c, d, e);

}

/*
 * Perform the appropriate triplet combination function for the current
 * iteration
 */
function sha1_ft(t, b, c, d)
{
  if(t &lt; 20) return (b &amp; c) | ((~b) &amp; d);
  if(t &lt; 40) return b ^ c ^ d;
  if(t &lt; 60) return (b &amp; c) | (b &amp; d) | (c &amp; d);
  return b ^ c ^ d;
}

/*
 * Determine the appropriate additive constant for the current iteration
 */
function sha1_kt(t)
{
  return (t &lt; 20) ?  1518500249 : (t &lt; 40) ?  1859775393 :
         (t &lt; 60) ? -1894007588 : -899497514;
}

/*
 * Calculate the HMAC-SHA1 of a key and some data
 */
function core_hmac_sha1(key, data)
{
  var bkey = str2binb(key);
  if(bkey.length &gt; 16) bkey = core_sha1(bkey, key.length * chrsz);

  var ipad = Array(16), opad = Array(16);
  for(var i = 0; i &lt; 16; i++)
  {
    ipad[i] = bkey[i] ^ 0x36363636;
    opad[i] = bkey[i] ^ 0x5C5C5C5C;
  }

  var hash = core_sha1(ipad.concat(str2binb(data)), 512 + data.length * chrsz);
  return core_sha1(opad.concat(hash), 512 + 160);
}

/*
 * Add integers, wrapping at 2^32. This uses 16-bit operations internally
 * to work around bugs in some JS interpreters.
 */
function safe_add(x, y)
{
  var lsw = (x &amp; 0xFFFF) + (y &amp; 0xFFFF);
  var msw = (x &gt;&gt; 16) + (y &gt;&gt; 16) + (lsw &gt;&gt; 16);
  return (msw &lt;&lt; 16) | (lsw &amp; 0xFFFF);
}

/*
 * Bitwise rotate a 32-bit number to the left.
 */
function rol(num, cnt)
{
  return (num &lt;&lt; cnt) | (num &gt;&gt;&gt; (32 - cnt));
}

/*
 * Convert an 8-bit or 16-bit string to an array of big-endian words
 * In 8-bit function, characters &gt;255 have their hi-byte silently ignored.
 */
function str2binb(str)
{
  var bin = Array();
  var mask = (1 &lt;&lt; chrsz) - 1;
  for(var i = 0; i &lt; str.length * chrsz; i += chrsz)
    bin[i&gt;&gt;5] |= (str.charCodeAt(i / chrsz) &amp; mask) &lt;&lt; (32 - chrsz - i%32);
  return bin;
}

/*
 * Convert an array of big-endian words to a string
 */
function binb2str(bin)
{
  var str = &quot;&quot;;
  var mask = (1 &lt;&lt; chrsz) - 1;
  for(var i = 0; i &lt; bin.length * 32; i += chrsz)
    str += String.fromCharCode((bin[i&gt;&gt;5] &gt;&gt;&gt; (32 - chrsz - i%32)) &amp; mask);
  return str;
}

/*
 * Convert an array of big-endian words to a hex string.
 */
function binb2hex(binarray)
{
  var hex_tab = hexcase ? &quot;0123456789ABCDEF&quot; : &quot;0123456789abcdef&quot;;
  var str = &quot;&quot;;
  for(var i = 0; i &lt; binarray.length * 4; i++)
  {
    str += hex_tab.charAt((binarray[i&gt;&gt;2] &gt;&gt; ((3 - i%4)*8+4)) &amp; 0xF) +
           hex_tab.charAt((binarray[i&gt;&gt;2] &gt;&gt; ((3 - i%4)*8  )) &amp; 0xF);
  }
  return str;
}

/*
 * Convert an array of big-endian words to a base-64 string
 */
function binb2b64(binarray)
{
  var tab = &quot;ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/&quot;;
  var str = &quot;&quot;;
  for(var i = 0; i &lt; binarray.length * 4; i += 3)
  {
    var triplet = (((binarray[i   &gt;&gt; 2] &gt;&gt; 8 * (3 -  i   %4)) &amp; 0xFF) &lt;&lt; 16)
                | (((binarray[i+1 &gt;&gt; 2] &gt;&gt; 8 * (3 - (i+1)%4)) &amp; 0xFF) &lt;&lt; 8 )
                |  ((binarray[i+2 &gt;&gt; 2] &gt;&gt; 8 * (3 - (i+2)%4)) &amp; 0xFF);
    for(var j = 0; j &lt; 4; j++)
    {
      if(i * 8 + j * 6 &gt; binarray.length * 32) str += b64pad;
      else str += tab.charAt((triplet &gt;&gt; 6*(3-j)) &amp; 0x3F);
    }
  }
  return str;
}

/*
 * Copyright 2008 Netflix, Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/* Here&apos;s some JavaScript software for implementing OAuth.

   This isn&apos;t as useful as you might hope.  OAuth is based around
   allowing tools and websites to talk to each other.  However,
   JavaScript running in web browsers is hampered by security
   restrictions that prevent code running on one website from
   accessing data stored or served on another.

   Before you start hacking, make sure you understand the limitations
   posed by cross-domain XMLHttpRequest.

   On the bright side, some platforms use JavaScript as their
   language, but enable the programmer to access other web sites.
   Examples include Google Gadgets, and Microsoft Vista Sidebar.
   For those platforms, this library should come in handy.
*/

// The HMAC-SHA1 signature method calls b64_hmac_sha1, defined by
// http://pajhome.org.uk/crypt/md5/sha1.js

/* An OAuth message is represented as an object like this:
   {method: &quot;GET&quot;, action: &quot;http://server.com/path&quot;, parameters: ...}

   The parameters may be either a map {name: value, name2: value2}
   or an Array of name-value pairs [[name, value], [name2, value2]].
   The latter representation is more powerful: it supports parameters
   in a specific sequence, or several parameters with the same name;
   for example [[&quot;a&quot;, 1], [&quot;b&quot;, 2], [&quot;a&quot;, 3]].

   Parameter names and values are NOT percent-encoded in an object.
   They must be encoded before transmission and decoded after reception.
   For example, this message object:
   {method: &quot;GET&quot;, action: &quot;http://server/path&quot;, parameters: {p: &quot;x y&quot;}}
   ... can be transmitted as an HTTP request that begins:
   GET /path?p=x%20y HTTP/1.0
   (This isn&apos;t a valid OAuth request, since it lacks a signature etc.)
   Note that the object &quot;x y&quot; is transmitted as x%20y.  To encode
   parameters, you can call OAuth.addToURL, OAuth.formEncode or
   OAuth.getAuthorization.

   This message object model harmonizes with the browser object model for
   input elements of an form, whose value property isn&apos;t percent encoded.
   The browser encodes each value before transmitting it. For example,
   see consumer.setInputs in example/consumer.js.
 */

/* This script needs to know what time it is. By default, it uses the local
   clock (new Date), which is apt to be inaccurate in browsers. To do
   better, you can load this script from a URL whose query string contains
   an oauth_timestamp parameter, whose value is a current Unix timestamp.
   For example, when generating the enclosing document using PHP:

   &lt;script src=&quot;oauth.js?oauth_timestamp=&lt;?=time()?&gt;&quot; ...

   Another option is to call OAuth.correctTimestamp with a Unix timestamp.
 */

var OAuth; if (OAuth == null) OAuth = {};

OAuth.setProperties = function setProperties(into, from) {
    if (into != null &amp;&amp; from != null) {
        for (var key in from) {
            into[key] = from[key];
        }
    }
    return into;
}

OAuth.setProperties(OAuth, // utility functions
{
    percentEncode: function percentEncode(s) {
        if (s == null) {
            return &quot;&quot;;
        }
        if (s instanceof Array) {
            var e = &quot;&quot;;
            for (var i = 0; i &lt; s.length; ++s) {
                if (e != &quot;&quot;) e += &apos;&amp;&apos;;
                e += OAuth.percentEncode(s[i]);
            }
            return e;
        }
        s = encodeURIComponent(s);
        // Now replace the values which encodeURIComponent doesn&apos;t do
        // encodeURIComponent ignores: - _ . ! ~ * &apos; ( )
        // OAuth dictates the only ones you can ignore are: - _ . ~
        // Source: http://developer.mozilla.org/en/docs/Core_JavaScript_1.5_Reference:Global_Functions:encodeURIComponent
        s = s.replace(/\!/g, &quot;%21&quot;);
        s = s.replace(/\*/g, &quot;%2A&quot;);
        s = s.replace(/\&apos;/g, &quot;%27&quot;);
        s = s.replace(/\(/g, &quot;%28&quot;);
        s = s.replace(/\)/g, &quot;%29&quot;);
        return s;
    }
,
    decodePercent: function decodePercent(s) {
        if (s != null) {
            // Handle application/x-www-form-urlencoded, which is defined by
            // http://www.w3.org/TR/html4/interact/forms.html#h-17.13.4.1
            s = s.replace(/\+/g, &quot; &quot;);
        }
        return decodeURIComponent(s);
    }
,
    /** Convert the given parameters to an Array of name-value pairs. */
    getParameterList: function getParameterList(parameters) {
        if (parameters == null) {
            return [];
        }
        if (typeof parameters != &quot;object&quot;) {
            return OAuth.decodeForm(parameters + &quot;&quot;);
        }
        if (parameters instanceof Array) {
            return parameters;
        }
        var list = [];
        for (var p in parameters) {
            list.push([p, parameters[p]]);
        }
        return list;
    }
,
    /** Convert the given parameters to a map from name to value. */
    getParameterMap: function getParameterMap(parameters) {
        if (parameters == null) {
            return {};
        }
        if (typeof parameters != &quot;object&quot;) {
            return OAuth.getParameterMap(OAuth.decodeForm(parameters + &quot;&quot;));
        }
        if (parameters instanceof Array) {
            var map = {};
            for (var p = 0; p &lt; parameters.length; ++p) {
                var key = parameters[p][0];
                if (map[key] === undefined) { // first value wins
                    map[key] = parameters[p][1];
                }
            }
            return map;
        }
        return parameters;
    }
,
    getParameter: function getParameter(parameters, name) {
        if (parameters instanceof Array) {
            for (var p = 0; p &lt; parameters.length; ++p) {
                if (parameters[p][0] == name) {
                    return parameters[p][1]; // first value wins
                }
            }
        } else {
            return OAuth.getParameterMap(parameters)[name];
        }
        return null;
    }
,
    formEncode: function formEncode(parameters) {
        var form = &quot;&quot;;
        var list = OAuth.getParameterList(parameters);
        for (var p = 0; p &lt; list.length; ++p) {
            var value = list[p][1];
            if (value == null) value = &quot;&quot;;
            if (form != &quot;&quot;) form += &apos;&amp;&apos;;
            form += OAuth.percentEncode(list[p][0])
              +&apos;=&apos;+ OAuth.percentEncode(value);
        }
        return form;
    }
,
    decodeForm: function decodeForm(form) {
        var list = [];
        var nvps = form.split(&apos;&amp;&apos;);
        for (var n = 0; n &lt; nvps.length; ++n) {
            var nvp = nvps[n];
            if (nvp == &quot;&quot;) {
                continue;
            }
            var equals = nvp.indexOf(&apos;=&apos;);
            var name;
            var value;
            if (equals &lt; 0) {
                name = OAuth.decodePercent(nvp);
                value = null;
            } else {
                name = OAuth.decodePercent(nvp.substring(0, equals));
                value = OAuth.decodePercent(nvp.substring(equals + 1));
            }
            list.push([name, value]);
        }
        return list;
    }
,
    setParameter: function setParameter(message, name, value) {
        var parameters = message.parameters;
        if (parameters instanceof Array) {
            for (var p = 0; p &lt; parameters.length; ++p) {
                if (parameters[p][0] == name) {
                    if (value === undefined) {
                        parameters.splice(p, 1);
                    } else {
                        parameters[p][1] = value;
                        value = undefined;
                    }
                }
            }
            if (value !== undefined) {
                parameters.push([name, value]);
            }
        } else {
            parameters = OAuth.getParameterMap(parameters);
            parameters[name] = value;
            message.parameters = parameters;
        }
    }
,
    setParameters: function setParameters(message, parameters) {
        var list = OAuth.getParameterList(parameters);
        for (var i = 0; i &lt; list.length; ++i) {
            OAuth.setParameter(message, list[i][0], list[i][1]);
        }
    }
,
    /** Fill in parameters to help construct a request message.
        This function doesn&apos;t fill in every parameter.
        The accessor object should be like:
        {consumerKey:&apos;foo&apos;, consumerSecret:&apos;bar&apos;, accessorSecret:&apos;nurn&apos;, token:&apos;krelm&apos;, tokenSecret:&apos;blah&apos;}
        The accessorSecret property is optional.
     */
    completeRequest: function completeRequest(message, accessor) {
        if (message.method == null) {
            message.method = &quot;GET&quot;;
        }
        var map = OAuth.getParameterMap(message.parameters);
        if (map.oauth_consumer_key == null) {
            OAuth.setParameter(message, &quot;oauth_consumer_key&quot;, accessor.consumerKey || &quot;&quot;);
        }
        if (map.oauth_token == null &amp;&amp; accessor.token != null) {
            OAuth.setParameter(message, &quot;oauth_token&quot;, accessor.token);
        }
        if (map.oauth_version == null) {
            OAuth.setParameter(message, &quot;oauth_version&quot;, &quot;1.0&quot;);
        }
        if (map.oauth_timestamp == null) {
            OAuth.setParameter(message, &quot;oauth_timestamp&quot;, OAuth.timestamp());
        }
        if (map.oauth_nonce == null) {
            OAuth.setParameter(message, &quot;oauth_nonce&quot;, OAuth.nonce(6));
        }
        OAuth.SignatureMethod.sign(message, accessor);
    }
,
    setTimestampAndNonce: function setTimestampAndNonce(message) {
        OAuth.setParameter(message, &quot;oauth_timestamp&quot;, OAuth.timestamp());
        OAuth.setParameter(message, &quot;oauth_nonce&quot;, OAuth.nonce(6));
    }
,
    addToURL: function addToURL(url, parameters) {
        newURL = url;
        if (parameters != null) {
            var toAdd = OAuth.formEncode(parameters);
            if (toAdd.length &gt; 0) {
                var q = url.indexOf(&apos;?&apos;);
                if (q &lt; 0) newURL += &apos;?&apos;;
                else       newURL += &apos;&amp;&apos;;
                newURL += toAdd;
            }
        }
        return newURL;
    }
,
    /** Construct the value of the Authorization header for an HTTP request. */
    getAuthorizationHeader: function getAuthorizationHeader(realm, parameters) {
        var header = &apos;OAuth realm=&quot;&apos; + OAuth.percentEncode(realm) + &apos;&quot;&apos;;
        var list = OAuth.getParameterList(parameters);
        for (var p = 0; p &lt; list.length; ++p) {
            var parameter = list[p];
            var name = parameter[0];
            if (name.indexOf(&quot;oauth_&quot;) == 0) {
                header += &apos;,&apos; + OAuth.percentEncode(name) + &apos;=&quot;&apos; + OAuth.percentEncode(parameter[1]) + &apos;&quot;&apos;;
            }
        }
        return header;
    }
,
    /** Correct the time using a parameter from the URL from which the last script was loaded. */
    correctTimestampFromSrc: function correctTimestampFromSrc(parameterName) {
        parameterName = parameterName || &quot;oauth_timestamp&quot;;
        var scripts = document.getElementsByTagName(&apos;script&apos;);
        if (scripts == null || !scripts.length) return;
        var src = scripts[scripts.length-1].src;
        if (!src) return;
        var q = src.indexOf(&quot;?&quot;);
        if (q &lt; 0) return;
        parameters = OAuth.getParameterMap(OAuth.decodeForm(src.substring(q+1)));
        var t = parameters[parameterName];
        if (t == null) return;
        OAuth.correctTimestamp(t);
    }
,
    /** Generate timestamps starting with the given value. */
    correctTimestamp: function correctTimestamp(timestamp) {
        OAuth.timeCorrectionMsec = (timestamp * 1000) - (new Date()).getTime();
    }
,
    /** The difference between the correct time and my clock. */
    timeCorrectionMsec: 0
,
    timestamp: function timestamp() {
        var t = (new Date()).getTime() + OAuth.timeCorrectionMsec;
        return Math.floor(t / 1000);
    }
,
    nonce: function nonce(length) {
        var chars = OAuth.nonce.CHARS;
        var result = &quot;&quot;;
        for (var i = 0; i &lt; length; ++i) {
            var rnum = Math.floor(Math.random() * chars.length);
            result += chars.substring(rnum, rnum+1);
        }
        return result;
    }
});

OAuth.nonce.CHARS = &quot;0123456789ABCDEFGHIJKLMNOPQRSTUVWXTZabcdefghiklmnopqrstuvwxyz&quot;;

/** Define a constructor function,
    without causing trouble to anyone who was using it as a namespace.
    That is, if parent[name] already existed and had properties,
    copy those properties into the new constructor.
 */
OAuth.declareClass = function declareClass(parent, name, newConstructor) {
    var previous = parent[name];
    parent[name] = newConstructor;
    if (newConstructor != null &amp;&amp; previous != null) {
        for (var key in previous) {
            if (key != &quot;prototype&quot;) {
                newConstructor[key] = previous[key];
            }
        }
    }
    return newConstructor;
}

/** An abstract algorithm for signing messages. */
OAuth.declareClass(OAuth, &quot;SignatureMethod&quot;, function OAuthSignatureMethod(){});

OAuth.setProperties(OAuth.SignatureMethod.prototype, // instance members
{
    /** Add a signature to the message. */
    sign: function sign(message) {
        var baseString = OAuth.SignatureMethod.getBaseString(message);
        var signature = this.getSignature(baseString);
        OAuth.setParameter(message, &quot;oauth_signature&quot;, signature);
        return signature; // just in case someone&apos;s interested
    }
,
    /** Set the key string for signing. */
    initialize: function initialize(name, accessor) {
        var consumerSecret;
        if (accessor.accessorSecret != null
            &amp;&amp; name.length &gt; 9
            &amp;&amp; name.substring(name.length-9) == &quot;-Accessor&quot;)
        {
            consumerSecret = accessor.accessorSecret;
        } else {
            consumerSecret = accessor.consumerSecret;
        }
        this.key = OAuth.percentEncode(consumerSecret)
             +&quot;&amp;&quot;+ OAuth.percentEncode(accessor.tokenSecret);
    }
});

/* SignatureMethod expects an accessor object to be like this:
   {tokenSecret: &quot;lakjsdflkj...&quot;, consumerSecret: &quot;QOUEWRI..&quot;, accessorSecret: &quot;xcmvzc...&quot;}
   The accessorSecret property is optional.
 */
// Class members:
OAuth.setProperties(OAuth.SignatureMethod, // class members
{
    sign: function sign(message, accessor) {
        var name = OAuth.getParameterMap(message.parameters).oauth_signature_method;
        if (name == null || name == &quot;&quot;) {
            name = &quot;HMAC-SHA1&quot;;
            OAuth.setParameter(message, &quot;oauth_signature_method&quot;, name);
        }
        OAuth.SignatureMethod.newMethod(name, accessor).sign(message);
    }
,
    /** Instantiate a SignatureMethod for the given method name. */
    newMethod: function newMethod(name, accessor) {
        var impl = OAuth.SignatureMethod.REGISTERED[name];
        if (impl != null) {
            var method = new impl();
            method.initialize(name, accessor);
            return method;
        }
        var err = new Error(&quot;signature_method_rejected&quot;);
        var acceptable = &quot;&quot;;
        for (var r in OAuth.SignatureMethod.REGISTERED) {
            if (acceptable != &quot;&quot;) acceptable += &apos;&amp;&apos;;
            acceptable += OAuth.percentEncode(r);
        }
        err.oauth_acceptable_signature_methods = acceptable;
        throw err;
    }
,
    /** A map from signature method name to constructor. */
    REGISTERED : {}
,
    /** Subsequently, the given constructor will be used for the named methods.
        The constructor will be called with no parameters.
        The resulting object should usually implement getSignature(baseString).
        You can easily define such a constructor by calling makeSubclass, below.
     */
    registerMethodClass: function registerMethodClass(names, classConstructor) {
        for (var n = 0; n &lt; names.length; ++n) {
            OAuth.SignatureMethod.REGISTERED[names[n]] = classConstructor;
        }
    }
,
    /** Create a subclass of OAuth.SignatureMethod, with the given getSignature function. */
    makeSubclass: function makeSubclass(getSignatureFunction) {
        var superClass = OAuth.SignatureMethod;
        var subClass = function() {
            superClass.call(this);
        };
        subClass.prototype = new superClass();
        // Delete instance variables from prototype:
        // delete subclass.prototype... There aren&apos;t any.
        subClass.prototype.getSignature = getSignatureFunction;
        subClass.prototype.constructor = subClass;
        return subClass;
    }
,
    getBaseString: function getBaseString(message) {
        var URL = message.action;
        var q = URL.indexOf(&apos;?&apos;);
        var parameters;
        if (q &lt; 0) {
            parameters = message.parameters;
        } else {
            // Combine the URL query string with the other parameters:
            parameters = OAuth.decodeForm(URL.substring(q + 1));
            var toAdd = OAuth.getParameterList(message.parameters);
            for (var a = 0; a &lt; toAdd.length; ++a) {
                parameters.push(toAdd[a]);
            }
        }
        return OAuth.percentEncode(message.method.toUpperCase())
         +&apos;&amp;&apos;+ OAuth.percentEncode(OAuth.SignatureMethod.normalizeUrl(URL))
         +&apos;&amp;&apos;+ OAuth.percentEncode(OAuth.SignatureMethod.normalizeParameters(parameters));
    }
,
    normalizeUrl: function normalizeUrl(url) {
        var uri = OAuth.SignatureMethod.parseUri(url);
        var scheme = uri.protocol.toLowerCase();
        var authority = uri.authority.toLowerCase();
        var dropPort = (scheme == &quot;http&quot; &amp;&amp; uri.port == 80)
                    || (scheme == &quot;https&quot; &amp;&amp; uri.port == 443);
        if (dropPort) {
            // find the last : in the authority
            var index = authority.lastIndexOf(&quot;:&quot;);
            if (index &gt;= 0) {
                authority = authority.substring(0, index);
            }
        }
        var path = uri.path;
        if (!path) {
            path = &quot;/&quot;; // conforms to RFC 2616 section 3.2.2
        }
        // we know that there is no query and no fragment here.
        return scheme + &quot;://&quot; + authority + path;
    }
,
    parseUri: function parseUri (str) {
        /* This function was adapted from parseUri 1.2.1
           http://stevenlevithan.com/demo/parseuri/js/assets/parseuri.js
         */
        var o = {key: [&quot;source&quot;,&quot;protocol&quot;,&quot;authority&quot;,&quot;userInfo&quot;,&quot;user&quot;,&quot;password&quot;,&quot;host&quot;,&quot;port&quot;,&quot;relative&quot;,&quot;path&quot;,&quot;directory&quot;,&quot;file&quot;,&quot;query&quot;,&quot;anchor&quot;],
                 parser: {strict: /^(?:([^:\/?#]+):)?(?:\/\/((?:(([^:@\/]*):?([^:@\/]*))?@)?([^:\/?#]*)(?::(\d*))?))?((((?:[^?#\/]*\/)*)([^?#]*))(?:\?([^#]*))?(?:#(.*))?)/ }};
        var m = o.parser.strict.exec(str);
        var uri = {};
        var i = 14;
        while (i--) uri[o.key[i]] = m[i] || &quot;&quot;;
        return uri;
    }
,
    normalizeParameters: function normalizeParameters(parameters) {
        if (parameters == null) {
            return &quot;&quot;;
        }
        var list = OAuth.getParameterList(parameters);
        var sortable = [];
        for (var p = 0; p &lt; list.length; ++p) {
            var nvp = list[p];
            if (nvp[0] != &quot;oauth_signature&quot;) {
                sortable.push([ OAuth.percentEncode(nvp[0])
                              + &quot; &quot; // because it comes before any character that can appear in a percentEncoded string.
                              + OAuth.percentEncode(nvp[1])
                              , nvp]);
            }
        }
        sortable.sort(function(a,b) {
                          if (a[0] &lt; b[0]) return  -1;
                          if (a[0] &gt; b[0]) return 1;
                          return 0;
                      });
        var sorted = [];
        for (var s = 0; s &lt; sortable.length; ++s) {
            sorted.push(sortable[s][1]);
        }
        return OAuth.formEncode(sorted);
    }
});

OAuth.SignatureMethod.registerMethodClass([&quot;PLAINTEXT&quot;, &quot;PLAINTEXT-Accessor&quot;],
    OAuth.SignatureMethod.makeSubclass(
        function getSignature(baseString) {
            return this.key;
        }
    ));

OAuth.SignatureMethod.registerMethodClass([&quot;HMAC-SHA1&quot;, &quot;HMAC-SHA1-Accessor&quot;],
    OAuth.SignatureMethod.makeSubclass(
        function getSignature(baseString) {
            b64pad = &apos;=&apos;;
            var signature = b64_hmac_sha1(this.key, baseString);
            return signature;
        }
    ));

try {
    OAuth.correctTimestampFromSrc();
} catch(e) {
}


//--------------------------------------------------

var consumerKey = &quot;${consumer_key}&quot;;
var consumerSecret = &quot;${consumer_secret}&quot;;
var params = [];
var query = [];
query.push(&apos;access_token&apos; + &apos;=&apos; + &apos;${access_token}&apos;);
query.push(&apos;id_token&apos; + &apos;=&apos; + &apos;${id_token}&apos;);
var url =  &quot;${protocol}://${misp_url}/marvelous/people/@me/@self&quot;;

if (query.length) {
    url += &apos;?&apos; + query.join(&apos;&amp;&apos;);
}

var message = {
    method: &apos;put&apos;,
    parameters: params, 
    action: url
};

log.info(url);
log.info(consumerSecret);

var accessor = {
    consumerKey: consumerKey,
    consumerSecret: consumerSecret,
    token:  &apos;${access_token}&apos;,
    tokenSecret: &apos;${id_token}&apos;
};

OAuth.completeRequest(message, accessor);
vars.put(&apos;put_auth_header&apos;, OAuth.getAuthorizationHeader(&apos;&apos;, params).replace(&apos;OAuth realm=&quot;&quot;,&apos;, &apos; OAuth &apos;));
</stringProp>
            <stringProp name="scriptLanguage">javascript</stringProp>
          </BSFPreProcessor>
          <hashTree/>
          <HeaderManager guiclass="HeaderPanel" testclass="HeaderManager" testname="HTTP ヘッダマネージャ" enabled="true">
            <collectionProp name="HeaderManager.headers">
              <elementProp name="" elementType="Header">
                <stringProp name="Header.name">Authorization</stringProp>
                <stringProp name="Header.value">${put_auth_header}</stringProp>
              </elementProp>
              <elementProp name="" elementType="Header">
                <stringProp name="Header.name">content-type</stringProp>
                <stringProp name="Header.value">application/json; charset=utf8</stringProp>
              </elementProp>
              <elementProp name="" elementType="Header">
                <stringProp name="Header.name">Connection</stringProp>
                <stringProp name="Header.value">close</stringProp>
              </elementProp>
              <elementProp name="" elementType="Header">
                <stringProp name="Header.name">Accept-encoding</stringProp>
                <stringProp name="Header.value">gzip, deflate</stringProp>
              </elementProp>
            </collectionProp>
          </HeaderManager>
          <hashTree/>
          <RegexExtractor guiclass="RegexExtractorGui" testclass="RegexExtractor" testname="access_token" enabled="true">
            <stringProp name="RegexExtractor.useHeaders">false</stringProp>
            <stringProp name="RegexExtractor.refname">access_token</stringProp>
            <stringProp name="RegexExtractor.regex">&quot;accessToken&quot;:&quot;(.*?)&quot;</stringProp>
            <stringProp name="RegexExtractor.template">$1$</stringProp>
            <stringProp name="RegexExtractor.default"></stringProp>
            <stringProp name="RegexExtractor.match_number">1</stringProp>
          </RegexExtractor>
          <hashTree/>
          <RegexExtractor guiclass="RegexExtractorGui" testclass="RegexExtractor" testname="id_token" enabled="true">
            <stringProp name="RegexExtractor.useHeaders">false</stringProp>
            <stringProp name="RegexExtractor.refname">id_token</stringProp>
            <stringProp name="RegexExtractor.regex">&quot;idToken&quot;:&quot;(.*?)&quot;</stringProp>
            <stringProp name="RegexExtractor.template">$1$</stringProp>
            <stringProp name="RegexExtractor.default"></stringProp>
            <stringProp name="RegexExtractor.match_number">1</stringProp>
          </RegexExtractor>
          <hashTree/>
          <ResponseAssertion guiclass="AssertionGui" testclass="ResponseAssertion" testname="アサーション" enabled="true">
            <collectionProp name="Asserion.test_strings">
              <stringProp name="1660111156">&quot;password&quot;:&quot;gesuno&quot;</stringProp>
              <stringProp name="1437218324">&quot;username&quot;:&quot;trustedproxy_basic_5&quot;</stringProp>
            </collectionProp>
            <stringProp name="TestPlan.comments">確認項目
パスワードが空になっていないか？</stringProp>
            <stringProp name="Assertion.test_field">Assertion.response_data</stringProp>
            <boolProp name="Assertion.assume_success">false</boolProp>
            <intProp name="Assertion.test_type">2</intProp>
          </ResponseAssertion>
          <hashTree/>
        </hashTree>
        <HTTPSamplerProxy guiclass="HttpTestSampleGui" testclass="HTTPSamplerProxy" testname="Basic.トークンリフレッシュ" enabled="true">
          <elementProp name="HTTPsampler.Arguments" elementType="Arguments" guiclass="HTTPArgumentsPanel" testclass="Arguments" enabled="true">
            <collectionProp name="Arguments.arguments">
              <elementProp name="grant_type" elementType="HTTPArgument">
                <boolProp name="HTTPArgument.always_encode">false</boolProp>
                <stringProp name="Argument.value">refresh_token</stringProp>
                <stringProp name="Argument.metadata">=</stringProp>
                <boolProp name="HTTPArgument.use_equals">true</boolProp>
                <stringProp name="Argument.name">grant_type</stringProp>
              </elementProp>
              <elementProp name="refresh_token" elementType="HTTPArgument">
                <boolProp name="HTTPArgument.always_encode">false</boolProp>
                <stringProp name="Argument.value">${refresh_token}</stringProp>
                <stringProp name="Argument.metadata">=</stringProp>
                <boolProp name="HTTPArgument.use_equals">true</boolProp>
                <stringProp name="Argument.name">refresh_token</stringProp>
              </elementProp>
              <elementProp name="redirect_uri" elementType="HTTPArgument">
                <boolProp name="HTTPArgument.always_encode">false</boolProp>
                <stringProp name="Argument.value">${protocol}%3A%2F%2F${jmeter_path}%2Ftest%2Fmisp%2Fmisp-callback</stringProp>
                <stringProp name="Argument.metadata">=</stringProp>
                <boolProp name="HTTPArgument.use_equals">true</boolProp>
                <stringProp name="Argument.name">redirect_uri</stringProp>
              </elementProp>
            </collectionProp>
          </elementProp>
          <stringProp name="HTTPSampler.domain">${misp_url}</stringProp>
          <stringProp name="HTTPSampler.port"></stringProp>
          <stringProp name="HTTPSampler.connect_timeout"></stringProp>
          <stringProp name="HTTPSampler.response_timeout"></stringProp>
          <stringProp name="HTTPSampler.protocol">${protocol}</stringProp>
          <stringProp name="HTTPSampler.contentEncoding"></stringProp>
          <stringProp name="HTTPSampler.path">/marvelous/token</stringProp>
          <stringProp name="HTTPSampler.method">POST</stringProp>
          <boolProp name="HTTPSampler.follow_redirects">true</boolProp>
          <boolProp name="HTTPSampler.auto_redirects">false</boolProp>
          <boolProp name="HTTPSampler.use_keepalive">true</boolProp>
          <boolProp name="HTTPSampler.DO_MULTIPART_POST">false</boolProp>
          <boolProp name="HTTPSampler.monitor">false</boolProp>
          <stringProp name="HTTPSampler.embedded_url_re"></stringProp>
        </HTTPSamplerProxy>
        <hashTree>
          <BSFPreProcessor guiclass="TestBeanGUI" testclass="BSFPreProcessor" testname="BSF PreProcessor" enabled="true">
            <stringProp name="filename"></stringProp>
            <stringProp name="parameters"></stringProp>
            <stringProp name="script">/*
 * A JavaScript implementation of the Secure Hash Algorithm, SHA-1, as defined
 * in FIPS PUB 180-1
 * Version 2.1a Copyright Paul Johnston 2000 - 2002.
 * Other contributors: Greg Holt, Andrew Kepert, Ydnar, Lostinet
 * Distributed under the BSD License
 * See http://pajhome.org.uk/crypt/md5 for details.
 */

/*
 * Configurable variables. You may need to tweak these to be compatible with
 * the server-side, but the defaults work in most cases.
 */
var hexcase = 0;  /* hex output format. 0 - lowercase; 1 - uppercase        */
var b64pad  = &quot;&quot;; /* base-64 pad character. &quot;=&quot; for strict RFC compliance   */
var chrsz   = 8;  /* bits per input character. 8 - ASCII; 16 - Unicode      */

/*
 * These are the functions you&apos;ll usually want to call
 * They take string arguments and return either hex or base-64 encoded strings
 */
function hex_sha1(s){return binb2hex(core_sha1(str2binb(s),s.length * chrsz));}
function b64_sha1(s){return binb2b64(core_sha1(str2binb(s),s.length * chrsz));}
function str_sha1(s){return binb2str(core_sha1(str2binb(s),s.length * chrsz));}
function hex_hmac_sha1(key, data){ return binb2hex(core_hmac_sha1(key, data));}
function b64_hmac_sha1(key, data){ return binb2b64(core_hmac_sha1(key, data));}
function str_hmac_sha1(key, data){ return binb2str(core_hmac_sha1(key, data));}

/*
 * Perform a simple self-test to see if the VM is working
 */
function sha1_vm_test()
{
  return hex_sha1(&quot;abc&quot;) == &quot;a9993e364706816aba3e25717850c26c9cd0d89d&quot;;
}

/*
 * Calculate the SHA-1 of an array of big-endian words, and a bit length
 */
function core_sha1(x, len)
{
  /* append padding */
  x[len &gt;&gt; 5] |= 0x80 &lt;&lt; (24 - len % 32);
  x[((len + 64 &gt;&gt; 9) &lt;&lt; 4) + 15] = len;

  var w = Array(80);
  var a =  1732584193;
  var b = -271733879;
  var c = -1732584194;
  var d =  271733878;
  var e = -1009589776;

  for(var i = 0; i &lt; x.length; i += 16)
  {
    var olda = a;
    var oldb = b;
    var oldc = c;
    var oldd = d;
    var olde = e;

    for(var j = 0; j &lt; 80; j++)
    {
      if(j &lt; 16) w[j] = x[i + j];
      else w[j] = rol(w[j-3] ^ w[j-8] ^ w[j-14] ^ w[j-16], 1);
      var t = safe_add(safe_add(rol(a, 5), sha1_ft(j, b, c, d)),
                       safe_add(safe_add(e, w[j]), sha1_kt(j)));
      e = d;
      d = c;
      c = rol(b, 30);
      b = a;
      a = t;
    }

    a = safe_add(a, olda);
    b = safe_add(b, oldb);
    c = safe_add(c, oldc);
    d = safe_add(d, oldd);
    e = safe_add(e, olde);
  }
  return Array(a, b, c, d, e);

}

/*
 * Perform the appropriate triplet combination function for the current
 * iteration
 */
function sha1_ft(t, b, c, d)
{
  if(t &lt; 20) return (b &amp; c) | ((~b) &amp; d);
  if(t &lt; 40) return b ^ c ^ d;
  if(t &lt; 60) return (b &amp; c) | (b &amp; d) | (c &amp; d);
  return b ^ c ^ d;
}

/*
 * Determine the appropriate additive constant for the current iteration
 */
function sha1_kt(t)
{
  return (t &lt; 20) ?  1518500249 : (t &lt; 40) ?  1859775393 :
         (t &lt; 60) ? -1894007588 : -899497514;
}

/*
 * Calculate the HMAC-SHA1 of a key and some data
 */
function core_hmac_sha1(key, data)
{
  var bkey = str2binb(key);
  if(bkey.length &gt; 16) bkey = core_sha1(bkey, key.length * chrsz);

  var ipad = Array(16), opad = Array(16);
  for(var i = 0; i &lt; 16; i++)
  {
    ipad[i] = bkey[i] ^ 0x36363636;
    opad[i] = bkey[i] ^ 0x5C5C5C5C;
  }

  var hash = core_sha1(ipad.concat(str2binb(data)), 512 + data.length * chrsz);
  return core_sha1(opad.concat(hash), 512 + 160);
}

/*
 * Add integers, wrapping at 2^32. This uses 16-bit operations internally
 * to work around bugs in some JS interpreters.
 */
function safe_add(x, y)
{
  var lsw = (x &amp; 0xFFFF) + (y &amp; 0xFFFF);
  var msw = (x &gt;&gt; 16) + (y &gt;&gt; 16) + (lsw &gt;&gt; 16);
  return (msw &lt;&lt; 16) | (lsw &amp; 0xFFFF);
}

/*
 * Bitwise rotate a 32-bit number to the left.
 */
function rol(num, cnt)
{
  return (num &lt;&lt; cnt) | (num &gt;&gt;&gt; (32 - cnt));
}

/*
 * Convert an 8-bit or 16-bit string to an array of big-endian words
 * In 8-bit function, characters &gt;255 have their hi-byte silently ignored.
 */
function str2binb(str)
{
  var bin = Array();
  var mask = (1 &lt;&lt; chrsz) - 1;
  for(var i = 0; i &lt; str.length * chrsz; i += chrsz)
    bin[i&gt;&gt;5] |= (str.charCodeAt(i / chrsz) &amp; mask) &lt;&lt; (32 - chrsz - i%32);
  return bin;
}

/*
 * Convert an array of big-endian words to a string
 */
function binb2str(bin)
{
  var str = &quot;&quot;;
  var mask = (1 &lt;&lt; chrsz) - 1;
  for(var i = 0; i &lt; bin.length * 32; i += chrsz)
    str += String.fromCharCode((bin[i&gt;&gt;5] &gt;&gt;&gt; (32 - chrsz - i%32)) &amp; mask);
  return str;
}

/*
 * Convert an array of big-endian words to a hex string.
 */
function binb2hex(binarray)
{
  var hex_tab = hexcase ? &quot;0123456789ABCDEF&quot; : &quot;0123456789abcdef&quot;;
  var str = &quot;&quot;;
  for(var i = 0; i &lt; binarray.length * 4; i++)
  {
    str += hex_tab.charAt((binarray[i&gt;&gt;2] &gt;&gt; ((3 - i%4)*8+4)) &amp; 0xF) +
           hex_tab.charAt((binarray[i&gt;&gt;2] &gt;&gt; ((3 - i%4)*8  )) &amp; 0xF);
  }
  return str;
}

/*
 * Convert an array of big-endian words to a base-64 string
 */
function binb2b64(binarray)
{
  var tab = &quot;ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/&quot;;
  var str = &quot;&quot;;
  for(var i = 0; i &lt; binarray.length * 4; i += 3)
  {
    var triplet = (((binarray[i   &gt;&gt; 2] &gt;&gt; 8 * (3 -  i   %4)) &amp; 0xFF) &lt;&lt; 16)
                | (((binarray[i+1 &gt;&gt; 2] &gt;&gt; 8 * (3 - (i+1)%4)) &amp; 0xFF) &lt;&lt; 8 )
                |  ((binarray[i+2 &gt;&gt; 2] &gt;&gt; 8 * (3 - (i+2)%4)) &amp; 0xFF);
    for(var j = 0; j &lt; 4; j++)
    {
      if(i * 8 + j * 6 &gt; binarray.length * 32) str += b64pad;
      else str += tab.charAt((triplet &gt;&gt; 6*(3-j)) &amp; 0x3F);
    }
  }
  return str;
}

/*
 * Copyright 2008 Netflix, Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/* Here&apos;s some JavaScript software for implementing OAuth.

   This isn&apos;t as useful as you might hope.  OAuth is based around
   allowing tools and websites to talk to each other.  However,
   JavaScript running in web browsers is hampered by security
   restrictions that prevent code running on one website from
   accessing data stored or served on another.

   Before you start hacking, make sure you understand the limitations
   posed by cross-domain XMLHttpRequest.

   On the bright side, some platforms use JavaScript as their
   language, but enable the programmer to access other web sites.
   Examples include Google Gadgets, and Microsoft Vista Sidebar.
   For those platforms, this library should come in handy.
*/

// The HMAC-SHA1 signature method calls b64_hmac_sha1, defined by
// http://pajhome.org.uk/crypt/md5/sha1.js

/* An OAuth message is represented as an object like this:
   {method: &quot;GET&quot;, action: &quot;http://server.com/path&quot;, parameters: ...}

   The parameters may be either a map {name: value, name2: value2}
   or an Array of name-value pairs [[name, value], [name2, value2]].
   The latter representation is more powerful: it supports parameters
   in a specific sequence, or several parameters with the same name;
   for example [[&quot;a&quot;, 1], [&quot;b&quot;, 2], [&quot;a&quot;, 3]].

   Parameter names and values are NOT percent-encoded in an object.
   They must be encoded before transmission and decoded after reception.
   For example, this message object:
   {method: &quot;GET&quot;, action: &quot;http://server/path&quot;, parameters: {p: &quot;x y&quot;}}
   ... can be transmitted as an HTTP request that begins:
   GET /path?p=x%20y HTTP/1.0
   (This isn&apos;t a valid OAuth request, since it lacks a signature etc.)
   Note that the object &quot;x y&quot; is transmitted as x%20y.  To encode
   parameters, you can call OAuth.addToURL, OAuth.formEncode or
   OAuth.getAuthorization.

   This message object model harmonizes with the browser object model for
   input elements of an form, whose value property isn&apos;t percent encoded.
   The browser encodes each value before transmitting it. For example,
   see consumer.setInputs in example/consumer.js.
 */

/* This script needs to know what time it is. By default, it uses the local
   clock (new Date), which is apt to be inaccurate in browsers. To do
   better, you can load this script from a URL whose query string contains
   an oauth_timestamp parameter, whose value is a current Unix timestamp.
   For example, when generating the enclosing document using PHP:

   &lt;script src=&quot;oauth.js?oauth_timestamp=&lt;?=time()?&gt;&quot; ...

   Another option is to call OAuth.correctTimestamp with a Unix timestamp.
 */

var OAuth; if (OAuth == null) OAuth = {};

OAuth.setProperties = function setProperties(into, from) {
    if (into != null &amp;&amp; from != null) {
        for (var key in from) {
            into[key] = from[key];
        }
    }
    return into;
}

OAuth.setProperties(OAuth, // utility functions
{
    percentEncode: function percentEncode(s) {
        if (s == null) {
            return &quot;&quot;;
        }
        if (s instanceof Array) {
            var e = &quot;&quot;;
            for (var i = 0; i &lt; s.length; ++s) {
                if (e != &quot;&quot;) e += &apos;&amp;&apos;;
                e += OAuth.percentEncode(s[i]);
            }
            return e;
        }
        s = encodeURIComponent(s);
        // Now replace the values which encodeURIComponent doesn&apos;t do
        // encodeURIComponent ignores: - _ . ! ~ * &apos; ( )
        // OAuth dictates the only ones you can ignore are: - _ . ~
        // Source: http://developer.mozilla.org/en/docs/Core_JavaScript_1.5_Reference:Global_Functions:encodeURIComponent
        s = s.replace(/\!/g, &quot;%21&quot;);
        s = s.replace(/\*/g, &quot;%2A&quot;);
        s = s.replace(/\&apos;/g, &quot;%27&quot;);
        s = s.replace(/\(/g, &quot;%28&quot;);
        s = s.replace(/\)/g, &quot;%29&quot;);
        return s;
    }
,
    decodePercent: function decodePercent(s) {
        if (s != null) {
            // Handle application/x-www-form-urlencoded, which is defined by
            // http://www.w3.org/TR/html4/interact/forms.html#h-17.13.4.1
            s = s.replace(/\+/g, &quot; &quot;);
        }
        return decodeURIComponent(s);
    }
,
    /** Convert the given parameters to an Array of name-value pairs. */
    getParameterList: function getParameterList(parameters) {
        if (parameters == null) {
            return [];
        }
        if (typeof parameters != &quot;object&quot;) {
            return OAuth.decodeForm(parameters + &quot;&quot;);
        }
        if (parameters instanceof Array) {
            return parameters;
        }
        var list = [];
        for (var p in parameters) {
            list.push([p, parameters[p]]);
        }
        return list;
    }
,
    /** Convert the given parameters to a map from name to value. */
    getParameterMap: function getParameterMap(parameters) {
        if (parameters == null) {
            return {};
        }
        if (typeof parameters != &quot;object&quot;) {
            return OAuth.getParameterMap(OAuth.decodeForm(parameters + &quot;&quot;));
        }
        if (parameters instanceof Array) {
            var map = {};
            for (var p = 0; p &lt; parameters.length; ++p) {
                var key = parameters[p][0];
                if (map[key] === undefined) { // first value wins
                    map[key] = parameters[p][1];
                }
            }
            return map;
        }
        return parameters;
    }
,
    getParameter: function getParameter(parameters, name) {
        if (parameters instanceof Array) {
            for (var p = 0; p &lt; parameters.length; ++p) {
                if (parameters[p][0] == name) {
                    return parameters[p][1]; // first value wins
                }
            }
        } else {
            return OAuth.getParameterMap(parameters)[name];
        }
        return null;
    }
,
    formEncode: function formEncode(parameters) {
        var form = &quot;&quot;;
        var list = OAuth.getParameterList(parameters);
        for (var p = 0; p &lt; list.length; ++p) {
            var value = list[p][1];
            if (value == null) value = &quot;&quot;;
            if (form != &quot;&quot;) form += &apos;&amp;&apos;;
            form += OAuth.percentEncode(list[p][0])
              +&apos;=&apos;+ OAuth.percentEncode(value);
        }
        return form;
    }
,
    decodeForm: function decodeForm(form) {
        var list = [];
        var nvps = form.split(&apos;&amp;&apos;);
        for (var n = 0; n &lt; nvps.length; ++n) {
            var nvp = nvps[n];
            if (nvp == &quot;&quot;) {
                continue;
            }
            var equals = nvp.indexOf(&apos;=&apos;);
            var name;
            var value;
            if (equals &lt; 0) {
                name = OAuth.decodePercent(nvp);
                value = null;
            } else {
                name = OAuth.decodePercent(nvp.substring(0, equals));
                value = OAuth.decodePercent(nvp.substring(equals + 1));
            }
            list.push([name, value]);
        }
        return list;
    }
,
    setParameter: function setParameter(message, name, value) {
        var parameters = message.parameters;
        if (parameters instanceof Array) {
            for (var p = 0; p &lt; parameters.length; ++p) {
                if (parameters[p][0] == name) {
                    if (value === undefined) {
                        parameters.splice(p, 1);
                    } else {
                        parameters[p][1] = value;
                        value = undefined;
                    }
                }
            }
            if (value !== undefined) {
                parameters.push([name, value]);
            }
        } else {
            parameters = OAuth.getParameterMap(parameters);
            parameters[name] = value;
            message.parameters = parameters;
        }
    }
,
    setParameters: function setParameters(message, parameters) {
        var list = OAuth.getParameterList(parameters);
        for (var i = 0; i &lt; list.length; ++i) {
            OAuth.setParameter(message, list[i][0], list[i][1]);
        }
    }
,
    /** Fill in parameters to help construct a request message.
        This function doesn&apos;t fill in every parameter.
        The accessor object should be like:
        {consumerKey:&apos;foo&apos;, consumerSecret:&apos;bar&apos;, accessorSecret:&apos;nurn&apos;, token:&apos;krelm&apos;, tokenSecret:&apos;blah&apos;}
        The accessorSecret property is optional.
     */
    completeRequest: function completeRequest(message, accessor) {
        if (message.method == null) {
            message.method = &quot;GET&quot;;
        }
        var map = OAuth.getParameterMap(message.parameters);
        if (map.oauth_consumer_key == null) {
            OAuth.setParameter(message, &quot;oauth_consumer_key&quot;, accessor.consumerKey || &quot;&quot;);
        }
        if (map.oauth_token == null &amp;&amp; accessor.token != null) {
            OAuth.setParameter(message, &quot;oauth_token&quot;, accessor.token);
        }
        if (map.oauth_version == null) {
            OAuth.setParameter(message, &quot;oauth_version&quot;, &quot;1.0&quot;);
        }
        if (map.oauth_timestamp == null) {
            OAuth.setParameter(message, &quot;oauth_timestamp&quot;, OAuth.timestamp());
        }
        if (map.oauth_nonce == null) {
            OAuth.setParameter(message, &quot;oauth_nonce&quot;, OAuth.nonce(6));
        }
        OAuth.SignatureMethod.sign(message, accessor);
    }
,
    setTimestampAndNonce: function setTimestampAndNonce(message) {
        OAuth.setParameter(message, &quot;oauth_timestamp&quot;, OAuth.timestamp());
        OAuth.setParameter(message, &quot;oauth_nonce&quot;, OAuth.nonce(6));
    }
,
    addToURL: function addToURL(url, parameters) {
        newURL = url;
        if (parameters != null) {
            var toAdd = OAuth.formEncode(parameters);
            if (toAdd.length &gt; 0) {
                var q = url.indexOf(&apos;?&apos;);
                if (q &lt; 0) newURL += &apos;?&apos;;
                else       newURL += &apos;&amp;&apos;;
                newURL += toAdd;
            }
        }
        return newURL;
    }
,
    /** Construct the value of the Authorization header for an HTTP request. */
    getAuthorizationHeader: function getAuthorizationHeader(realm, parameters) {
        var header = &apos;OAuth realm=&quot;&apos; + OAuth.percentEncode(realm) + &apos;&quot;&apos;;
        var list = OAuth.getParameterList(parameters);
        for (var p = 0; p &lt; list.length; ++p) {
            var parameter = list[p];
            var name = parameter[0];
            if (name.indexOf(&quot;oauth_&quot;) == 0) {
                header += &apos;,&apos; + OAuth.percentEncode(name) + &apos;=&quot;&apos; + OAuth.percentEncode(parameter[1]) + &apos;&quot;&apos;;
            }
        }
        return header;
    }
,
    /** Correct the time using a parameter from the URL from which the last script was loaded. */
    correctTimestampFromSrc: function correctTimestampFromSrc(parameterName) {
        parameterName = parameterName || &quot;oauth_timestamp&quot;;
        var scripts = document.getElementsByTagName(&apos;script&apos;);
        if (scripts == null || !scripts.length) return;
        var src = scripts[scripts.length-1].src;
        if (!src) return;
        var q = src.indexOf(&quot;?&quot;);
        if (q &lt; 0) return;
        parameters = OAuth.getParameterMap(OAuth.decodeForm(src.substring(q+1)));
        var t = parameters[parameterName];
        if (t == null) return;
        OAuth.correctTimestamp(t);
    }
,
    /** Generate timestamps starting with the given value. */
    correctTimestamp: function correctTimestamp(timestamp) {
        OAuth.timeCorrectionMsec = (timestamp * 1000) - (new Date()).getTime();
    }
,
    /** The difference between the correct time and my clock. */
    timeCorrectionMsec: 0
,
    timestamp: function timestamp() {
        var t = (new Date()).getTime() + OAuth.timeCorrectionMsec;
        return Math.floor(t / 1000);
    }
,
    nonce: function nonce(length) {
        var chars = OAuth.nonce.CHARS;
        var result = &quot;&quot;;
        for (var i = 0; i &lt; length; ++i) {
            var rnum = Math.floor(Math.random() * chars.length);
            result += chars.substring(rnum, rnum+1);
        }
        return result;
    }
});

OAuth.nonce.CHARS = &quot;0123456789ABCDEFGHIJKLMNOPQRSTUVWXTZabcdefghiklmnopqrstuvwxyz&quot;;

/** Define a constructor function,
    without causing trouble to anyone who was using it as a namespace.
    That is, if parent[name] already existed and had properties,
    copy those properties into the new constructor.
 */
OAuth.declareClass = function declareClass(parent, name, newConstructor) {
    var previous = parent[name];
    parent[name] = newConstructor;
    if (newConstructor != null &amp;&amp; previous != null) {
        for (var key in previous) {
            if (key != &quot;prototype&quot;) {
                newConstructor[key] = previous[key];
            }
        }
    }
    return newConstructor;
}

/** An abstract algorithm for signing messages. */
OAuth.declareClass(OAuth, &quot;SignatureMethod&quot;, function OAuthSignatureMethod(){});

OAuth.setProperties(OAuth.SignatureMethod.prototype, // instance members
{
    /** Add a signature to the message. */
    sign: function sign(message) {
        var baseString = OAuth.SignatureMethod.getBaseString(message);
        var signature = this.getSignature(baseString);
        OAuth.setParameter(message, &quot;oauth_signature&quot;, signature);
        return signature; // just in case someone&apos;s interested
    }
,
    /** Set the key string for signing. */
    initialize: function initialize(name, accessor) {
        var consumerSecret;
        if (accessor.accessorSecret != null
            &amp;&amp; name.length &gt; 9
            &amp;&amp; name.substring(name.length-9) == &quot;-Accessor&quot;)
        {
            consumerSecret = accessor.accessorSecret;
        } else {
            consumerSecret = accessor.consumerSecret;
        }
        this.key = OAuth.percentEncode(consumerSecret)
             +&quot;&amp;&quot;+ OAuth.percentEncode(accessor.tokenSecret);
    }
});

/* SignatureMethod expects an accessor object to be like this:
   {tokenSecret: &quot;lakjsdflkj...&quot;, consumerSecret: &quot;QOUEWRI..&quot;, accessorSecret: &quot;xcmvzc...&quot;}
   The accessorSecret property is optional.
 */
// Class members:
OAuth.setProperties(OAuth.SignatureMethod, // class members
{
    sign: function sign(message, accessor) {
        var name = OAuth.getParameterMap(message.parameters).oauth_signature_method;
        if (name == null || name == &quot;&quot;) {
            name = &quot;HMAC-SHA1&quot;;
            OAuth.setParameter(message, &quot;oauth_signature_method&quot;, name);
        }
        OAuth.SignatureMethod.newMethod(name, accessor).sign(message);
    }
,
    /** Instantiate a SignatureMethod for the given method name. */
    newMethod: function newMethod(name, accessor) {
        var impl = OAuth.SignatureMethod.REGISTERED[name];
        if (impl != null) {
            var method = new impl();
            method.initialize(name, accessor);
            return method;
        }
        var err = new Error(&quot;signature_method_rejected&quot;);
        var acceptable = &quot;&quot;;
        for (var r in OAuth.SignatureMethod.REGISTERED) {
            if (acceptable != &quot;&quot;) acceptable += &apos;&amp;&apos;;
            acceptable += OAuth.percentEncode(r);
        }
        err.oauth_acceptable_signature_methods = acceptable;
        throw err;
    }
,
    /** A map from signature method name to constructor. */
    REGISTERED : {}
,
    /** Subsequently, the given constructor will be used for the named methods.
        The constructor will be called with no parameters.
        The resulting object should usually implement getSignature(baseString).
        You can easily define such a constructor by calling makeSubclass, below.
     */
    registerMethodClass: function registerMethodClass(names, classConstructor) {
        for (var n = 0; n &lt; names.length; ++n) {
            OAuth.SignatureMethod.REGISTERED[names[n]] = classConstructor;
        }
    }
,
    /** Create a subclass of OAuth.SignatureMethod, with the given getSignature function. */
    makeSubclass: function makeSubclass(getSignatureFunction) {
        var superClass = OAuth.SignatureMethod;
        var subClass = function() {
            superClass.call(this);
        };
        subClass.prototype = new superClass();
        // Delete instance variables from prototype:
        // delete subclass.prototype... There aren&apos;t any.
        subClass.prototype.getSignature = getSignatureFunction;
        subClass.prototype.constructor = subClass;
        return subClass;
    }
,
    getBaseString: function getBaseString(message) {
        var URL = message.action;
        var q = URL.indexOf(&apos;?&apos;);
        var parameters;
        if (q &lt; 0) {
            parameters = message.parameters;
        } else {
            // Combine the URL query string with the other parameters:
            parameters = OAuth.decodeForm(URL.substring(q + 1));
            var toAdd = OAuth.getParameterList(message.parameters);
            for (var a = 0; a &lt; toAdd.length; ++a) {
                parameters.push(toAdd[a]);
            }
        }
        return OAuth.percentEncode(message.method.toUpperCase())
         +&apos;&amp;&apos;+ OAuth.percentEncode(OAuth.SignatureMethod.normalizeUrl(URL))
         +&apos;&amp;&apos;+ OAuth.percentEncode(OAuth.SignatureMethod.normalizeParameters(parameters));
    }
,
    normalizeUrl: function normalizeUrl(url) {
        var uri = OAuth.SignatureMethod.parseUri(url);
        var scheme = uri.protocol.toLowerCase();
        var authority = uri.authority.toLowerCase();
        var dropPort = (scheme == &quot;http&quot; &amp;&amp; uri.port == 80)
                    || (scheme == &quot;https&quot; &amp;&amp; uri.port == 443);
        if (dropPort) {
            // find the last : in the authority
            var index = authority.lastIndexOf(&quot;:&quot;);
            if (index &gt;= 0) {
                authority = authority.substring(0, index);
            }
        }
        var path = uri.path;
        if (!path) {
            path = &quot;/&quot;; // conforms to RFC 2616 section 3.2.2
        }
        // we know that there is no query and no fragment here.
        return scheme + &quot;://&quot; + authority + path;
    }
,
    parseUri: function parseUri (str) {
        /* This function was adapted from parseUri 1.2.1
           http://stevenlevithan.com/demo/parseuri/js/assets/parseuri.js
         */
        var o = {key: [&quot;source&quot;,&quot;protocol&quot;,&quot;authority&quot;,&quot;userInfo&quot;,&quot;user&quot;,&quot;password&quot;,&quot;host&quot;,&quot;port&quot;,&quot;relative&quot;,&quot;path&quot;,&quot;directory&quot;,&quot;file&quot;,&quot;query&quot;,&quot;anchor&quot;],
                 parser: {strict: /^(?:([^:\/?#]+):)?(?:\/\/((?:(([^:@\/]*):?([^:@\/]*))?@)?([^:\/?#]*)(?::(\d*))?))?((((?:[^?#\/]*\/)*)([^?#]*))(?:\?([^#]*))?(?:#(.*))?)/ }};
        var m = o.parser.strict.exec(str);
        var uri = {};
        var i = 14;
        while (i--) uri[o.key[i]] = m[i] || &quot;&quot;;
        return uri;
    }
,
    normalizeParameters: function normalizeParameters(parameters) {
        if (parameters == null) {
            return &quot;&quot;;
        }
        var list = OAuth.getParameterList(parameters);
        var sortable = [];
        for (var p = 0; p &lt; list.length; ++p) {
            var nvp = list[p];
            if (nvp[0] != &quot;oauth_signature&quot;) {
                sortable.push([ OAuth.percentEncode(nvp[0])
                              + &quot; &quot; // because it comes before any character that can appear in a percentEncoded string.
                              + OAuth.percentEncode(nvp[1])
                              , nvp]);
            }
        }
        sortable.sort(function(a,b) {
                          if (a[0] &lt; b[0]) return  -1;
                          if (a[0] &gt; b[0]) return 1;
                          return 0;
                      });
        var sorted = [];
        for (var s = 0; s &lt; sortable.length; ++s) {
            sorted.push(sortable[s][1]);
        }
        return OAuth.formEncode(sorted);
    }
});

OAuth.SignatureMethod.registerMethodClass([&quot;PLAINTEXT&quot;, &quot;PLAINTEXT-Accessor&quot;],
    OAuth.SignatureMethod.makeSubclass(
        function getSignature(baseString) {
            return this.key;
        }
    ));

OAuth.SignatureMethod.registerMethodClass([&quot;HMAC-SHA1&quot;, &quot;HMAC-SHA1-Accessor&quot;],
    OAuth.SignatureMethod.makeSubclass(
        function getSignature(baseString) {
            b64pad = &apos;=&apos;;
            var signature = b64_hmac_sha1(this.key, baseString);
            return signature;
        }
    ));

try {
    OAuth.correctTimestampFromSrc();
} catch(e) {
}


//--------------------------------------------------

var consumerKey = &quot;${consumer_key}&quot;;
var consumerSecret = &quot;${consumer_secret}&quot;;
var params = [];
var query = [];
query.push(&apos;grant_type&apos; + &apos;=&apos; + &apos;refresh_token&apos;);
query.push(&apos;refresh_token&apos; + &apos;=&apos; + &apos;${refresh_token}&apos;);
query.push(&apos;redirect_uri&apos; + &apos;=&apos; + &apos;${protocol}%3A%2F%2F${jmeter_path}%2Ftest%2Fmisp%2Fmisp-callback&apos;);
//query.push(&apos;code&apos; + &apos;=&apos; + &apos;${code}&apos;);
var url =  &quot;${protocol}://${misp_url}/marvelous/token&quot;;

if (query.length) {
    url += &apos;?&apos; + query.join(&apos;&amp;&apos;);
}

var message = {
    method: &apos;post&apos;,
    parameters: params, 
    action: url
};
       
var accessor = {
    consumerKey: consumerKey,
    consumerSecret: consumerSecret,
    token: null,
    tokenSecret: null
};

OAuth.completeRequest(message, accessor);
vars.put(&apos;token_auth_header&apos;, OAuth.getAuthorizationHeader(&apos;&apos;, params).replace(&apos;OAuth realm=&quot;&quot;,&apos;, &apos; OAuth &apos;));
</stringProp>
            <stringProp name="scriptLanguage">javascript</stringProp>
          </BSFPreProcessor>
          <hashTree/>
          <HeaderManager guiclass="HeaderPanel" testclass="HeaderManager" testname="HTTP ヘッダマネージャ" enabled="true">
            <collectionProp name="HeaderManager.headers">
              <elementProp name="" elementType="Header">
                <stringProp name="Header.name">Authorization</stringProp>
                <stringProp name="Header.value">${token_auth_header}</stringProp>
              </elementProp>
              <elementProp name="" elementType="Header">
                <stringProp name="Header.name">content-type</stringProp>
                <stringProp name="Header.value">application/x-www-form-urlencoded</stringProp>
              </elementProp>
            </collectionProp>
          </HeaderManager>
          <hashTree/>
          <RegexExtractor guiclass="RegexExtractorGui" testclass="RegexExtractor" testname="access_token" enabled="true">
            <stringProp name="RegexExtractor.useHeaders">false</stringProp>
            <stringProp name="RegexExtractor.refname">access_token</stringProp>
            <stringProp name="RegexExtractor.regex">&quot;access_token&quot;:&quot;(.*?)&quot;,</stringProp>
            <stringProp name="RegexExtractor.template">$1$</stringProp>
            <stringProp name="RegexExtractor.default"></stringProp>
            <stringProp name="RegexExtractor.match_number">1</stringProp>
          </RegexExtractor>
          <hashTree/>
          <RegexExtractor guiclass="RegexExtractorGui" testclass="RegexExtractor" testname="id_token" enabled="true">
            <stringProp name="RegexExtractor.useHeaders">false</stringProp>
            <stringProp name="RegexExtractor.refname">id_token</stringProp>
            <stringProp name="RegexExtractor.regex">&quot;id_token&quot;:&quot;(.*?)&quot;</stringProp>
            <stringProp name="RegexExtractor.template">$1$</stringProp>
            <stringProp name="RegexExtractor.default"></stringProp>
            <stringProp name="RegexExtractor.match_number">1</stringProp>
          </RegexExtractor>
          <hashTree/>
          <RegexExtractor guiclass="RegexExtractorGui" testclass="RegexExtractor" testname="refresh_token" enabled="true">
            <stringProp name="RegexExtractor.useHeaders">false</stringProp>
            <stringProp name="RegexExtractor.refname">refresh_token</stringProp>
            <stringProp name="RegexExtractor.regex">&quot;refresh_token&quot;:&quot;(.*?)&quot;,</stringProp>
            <stringProp name="RegexExtractor.template">$1$</stringProp>
            <stringProp name="RegexExtractor.default"></stringProp>
            <stringProp name="RegexExtractor.match_number">1</stringProp>
          </RegexExtractor>
          <hashTree/>
          <ConstantTimer guiclass="ConstantTimerGui" testclass="ConstantTimer" testname="定数タイマ updated_dateの差異確認用" enabled="true">
            <stringProp name="ConstantTimer.delay">3000</stringProp>
          </ConstantTimer>
          <hashTree/>
        </hashTree>
        <HTTPSamplerProxy guiclass="HttpTestSampleGui" testclass="HTTPSamplerProxy" testname="Basic.ユーザ取得" enabled="true">
          <elementProp name="HTTPsampler.Arguments" elementType="Arguments" guiclass="HTTPArgumentsPanel" testclass="Arguments" enabled="true">
            <collectionProp name="Arguments.arguments">
              <elementProp name="access_token" elementType="HTTPArgument">
                <boolProp name="HTTPArgument.always_encode">false</boolProp>
                <stringProp name="Argument.name">access_token</stringProp>
                <stringProp name="Argument.value">${access_token}</stringProp>
                <stringProp name="Argument.metadata">=</stringProp>
                <boolProp name="HTTPArgument.use_equals">true</boolProp>
              </elementProp>
              <elementProp name="id_token" elementType="HTTPArgument">
                <boolProp name="HTTPArgument.always_encode">false</boolProp>
                <stringProp name="Argument.name">id_token</stringProp>
                <stringProp name="Argument.value">${id_token}</stringProp>
                <stringProp name="Argument.metadata">=</stringProp>
                <boolProp name="HTTPArgument.use_equals">true</boolProp>
              </elementProp>
            </collectionProp>
          </elementProp>
          <stringProp name="HTTPSampler.domain"></stringProp>
          <stringProp name="HTTPSampler.port"></stringProp>
          <stringProp name="HTTPSampler.connect_timeout"></stringProp>
          <stringProp name="HTTPSampler.response_timeout"></stringProp>
          <stringProp name="HTTPSampler.protocol"></stringProp>
          <stringProp name="HTTPSampler.contentEncoding"></stringProp>
          <stringProp name="HTTPSampler.path">/marvelous/people/@me/@self</stringProp>
          <stringProp name="HTTPSampler.method">GET</stringProp>
          <boolProp name="HTTPSampler.follow_redirects">true</boolProp>
          <boolProp name="HTTPSampler.auto_redirects">false</boolProp>
          <boolProp name="HTTPSampler.use_keepalive">true</boolProp>
          <boolProp name="HTTPSampler.DO_MULTIPART_POST">false</boolProp>
          <boolProp name="HTTPSampler.monitor">false</boolProp>
          <stringProp name="HTTPSampler.embedded_url_re"></stringProp>
          <stringProp name="TestPlan.comments">リフレッシュしたトークンでユーザ取得ができるか</stringProp>
        </HTTPSamplerProxy>
        <hashTree>
          <ResponseAssertion guiclass="AssertionGui" testclass="ResponseAssertion" testname="アサーション" enabled="true">
            <collectionProp name="Asserion.test_strings">
              <stringProp name="1437218324">&quot;username&quot;:&quot;trustedproxy_basic_5&quot;</stringProp>
              <stringProp name="-1288437593">&quot;userId&quot;:&quot;basic_test_5&quot;</stringProp>
              <stringProp name="-1301137854">&quot;appId&quot;:&quot;00000&quot;</stringProp>
            </collectionProp>
            <stringProp name="Assertion.test_field">Assertion.response_data</stringProp>
            <boolProp name="Assertion.assume_success">false</boolProp>
            <intProp name="Assertion.test_type">2</intProp>
            <stringProp name="TestPlan.comments">確認項目
mispRp_2と同じ値を取得できていること</stringProp>
          </ResponseAssertion>
          <hashTree/>
          <HeaderManager guiclass="HeaderPanel" testclass="HeaderManager" testname="HTTP ヘッダマネージャ" enabled="true">
            <collectionProp name="HeaderManager.headers">
              <elementProp name="" elementType="Header">
                <stringProp name="Header.name">Authorization</stringProp>
                <stringProp name="Header.value">${get_auth_header}</stringProp>
              </elementProp>
              <elementProp name="" elementType="Header">
                <stringProp name="Header.name">content-type</stringProp>
                <stringProp name="Header.value">application/x-www-form-urlencoded</stringProp>
              </elementProp>
            </collectionProp>
          </HeaderManager>
          <hashTree/>
          <BSFPreProcessor guiclass="TestBeanGUI" testclass="BSFPreProcessor" testname="BSF PreProcessor" enabled="true">
            <stringProp name="filename"></stringProp>
            <stringProp name="parameters"></stringProp>
            <stringProp name="script">/*
 * A JavaScript implementation of the Secure Hash Algorithm, SHA-1, as defined
 * in FIPS PUB 180-1
 * Version 2.1a Copyright Paul Johnston 2000 - 2002.
 * Other contributors: Greg Holt, Andrew Kepert, Ydnar, Lostinet
 * Distributed under the BSD License
 * See http://pajhome.org.uk/crypt/md5 for details.
 */

/*
 * Configurable variables. You may need to tweak these to be compatible with
 * the server-side, but the defaults work in most cases.
 */
var hexcase = 0;  /* hex output format. 0 - lowercase; 1 - uppercase        */
var b64pad  = &quot;&quot;; /* base-64 pad character. &quot;=&quot; for strict RFC compliance   */
var chrsz   = 8;  /* bits per input character. 8 - ASCII; 16 - Unicode      */

/*
 * These are the functions you&apos;ll usually want to call
 * They take string arguments and return either hex or base-64 encoded strings
 */
function hex_sha1(s){return binb2hex(core_sha1(str2binb(s),s.length * chrsz));}
function b64_sha1(s){return binb2b64(core_sha1(str2binb(s),s.length * chrsz));}
function str_sha1(s){return binb2str(core_sha1(str2binb(s),s.length * chrsz));}
function hex_hmac_sha1(key, data){ return binb2hex(core_hmac_sha1(key, data));}
function b64_hmac_sha1(key, data){ return binb2b64(core_hmac_sha1(key, data));}
function str_hmac_sha1(key, data){ return binb2str(core_hmac_sha1(key, data));}

/*
 * Perform a simple self-test to see if the VM is working
 */
function sha1_vm_test()
{
  return hex_sha1(&quot;abc&quot;) == &quot;a9993e364706816aba3e25717850c26c9cd0d89d&quot;;
}

/*
 * Calculate the SHA-1 of an array of big-endian words, and a bit length
 */
function core_sha1(x, len)
{
  /* append padding */
  x[len &gt;&gt; 5] |= 0x80 &lt;&lt; (24 - len % 32);
  x[((len + 64 &gt;&gt; 9) &lt;&lt; 4) + 15] = len;

  var w = Array(80);
  var a =  1732584193;
  var b = -271733879;
  var c = -1732584194;
  var d =  271733878;
  var e = -1009589776;

  for(var i = 0; i &lt; x.length; i += 16)
  {
    var olda = a;
    var oldb = b;
    var oldc = c;
    var oldd = d;
    var olde = e;

    for(var j = 0; j &lt; 80; j++)
    {
      if(j &lt; 16) w[j] = x[i + j];
      else w[j] = rol(w[j-3] ^ w[j-8] ^ w[j-14] ^ w[j-16], 1);
      var t = safe_add(safe_add(rol(a, 5), sha1_ft(j, b, c, d)),
                       safe_add(safe_add(e, w[j]), sha1_kt(j)));
      e = d;
      d = c;
      c = rol(b, 30);
      b = a;
      a = t;
    }

    a = safe_add(a, olda);
    b = safe_add(b, oldb);
    c = safe_add(c, oldc);
    d = safe_add(d, oldd);
    e = safe_add(e, olde);
  }
  return Array(a, b, c, d, e);

}

/*
 * Perform the appropriate triplet combination function for the current
 * iteration
 */
function sha1_ft(t, b, c, d)
{
  if(t &lt; 20) return (b &amp; c) | ((~b) &amp; d);
  if(t &lt; 40) return b ^ c ^ d;
  if(t &lt; 60) return (b &amp; c) | (b &amp; d) | (c &amp; d);
  return b ^ c ^ d;
}

/*
 * Determine the appropriate additive constant for the current iteration
 */
function sha1_kt(t)
{
  return (t &lt; 20) ?  1518500249 : (t &lt; 40) ?  1859775393 :
         (t &lt; 60) ? -1894007588 : -899497514;
}

/*
 * Calculate the HMAC-SHA1 of a key and some data
 */
function core_hmac_sha1(key, data)
{
  var bkey = str2binb(key);
  if(bkey.length &gt; 16) bkey = core_sha1(bkey, key.length * chrsz);

  var ipad = Array(16), opad = Array(16);
  for(var i = 0; i &lt; 16; i++)
  {
    ipad[i] = bkey[i] ^ 0x36363636;
    opad[i] = bkey[i] ^ 0x5C5C5C5C;
  }

  var hash = core_sha1(ipad.concat(str2binb(data)), 512 + data.length * chrsz);
  return core_sha1(opad.concat(hash), 512 + 160);
}

/*
 * Add integers, wrapping at 2^32. This uses 16-bit operations internally
 * to work around bugs in some JS interpreters.
 */
function safe_add(x, y)
{
  var lsw = (x &amp; 0xFFFF) + (y &amp; 0xFFFF);
  var msw = (x &gt;&gt; 16) + (y &gt;&gt; 16) + (lsw &gt;&gt; 16);
  return (msw &lt;&lt; 16) | (lsw &amp; 0xFFFF);
}

/*
 * Bitwise rotate a 32-bit number to the left.
 */
function rol(num, cnt)
{
  return (num &lt;&lt; cnt) | (num &gt;&gt;&gt; (32 - cnt));
}

/*
 * Convert an 8-bit or 16-bit string to an array of big-endian words
 * In 8-bit function, characters &gt;255 have their hi-byte silently ignored.
 */
function str2binb(str)
{
  var bin = Array();
  var mask = (1 &lt;&lt; chrsz) - 1;
  for(var i = 0; i &lt; str.length * chrsz; i += chrsz)
    bin[i&gt;&gt;5] |= (str.charCodeAt(i / chrsz) &amp; mask) &lt;&lt; (32 - chrsz - i%32);
  return bin;
}

/*
 * Convert an array of big-endian words to a string
 */
function binb2str(bin)
{
  var str = &quot;&quot;;
  var mask = (1 &lt;&lt; chrsz) - 1;
  for(var i = 0; i &lt; bin.length * 32; i += chrsz)
    str += String.fromCharCode((bin[i&gt;&gt;5] &gt;&gt;&gt; (32 - chrsz - i%32)) &amp; mask);
  return str;
}

/*
 * Convert an array of big-endian words to a hex string.
 */
function binb2hex(binarray)
{
  var hex_tab = hexcase ? &quot;0123456789ABCDEF&quot; : &quot;0123456789abcdef&quot;;
  var str = &quot;&quot;;
  for(var i = 0; i &lt; binarray.length * 4; i++)
  {
    str += hex_tab.charAt((binarray[i&gt;&gt;2] &gt;&gt; ((3 - i%4)*8+4)) &amp; 0xF) +
           hex_tab.charAt((binarray[i&gt;&gt;2] &gt;&gt; ((3 - i%4)*8  )) &amp; 0xF);
  }
  return str;
}

/*
 * Convert an array of big-endian words to a base-64 string
 */
function binb2b64(binarray)
{
  var tab = &quot;ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/&quot;;
  var str = &quot;&quot;;
  for(var i = 0; i &lt; binarray.length * 4; i += 3)
  {
    var triplet = (((binarray[i   &gt;&gt; 2] &gt;&gt; 8 * (3 -  i   %4)) &amp; 0xFF) &lt;&lt; 16)
                | (((binarray[i+1 &gt;&gt; 2] &gt;&gt; 8 * (3 - (i+1)%4)) &amp; 0xFF) &lt;&lt; 8 )
                |  ((binarray[i+2 &gt;&gt; 2] &gt;&gt; 8 * (3 - (i+2)%4)) &amp; 0xFF);
    for(var j = 0; j &lt; 4; j++)
    {
      if(i * 8 + j * 6 &gt; binarray.length * 32) str += b64pad;
      else str += tab.charAt((triplet &gt;&gt; 6*(3-j)) &amp; 0x3F);
    }
  }
  return str;
}

/*
 * Copyright 2008 Netflix, Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/* Here&apos;s some JavaScript software for implementing OAuth.

   This isn&apos;t as useful as you might hope.  OAuth is based around
   allowing tools and websites to talk to each other.  However,
   JavaScript running in web browsers is hampered by security
   restrictions that prevent code running on one website from
   accessing data stored or served on another.

   Before you start hacking, make sure you understand the limitations
   posed by cross-domain XMLHttpRequest.

   On the bright side, some platforms use JavaScript as their
   language, but enable the programmer to access other web sites.
   Examples include Google Gadgets, and Microsoft Vista Sidebar.
   For those platforms, this library should come in handy.
*/

// The HMAC-SHA1 signature method calls b64_hmac_sha1, defined by
// http://pajhome.org.uk/crypt/md5/sha1.js

/* An OAuth message is represented as an object like this:
   {method: &quot;GET&quot;, action: &quot;http://server.com/path&quot;, parameters: ...}

   The parameters may be either a map {name: value, name2: value2}
   or an Array of name-value pairs [[name, value], [name2, value2]].
   The latter representation is more powerful: it supports parameters
   in a specific sequence, or several parameters with the same name;
   for example [[&quot;a&quot;, 1], [&quot;b&quot;, 2], [&quot;a&quot;, 3]].

   Parameter names and values are NOT percent-encoded in an object.
   They must be encoded before transmission and decoded after reception.
   For example, this message object:
   {method: &quot;GET&quot;, action: &quot;http://server/path&quot;, parameters: {p: &quot;x y&quot;}}
   ... can be transmitted as an HTTP request that begins:
   GET /path?p=x%20y HTTP/1.0
   (This isn&apos;t a valid OAuth request, since it lacks a signature etc.)
   Note that the object &quot;x y&quot; is transmitted as x%20y.  To encode
   parameters, you can call OAuth.addToURL, OAuth.formEncode or
   OAuth.getAuthorization.

   This message object model harmonizes with the browser object model for
   input elements of an form, whose value property isn&apos;t percent encoded.
   The browser encodes each value before transmitting it. For example,
   see consumer.setInputs in example/consumer.js.
 */

/* This script needs to know what time it is. By default, it uses the local
   clock (new Date), which is apt to be inaccurate in browsers. To do
   better, you can load this script from a URL whose query string contains
   an oauth_timestamp parameter, whose value is a current Unix timestamp.
   For example, when generating the enclosing document using PHP:

   &lt;script src=&quot;oauth.js?oauth_timestamp=&lt;?=time()?&gt;&quot; ...

   Another option is to call OAuth.correctTimestamp with a Unix timestamp.
 */

var OAuth; if (OAuth == null) OAuth = {};

OAuth.setProperties = function setProperties(into, from) {
    if (into != null &amp;&amp; from != null) {
        for (var key in from) {
            into[key] = from[key];
        }
    }
    return into;
}

OAuth.setProperties(OAuth, // utility functions
{
    percentEncode: function percentEncode(s) {
        if (s == null) {
            return &quot;&quot;;
        }
        if (s instanceof Array) {
            var e = &quot;&quot;;
            for (var i = 0; i &lt; s.length; ++s) {
                if (e != &quot;&quot;) e += &apos;&amp;&apos;;
                e += OAuth.percentEncode(s[i]);
            }
            return e;
        }
        s = encodeURIComponent(s);
        // Now replace the values which encodeURIComponent doesn&apos;t do
        // encodeURIComponent ignores: - _ . ! ~ * &apos; ( )
        // OAuth dictates the only ones you can ignore are: - _ . ~
        // Source: http://developer.mozilla.org/en/docs/Core_JavaScript_1.5_Reference:Global_Functions:encodeURIComponent
        s = s.replace(/\!/g, &quot;%21&quot;);
        s = s.replace(/\*/g, &quot;%2A&quot;);
        s = s.replace(/\&apos;/g, &quot;%27&quot;);
        s = s.replace(/\(/g, &quot;%28&quot;);
        s = s.replace(/\)/g, &quot;%29&quot;);
        return s;
    }
,
    decodePercent: function decodePercent(s) {
        if (s != null) {
            // Handle application/x-www-form-urlencoded, which is defined by
            // http://www.w3.org/TR/html4/interact/forms.html#h-17.13.4.1
            s = s.replace(/\+/g, &quot; &quot;);
        }
        return decodeURIComponent(s);
    }
,
    /** Convert the given parameters to an Array of name-value pairs. */
    getParameterList: function getParameterList(parameters) {
        if (parameters == null) {
            return [];
        }
        if (typeof parameters != &quot;object&quot;) {
            return OAuth.decodeForm(parameters + &quot;&quot;);
        }
        if (parameters instanceof Array) {
            return parameters;
        }
        var list = [];
        for (var p in parameters) {
            list.push([p, parameters[p]]);
        }
        return list;
    }
,
    /** Convert the given parameters to a map from name to value. */
    getParameterMap: function getParameterMap(parameters) {
        if (parameters == null) {
            return {};
        }
        if (typeof parameters != &quot;object&quot;) {
            return OAuth.getParameterMap(OAuth.decodeForm(parameters + &quot;&quot;));
        }
        if (parameters instanceof Array) {
            var map = {};
            for (var p = 0; p &lt; parameters.length; ++p) {
                var key = parameters[p][0];
                if (map[key] === undefined) { // first value wins
                    map[key] = parameters[p][1];
                }
            }
            return map;
        }
        return parameters;
    }
,
    getParameter: function getParameter(parameters, name) {
        if (parameters instanceof Array) {
            for (var p = 0; p &lt; parameters.length; ++p) {
                if (parameters[p][0] == name) {
                    return parameters[p][1]; // first value wins
                }
            }
        } else {
            return OAuth.getParameterMap(parameters)[name];
        }
        return null;
    }
,
    formEncode: function formEncode(parameters) {
        var form = &quot;&quot;;
        var list = OAuth.getParameterList(parameters);
        for (var p = 0; p &lt; list.length; ++p) {
            var value = list[p][1];
            if (value == null) value = &quot;&quot;;
            if (form != &quot;&quot;) form += &apos;&amp;&apos;;
            form += OAuth.percentEncode(list[p][0])
              +&apos;=&apos;+ OAuth.percentEncode(value);
        }
        return form;
    }
,
    decodeForm: function decodeForm(form) {
        var list = [];
        var nvps = form.split(&apos;&amp;&apos;);
        for (var n = 0; n &lt; nvps.length; ++n) {
            var nvp = nvps[n];
            if (nvp == &quot;&quot;) {
                continue;
            }
            var equals = nvp.indexOf(&apos;=&apos;);
            var name;
            var value;
            if (equals &lt; 0) {
                name = OAuth.decodePercent(nvp);
                value = null;
            } else {
                name = OAuth.decodePercent(nvp.substring(0, equals));
                value = OAuth.decodePercent(nvp.substring(equals + 1));
            }
            list.push([name, value]);
        }
        return list;
    }
,
    setParameter: function setParameter(message, name, value) {
        var parameters = message.parameters;
        if (parameters instanceof Array) {
            for (var p = 0; p &lt; parameters.length; ++p) {
                if (parameters[p][0] == name) {
                    if (value === undefined) {
                        parameters.splice(p, 1);
                    } else {
                        parameters[p][1] = value;
                        value = undefined;
                    }
                }
            }
            if (value !== undefined) {
                parameters.push([name, value]);
            }
        } else {
            parameters = OAuth.getParameterMap(parameters);
            parameters[name] = value;
            message.parameters = parameters;
        }
    }
,
    setParameters: function setParameters(message, parameters) {
        var list = OAuth.getParameterList(parameters);
        for (var i = 0; i &lt; list.length; ++i) {
            OAuth.setParameter(message, list[i][0], list[i][1]);
        }
    }
,
    /** Fill in parameters to help construct a request message.
        This function doesn&apos;t fill in every parameter.
        The accessor object should be like:
        {consumerKey:&apos;foo&apos;, consumerSecret:&apos;bar&apos;, accessorSecret:&apos;nurn&apos;, token:&apos;krelm&apos;, tokenSecret:&apos;blah&apos;}
        The accessorSecret property is optional.
     */
    completeRequest: function completeRequest(message, accessor) {
        if (message.method == null) {
            message.method = &quot;GET&quot;;
        }
        var map = OAuth.getParameterMap(message.parameters);
        if (map.oauth_consumer_key == null) {
            OAuth.setParameter(message, &quot;oauth_consumer_key&quot;, accessor.consumerKey || &quot;&quot;);
        }
        if (map.oauth_token == null &amp;&amp; accessor.token != null) {
            OAuth.setParameter(message, &quot;oauth_token&quot;, accessor.token);
        }
        if (map.oauth_version == null) {
            OAuth.setParameter(message, &quot;oauth_version&quot;, &quot;1.0&quot;);
        }
        if (map.oauth_timestamp == null) {
            OAuth.setParameter(message, &quot;oauth_timestamp&quot;, OAuth.timestamp());
        }
        if (map.oauth_nonce == null) {
            OAuth.setParameter(message, &quot;oauth_nonce&quot;, OAuth.nonce(6));
        }
        OAuth.SignatureMethod.sign(message, accessor);
    }
,
    setTimestampAndNonce: function setTimestampAndNonce(message) {
        OAuth.setParameter(message, &quot;oauth_timestamp&quot;, OAuth.timestamp());
        OAuth.setParameter(message, &quot;oauth_nonce&quot;, OAuth.nonce(6));
    }
,
    addToURL: function addToURL(url, parameters) {
        newURL = url;
        if (parameters != null) {
            var toAdd = OAuth.formEncode(parameters);
            if (toAdd.length &gt; 0) {
                var q = url.indexOf(&apos;?&apos;);
                if (q &lt; 0) newURL += &apos;?&apos;;
                else       newURL += &apos;&amp;&apos;;
                newURL += toAdd;
            }
        }
        return newURL;
    }
,
    /** Construct the value of the Authorization header for an HTTP request. */
    getAuthorizationHeader: function getAuthorizationHeader(realm, parameters) {
        var header = &apos;OAuth realm=&quot;&apos; + OAuth.percentEncode(realm) + &apos;&quot;&apos;;
        var list = OAuth.getParameterList(parameters);
        for (var p = 0; p &lt; list.length; ++p) {
            var parameter = list[p];
            var name = parameter[0];
            if (name.indexOf(&quot;oauth_&quot;) == 0) {
                header += &apos;,&apos; + OAuth.percentEncode(name) + &apos;=&quot;&apos; + OAuth.percentEncode(parameter[1]) + &apos;&quot;&apos;;
            }
        }
        return header;
    }
,
    /** Correct the time using a parameter from the URL from which the last script was loaded. */
    correctTimestampFromSrc: function correctTimestampFromSrc(parameterName) {
        parameterName = parameterName || &quot;oauth_timestamp&quot;;
        var scripts = document.getElementsByTagName(&apos;script&apos;);
        if (scripts == null || !scripts.length) return;
        var src = scripts[scripts.length-1].src;
        if (!src) return;
        var q = src.indexOf(&quot;?&quot;);
        if (q &lt; 0) return;
        parameters = OAuth.getParameterMap(OAuth.decodeForm(src.substring(q+1)));
        var t = parameters[parameterName];
        if (t == null) return;
        OAuth.correctTimestamp(t);
    }
,
    /** Generate timestamps starting with the given value. */
    correctTimestamp: function correctTimestamp(timestamp) {
        OAuth.timeCorrectionMsec = (timestamp * 1000) - (new Date()).getTime();
    }
,
    /** The difference between the correct time and my clock. */
    timeCorrectionMsec: 0
,
    timestamp: function timestamp() {
        var t = (new Date()).getTime() + OAuth.timeCorrectionMsec;
        return Math.floor(t / 1000);
    }
,
    nonce: function nonce(length) {
        var chars = OAuth.nonce.CHARS;
        var result = &quot;&quot;;
        for (var i = 0; i &lt; length; ++i) {
            var rnum = Math.floor(Math.random() * chars.length);
            result += chars.substring(rnum, rnum+1);
        }
        return result;
    }
});

OAuth.nonce.CHARS = &quot;0123456789ABCDEFGHIJKLMNOPQRSTUVWXTZabcdefghiklmnopqrstuvwxyz&quot;;

/** Define a constructor function,
    without causing trouble to anyone who was using it as a namespace.
    That is, if parent[name] already existed and had properties,
    copy those properties into the new constructor.
 */
OAuth.declareClass = function declareClass(parent, name, newConstructor) {
    var previous = parent[name];
    parent[name] = newConstructor;
    if (newConstructor != null &amp;&amp; previous != null) {
        for (var key in previous) {
            if (key != &quot;prototype&quot;) {
                newConstructor[key] = previous[key];
            }
        }
    }
    return newConstructor;
}

/** An abstract algorithm for signing messages. */
OAuth.declareClass(OAuth, &quot;SignatureMethod&quot;, function OAuthSignatureMethod(){});

OAuth.setProperties(OAuth.SignatureMethod.prototype, // instance members
{
    /** Add a signature to the message. */
    sign: function sign(message) {
        var baseString = OAuth.SignatureMethod.getBaseString(message);
        var signature = this.getSignature(baseString);
        OAuth.setParameter(message, &quot;oauth_signature&quot;, signature);
        return signature; // just in case someone&apos;s interested
    }
,
    /** Set the key string for signing. */
    initialize: function initialize(name, accessor) {
        var consumerSecret;
        if (accessor.accessorSecret != null
            &amp;&amp; name.length &gt; 9
            &amp;&amp; name.substring(name.length-9) == &quot;-Accessor&quot;)
        {
            consumerSecret = accessor.accessorSecret;
        } else {
            consumerSecret = accessor.consumerSecret;
        }
        this.key = OAuth.percentEncode(consumerSecret)
             +&quot;&amp;&quot;+ OAuth.percentEncode(accessor.tokenSecret);
    }
});

/* SignatureMethod expects an accessor object to be like this:
   {tokenSecret: &quot;lakjsdflkj...&quot;, consumerSecret: &quot;QOUEWRI..&quot;, accessorSecret: &quot;xcmvzc...&quot;}
   The accessorSecret property is optional.
 */
// Class members:
OAuth.setProperties(OAuth.SignatureMethod, // class members
{
    sign: function sign(message, accessor) {
        var name = OAuth.getParameterMap(message.parameters).oauth_signature_method;
        if (name == null || name == &quot;&quot;) {
            name = &quot;HMAC-SHA1&quot;;
            OAuth.setParameter(message, &quot;oauth_signature_method&quot;, name);
        }
        OAuth.SignatureMethod.newMethod(name, accessor).sign(message);
    }
,
    /** Instantiate a SignatureMethod for the given method name. */
    newMethod: function newMethod(name, accessor) {
        var impl = OAuth.SignatureMethod.REGISTERED[name];
        if (impl != null) {
            var method = new impl();
            method.initialize(name, accessor);
            return method;
        }
        var err = new Error(&quot;signature_method_rejected&quot;);
        var acceptable = &quot;&quot;;
        for (var r in OAuth.SignatureMethod.REGISTERED) {
            if (acceptable != &quot;&quot;) acceptable += &apos;&amp;&apos;;
            acceptable += OAuth.percentEncode(r);
        }
        err.oauth_acceptable_signature_methods = acceptable;
        throw err;
    }
,
    /** A map from signature method name to constructor. */
    REGISTERED : {}
,
    /** Subsequently, the given constructor will be used for the named methods.
        The constructor will be called with no parameters.
        The resulting object should usually implement getSignature(baseString).
        You can easily define such a constructor by calling makeSubclass, below.
     */
    registerMethodClass: function registerMethodClass(names, classConstructor) {
        for (var n = 0; n &lt; names.length; ++n) {
            OAuth.SignatureMethod.REGISTERED[names[n]] = classConstructor;
        }
    }
,
    /** Create a subclass of OAuth.SignatureMethod, with the given getSignature function. */
    makeSubclass: function makeSubclass(getSignatureFunction) {
        var superClass = OAuth.SignatureMethod;
        var subClass = function() {
            superClass.call(this);
        };
        subClass.prototype = new superClass();
        // Delete instance variables from prototype:
        // delete subclass.prototype... There aren&apos;t any.
        subClass.prototype.getSignature = getSignatureFunction;
        subClass.prototype.constructor = subClass;
        return subClass;
    }
,
    getBaseString: function getBaseString(message) {
        var URL = message.action;
        var q = URL.indexOf(&apos;?&apos;);
        var parameters;
        if (q &lt; 0) {
            parameters = message.parameters;
        } else {
            // Combine the URL query string with the other parameters:
            parameters = OAuth.decodeForm(URL.substring(q + 1));
            var toAdd = OAuth.getParameterList(message.parameters);
            for (var a = 0; a &lt; toAdd.length; ++a) {
                parameters.push(toAdd[a]);
            }
        }
        return OAuth.percentEncode(message.method.toUpperCase())
         +&apos;&amp;&apos;+ OAuth.percentEncode(OAuth.SignatureMethod.normalizeUrl(URL))
         +&apos;&amp;&apos;+ OAuth.percentEncode(OAuth.SignatureMethod.normalizeParameters(parameters));
    }
,
    normalizeUrl: function normalizeUrl(url) {
        var uri = OAuth.SignatureMethod.parseUri(url);
        var scheme = uri.protocol.toLowerCase();
        var authority = uri.authority.toLowerCase();
        var dropPort = (scheme == &quot;http&quot; &amp;&amp; uri.port == 80)
                    || (scheme == &quot;https&quot; &amp;&amp; uri.port == 443);
        if (dropPort) {
            // find the last : in the authority
            var index = authority.lastIndexOf(&quot;:&quot;);
            if (index &gt;= 0) {
                authority = authority.substring(0, index);
            }
        }
        var path = uri.path;
        if (!path) {
            path = &quot;/&quot;; // conforms to RFC 2616 section 3.2.2
        }
        // we know that there is no query and no fragment here.
        return scheme + &quot;://&quot; + authority + path;
    }
,
    parseUri: function parseUri (str) {
        /* This function was adapted from parseUri 1.2.1
           http://stevenlevithan.com/demo/parseuri/js/assets/parseuri.js
         */
        var o = {key: [&quot;source&quot;,&quot;protocol&quot;,&quot;authority&quot;,&quot;userInfo&quot;,&quot;user&quot;,&quot;password&quot;,&quot;host&quot;,&quot;port&quot;,&quot;relative&quot;,&quot;path&quot;,&quot;directory&quot;,&quot;file&quot;,&quot;query&quot;,&quot;anchor&quot;],
                 parser: {strict: /^(?:([^:\/?#]+):)?(?:\/\/((?:(([^:@\/]*):?([^:@\/]*))?@)?([^:\/?#]*)(?::(\d*))?))?((((?:[^?#\/]*\/)*)([^?#]*))(?:\?([^#]*))?(?:#(.*))?)/ }};
        var m = o.parser.strict.exec(str);
        var uri = {};
        var i = 14;
        while (i--) uri[o.key[i]] = m[i] || &quot;&quot;;
        return uri;
    }
,
    normalizeParameters: function normalizeParameters(parameters) {
        if (parameters == null) {
            return &quot;&quot;;
        }
        var list = OAuth.getParameterList(parameters);
        var sortable = [];
        for (var p = 0; p &lt; list.length; ++p) {
            var nvp = list[p];
            if (nvp[0] != &quot;oauth_signature&quot;) {
                sortable.push([ OAuth.percentEncode(nvp[0])
                              + &quot; &quot; // because it comes before any character that can appear in a percentEncoded string.
                              + OAuth.percentEncode(nvp[1])
                              , nvp]);
            }
        }
        sortable.sort(function(a,b) {
                          if (a[0] &lt; b[0]) return  -1;
                          if (a[0] &gt; b[0]) return 1;
                          return 0;
                      });
        var sorted = [];
        for (var s = 0; s &lt; sortable.length; ++s) {
            sorted.push(sortable[s][1]);
        }
        return OAuth.formEncode(sorted);
    }
});

OAuth.SignatureMethod.registerMethodClass([&quot;PLAINTEXT&quot;, &quot;PLAINTEXT-Accessor&quot;],
    OAuth.SignatureMethod.makeSubclass(
        function getSignature(baseString) {
            return this.key;
        }
    ));

OAuth.SignatureMethod.registerMethodClass([&quot;HMAC-SHA1&quot;, &quot;HMAC-SHA1-Accessor&quot;],
    OAuth.SignatureMethod.makeSubclass(
        function getSignature(baseString) {
            b64pad = &apos;=&apos;;
            var signature = b64_hmac_sha1(this.key, baseString);
            return signature;
        }
    ));

try {
    OAuth.correctTimestampFromSrc();
} catch(e) {
}


//--------------------------------------------------

var consumerKey = &quot;${consumer_key}&quot;;
var consumerSecret = &quot;${consumer_secret}&quot;;
var params = [];
var query = [];
query.push(&apos;access_token&apos; + &apos;=&apos; + &apos;${access_token}&apos;);
query.push(&apos;id_token&apos; + &apos;=&apos; + &apos;${id_token}&apos;);
var url =  &quot;${protocol}://${misp_url}/marvelous/people/@me/@self&quot;;

if (query.length) {
    url += &apos;?&apos; + query.join(&apos;&amp;&apos;);
}

var message = {
    method: &apos;get&apos;,
    parameters: params, 
    action: url
};

log.info(url);
log.info(consumerSecret);
       
var accessor = {
    consumerKey: consumerKey,
    consumerSecret: consumerSecret,
    token: &quot;${access_token}&quot;,
    tokenSecret: &quot;${id_token}&quot;
};

OAuth.completeRequest(message, accessor);
vars.put(&apos;get_auth_header&apos;, OAuth.getAuthorizationHeader(&apos;&apos;, params).replace(&apos;OAuth realm=&quot;&quot;,&apos;, &apos; OAuth &apos;));
</stringProp>
            <stringProp name="scriptLanguage">javascript</stringProp>
          </BSFPreProcessor>
          <hashTree/>
        </hashTree>
      </hashTree>
      <ThreadGroup guiclass="ThreadGroupGui" testclass="ThreadGroup" testname="ワザとミスリング 画面系は赤くなるのもあるけど例外を出すのが目的なのでそれでよし！！" enabled="true">
        <stringProp name="ThreadGroup.on_sample_error">continue</stringProp>
        <elementProp name="ThreadGroup.main_controller" elementType="LoopController" guiclass="LoopControlPanel" testclass="LoopController" testname="ループコントローラ" enabled="true">
          <boolProp name="LoopController.continue_forever">false</boolProp>
          <stringProp name="LoopController.loops">1</stringProp>
        </elementProp>
        <stringProp name="ThreadGroup.num_threads">1</stringProp>
        <stringProp name="ThreadGroup.ramp_time">1</stringProp>
        <longProp name="ThreadGroup.start_time">1386654990000</longProp>
        <longProp name="ThreadGroup.end_time">1386654990000</longProp>
        <boolProp name="ThreadGroup.scheduler">false</boolProp>
        <stringProp name="ThreadGroup.duration"></stringProp>
        <stringProp name="ThreadGroup.delay"></stringProp>
        <stringProp name="TestPlan.comments">結果のを応答データに「Application Error」の文字列があるかを確認する
exception.logに意図するログが出ているか確認する</stringProp>
      </ThreadGroup>
      <hashTree>
        <HTTPSamplerProxy guiclass="HttpTestSampleGui" testclass="HTTPSamplerProxy" testname="Error_Common_Exception_OauthInvalidRequest&lt;red&gt;" enabled="true">
          <elementProp name="HTTPsampler.Arguments" elementType="Arguments" guiclass="HTTPArgumentsPanel" testclass="Arguments" enabled="true">
            <collectionProp name="Arguments.arguments">
              <elementProp name="response_type" elementType="HTTPArgument">
                <boolProp name="HTTPArgument.always_encode">false</boolProp>
                <stringProp name="Argument.name">response_type</stringProp>
                <stringProp name="Argument.value">code</stringProp>
                <stringProp name="Argument.metadata">=</stringProp>
                <boolProp name="HTTPArgument.use_equals">true</boolProp>
              </elementProp>
              <elementProp name="client_id" elementType="HTTPArgument">
                <boolProp name="HTTPArgument.always_encode">false</boolProp>
                <stringProp name="Argument.name">client_id</stringProp>
                <stringProp name="Argument.value">00000</stringProp>
                <stringProp name="Argument.metadata">=</stringProp>
                <boolProp name="HTTPArgument.use_equals">true</boolProp>
              </elementProp>
              <elementProp name="redirect_uri" elementType="HTTPArgument">
                <boolProp name="HTTPArgument.always_encode">false</boolProp>
                <stringProp name="Argument.name">redirect_uri</stringProp>
                <stringProp name="Argument.value">${server_name}%2Ftest%2Fmisp%2Ferrorerroeerreere</stringProp>
                <stringProp name="Argument.metadata">=</stringProp>
                <boolProp name="HTTPArgument.use_equals">true</boolProp>
              </elementProp>
              <elementProp name="scope" elementType="HTTPArgument">
                <boolProp name="HTTPArgument.always_encode">false</boolProp>
                <stringProp name="Argument.name">scope</stringProp>
                <stringProp name="Argument.value">openid</stringProp>
                <stringProp name="Argument.metadata">=</stringProp>
                <boolProp name="HTTPArgument.use_equals">true</boolProp>
              </elementProp>
              <elementProp name="state" elementType="HTTPArgument">
                <boolProp name="HTTPArgument.always_encode">false</boolProp>
                <stringProp name="Argument.name">state</stringProp>
                <stringProp name="Argument.value">ddd</stringProp>
                <stringProp name="Argument.metadata">=</stringProp>
                <boolProp name="HTTPArgument.use_equals">true</boolProp>
              </elementProp>
              <elementProp name="platform_id" elementType="HTTPArgument">
                <boolProp name="HTTPArgument.always_encode">false</boolProp>
                <stringProp name="Argument.name">platform_id</stringProp>
                <stringProp name="Argument.value">Dummy3</stringProp>
                <stringProp name="Argument.metadata">=</stringProp>
                <boolProp name="HTTPArgument.use_equals">true</boolProp>
              </elementProp>
            </collectionProp>
          </elementProp>
          <stringProp name="HTTPSampler.domain"></stringProp>
          <stringProp name="HTTPSampler.port"></stringProp>
          <stringProp name="HTTPSampler.connect_timeout"></stringProp>
          <stringProp name="HTTPSampler.response_timeout"></stringProp>
          <stringProp name="HTTPSampler.protocol"></stringProp>
          <stringProp name="HTTPSampler.contentEncoding"></stringProp>
          <stringProp name="HTTPSampler.path">/marvelous/federation</stringProp>
          <stringProp name="HTTPSampler.method">GET</stringProp>
          <boolProp name="HTTPSampler.follow_redirects">true</boolProp>
          <boolProp name="HTTPSampler.auto_redirects">false</boolProp>
          <boolProp name="HTTPSampler.use_keepalive">true</boolProp>
          <boolProp name="HTTPSampler.DO_MULTIPART_POST">false</boolProp>
          <boolProp name="HTTPSampler.monitor">false</boolProp>
          <stringProp name="HTTPSampler.embedded_url_re"></stringProp>
          <stringProp name="TestPlan.comments">Common_Exception_OauthInvalidRequest が発生
例外が履かれていても、アサーションエラーが発生していないことを確認
500エラーの場合は赤くなるのを止められない…</stringProp>
        </HTTPSamplerProxy>
        <hashTree>
          <ResponseAssertion guiclass="AssertionGui" testclass="ResponseAssertion" testname="アサーション" enabled="true">
            <collectionProp name="Asserion.test_strings">
              <stringProp name="1207718697">Code : 400; Error : invalid_request</stringProp>
            </collectionProp>
            <stringProp name="Assertion.test_field">Assertion.response_data</stringProp>
            <boolProp name="Assertion.assume_success">false</boolProp>
            <intProp name="Assertion.test_type">2</intProp>
          </ResponseAssertion>
          <hashTree/>
        </hashTree>
        <HTTPSamplerProxy guiclass="HttpTestSampleGui" testclass="HTTPSamplerProxy" testname="invalid_grant" enabled="true">
          <elementProp name="HTTPsampler.Arguments" elementType="Arguments" guiclass="HTTPArgumentsPanel" testclass="Arguments" enabled="true">
            <collectionProp name="Arguments.arguments">
              <elementProp name="grant_type" elementType="HTTPArgument">
                <boolProp name="HTTPArgument.always_encode">false</boolProp>
                <stringProp name="Argument.value">authorization_code</stringProp>
                <stringProp name="Argument.metadata">=</stringProp>
                <boolProp name="HTTPArgument.use_equals">true</boolProp>
                <stringProp name="Argument.name">grant_type</stringProp>
              </elementProp>
              <elementProp name="code" elementType="HTTPArgument">
                <boolProp name="HTTPArgument.always_encode">false</boolProp>
                <stringProp name="Argument.value">hogeeeeeeeeeeeeee</stringProp>
                <stringProp name="Argument.metadata">=</stringProp>
                <boolProp name="HTTPArgument.use_equals">true</boolProp>
                <stringProp name="Argument.name">code</stringProp>
              </elementProp>
              <elementProp name="redirect_uri" elementType="HTTPArgument">
                <boolProp name="HTTPArgument.always_encode">false</boolProp>
                <stringProp name="Argument.value">${protocol}%3A%2F%2F${jmeter_path}%2Ftest%2Fmisp%2Fmisp-callback</stringProp>
                <stringProp name="Argument.metadata">=</stringProp>
                <boolProp name="HTTPArgument.use_equals">true</boolProp>
                <stringProp name="Argument.name">redirect_uri</stringProp>
              </elementProp>
            </collectionProp>
          </elementProp>
          <stringProp name="HTTPSampler.domain">${misp_url}</stringProp>
          <stringProp name="HTTPSampler.port"></stringProp>
          <stringProp name="HTTPSampler.connect_timeout"></stringProp>
          <stringProp name="HTTPSampler.response_timeout"></stringProp>
          <stringProp name="HTTPSampler.protocol">${protocol}</stringProp>
          <stringProp name="HTTPSampler.contentEncoding"></stringProp>
          <stringProp name="HTTPSampler.path">/marvelous/token</stringProp>
          <stringProp name="HTTPSampler.method">POST</stringProp>
          <boolProp name="HTTPSampler.follow_redirects">true</boolProp>
          <boolProp name="HTTPSampler.auto_redirects">false</boolProp>
          <boolProp name="HTTPSampler.use_keepalive">true</boolProp>
          <boolProp name="HTTPSampler.DO_MULTIPART_POST">false</boolProp>
          <boolProp name="HTTPSampler.monitor">false</boolProp>
          <stringProp name="HTTPSampler.embedded_url_re"></stringProp>
        </HTTPSamplerProxy>
        <hashTree>
          <BSFPreProcessor guiclass="TestBeanGUI" testclass="BSFPreProcessor" testname="BSF PreProcessor" enabled="true">
            <stringProp name="filename"></stringProp>
            <stringProp name="parameters"></stringProp>
            <stringProp name="script">/*
 * A JavaScript implementation of the Secure Hash Algorithm, SHA-1, as defined
 * in FIPS PUB 180-1
 * Version 2.1a Copyright Paul Johnston 2000 - 2002.
 * Other contributors: Greg Holt, Andrew Kepert, Ydnar, Lostinet
 * Distributed under the BSD License
 * See http://pajhome.org.uk/crypt/md5 for details.
 */

/*
 * Configurable variables. You may need to tweak these to be compatible with
 * the server-side, but the defaults work in most cases.
 */
var hexcase = 0;  /* hex output format. 0 - lowercase; 1 - uppercase        */
var b64pad  = &quot;&quot;; /* base-64 pad character. &quot;=&quot; for strict RFC compliance   */
var chrsz   = 8;  /* bits per input character. 8 - ASCII; 16 - Unicode      */

/*
 * These are the functions you&apos;ll usually want to call
 * They take string arguments and return either hex or base-64 encoded strings
 */
function hex_sha1(s){return binb2hex(core_sha1(str2binb(s),s.length * chrsz));}
function b64_sha1(s){return binb2b64(core_sha1(str2binb(s),s.length * chrsz));}
function str_sha1(s){return binb2str(core_sha1(str2binb(s),s.length * chrsz));}
function hex_hmac_sha1(key, data){ return binb2hex(core_hmac_sha1(key, data));}
function b64_hmac_sha1(key, data){ return binb2b64(core_hmac_sha1(key, data));}
function str_hmac_sha1(key, data){ return binb2str(core_hmac_sha1(key, data));}

/*
 * Perform a simple self-test to see if the VM is working
 */
function sha1_vm_test()
{
  return hex_sha1(&quot;abc&quot;) == &quot;a9993e364706816aba3e25717850c26c9cd0d89d&quot;;
}

/*
 * Calculate the SHA-1 of an array of big-endian words, and a bit length
 */
function core_sha1(x, len)
{
  /* append padding */
  x[len &gt;&gt; 5] |= 0x80 &lt;&lt; (24 - len % 32);
  x[((len + 64 &gt;&gt; 9) &lt;&lt; 4) + 15] = len;

  var w = Array(80);
  var a =  1732584193;
  var b = -271733879;
  var c = -1732584194;
  var d =  271733878;
  var e = -1009589776;

  for(var i = 0; i &lt; x.length; i += 16)
  {
    var olda = a;
    var oldb = b;
    var oldc = c;
    var oldd = d;
    var olde = e;

    for(var j = 0; j &lt; 80; j++)
    {
      if(j &lt; 16) w[j] = x[i + j];
      else w[j] = rol(w[j-3] ^ w[j-8] ^ w[j-14] ^ w[j-16], 1);
      var t = safe_add(safe_add(rol(a, 5), sha1_ft(j, b, c, d)),
                       safe_add(safe_add(e, w[j]), sha1_kt(j)));
      e = d;
      d = c;
      c = rol(b, 30);
      b = a;
      a = t;
    }

    a = safe_add(a, olda);
    b = safe_add(b, oldb);
    c = safe_add(c, oldc);
    d = safe_add(d, oldd);
    e = safe_add(e, olde);
  }
  return Array(a, b, c, d, e);

}

/*
 * Perform the appropriate triplet combination function for the current
 * iteration
 */
function sha1_ft(t, b, c, d)
{
  if(t &lt; 20) return (b &amp; c) | ((~b) &amp; d);
  if(t &lt; 40) return b ^ c ^ d;
  if(t &lt; 60) return (b &amp; c) | (b &amp; d) | (c &amp; d);
  return b ^ c ^ d;
}

/*
 * Determine the appropriate additive constant for the current iteration
 */
function sha1_kt(t)
{
  return (t &lt; 20) ?  1518500249 : (t &lt; 40) ?  1859775393 :
         (t &lt; 60) ? -1894007588 : -899497514;
}

/*
 * Calculate the HMAC-SHA1 of a key and some data
 */
function core_hmac_sha1(key, data)
{
  var bkey = str2binb(key);
  if(bkey.length &gt; 16) bkey = core_sha1(bkey, key.length * chrsz);

  var ipad = Array(16), opad = Array(16);
  for(var i = 0; i &lt; 16; i++)
  {
    ipad[i] = bkey[i] ^ 0x36363636;
    opad[i] = bkey[i] ^ 0x5C5C5C5C;
  }

  var hash = core_sha1(ipad.concat(str2binb(data)), 512 + data.length * chrsz);
  return core_sha1(opad.concat(hash), 512 + 160);
}

/*
 * Add integers, wrapping at 2^32. This uses 16-bit operations internally
 * to work around bugs in some JS interpreters.
 */
function safe_add(x, y)
{
  var lsw = (x &amp; 0xFFFF) + (y &amp; 0xFFFF);
  var msw = (x &gt;&gt; 16) + (y &gt;&gt; 16) + (lsw &gt;&gt; 16);
  return (msw &lt;&lt; 16) | (lsw &amp; 0xFFFF);
}

/*
 * Bitwise rotate a 32-bit number to the left.
 */
function rol(num, cnt)
{
  return (num &lt;&lt; cnt) | (num &gt;&gt;&gt; (32 - cnt));
}

/*
 * Convert an 8-bit or 16-bit string to an array of big-endian words
 * In 8-bit function, characters &gt;255 have their hi-byte silently ignored.
 */
function str2binb(str)
{
  var bin = Array();
  var mask = (1 &lt;&lt; chrsz) - 1;
  for(var i = 0; i &lt; str.length * chrsz; i += chrsz)
    bin[i&gt;&gt;5] |= (str.charCodeAt(i / chrsz) &amp; mask) &lt;&lt; (32 - chrsz - i%32);
  return bin;
}

/*
 * Convert an array of big-endian words to a string
 */
function binb2str(bin)
{
  var str = &quot;&quot;;
  var mask = (1 &lt;&lt; chrsz) - 1;
  for(var i = 0; i &lt; bin.length * 32; i += chrsz)
    str += String.fromCharCode((bin[i&gt;&gt;5] &gt;&gt;&gt; (32 - chrsz - i%32)) &amp; mask);
  return str;
}

/*
 * Convert an array of big-endian words to a hex string.
 */
function binb2hex(binarray)
{
  var hex_tab = hexcase ? &quot;0123456789ABCDEF&quot; : &quot;0123456789abcdef&quot;;
  var str = &quot;&quot;;
  for(var i = 0; i &lt; binarray.length * 4; i++)
  {
    str += hex_tab.charAt((binarray[i&gt;&gt;2] &gt;&gt; ((3 - i%4)*8+4)) &amp; 0xF) +
           hex_tab.charAt((binarray[i&gt;&gt;2] &gt;&gt; ((3 - i%4)*8  )) &amp; 0xF);
  }
  return str;
}

/*
 * Convert an array of big-endian words to a base-64 string
 */
function binb2b64(binarray)
{
  var tab = &quot;ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/&quot;;
  var str = &quot;&quot;;
  for(var i = 0; i &lt; binarray.length * 4; i += 3)
  {
    var triplet = (((binarray[i   &gt;&gt; 2] &gt;&gt; 8 * (3 -  i   %4)) &amp; 0xFF) &lt;&lt; 16)
                | (((binarray[i+1 &gt;&gt; 2] &gt;&gt; 8 * (3 - (i+1)%4)) &amp; 0xFF) &lt;&lt; 8 )
                |  ((binarray[i+2 &gt;&gt; 2] &gt;&gt; 8 * (3 - (i+2)%4)) &amp; 0xFF);
    for(var j = 0; j &lt; 4; j++)
    {
      if(i * 8 + j * 6 &gt; binarray.length * 32) str += b64pad;
      else str += tab.charAt((triplet &gt;&gt; 6*(3-j)) &amp; 0x3F);
    }
  }
  return str;
}

/*
 * Copyright 2008 Netflix, Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/* Here&apos;s some JavaScript software for implementing OAuth.

   This isn&apos;t as useful as you might hope.  OAuth is based around
   allowing tools and websites to talk to each other.  However,
   JavaScript running in web browsers is hampered by security
   restrictions that prevent code running on one website from
   accessing data stored or served on another.

   Before you start hacking, make sure you understand the limitations
   posed by cross-domain XMLHttpRequest.

   On the bright side, some platforms use JavaScript as their
   language, but enable the programmer to access other web sites.
   Examples include Google Gadgets, and Microsoft Vista Sidebar.
   For those platforms, this library should come in handy.
*/

// The HMAC-SHA1 signature method calls b64_hmac_sha1, defined by
// http://pajhome.org.uk/crypt/md5/sha1.js

/* An OAuth message is represented as an object like this:
   {method: &quot;GET&quot;, action: &quot;http://server.com/path&quot;, parameters: ...}

   The parameters may be either a map {name: value, name2: value2}
   or an Array of name-value pairs [[name, value], [name2, value2]].
   The latter representation is more powerful: it supports parameters
   in a specific sequence, or several parameters with the same name;
   for example [[&quot;a&quot;, 1], [&quot;b&quot;, 2], [&quot;a&quot;, 3]].

   Parameter names and values are NOT percent-encoded in an object.
   They must be encoded before transmission and decoded after reception.
   For example, this message object:
   {method: &quot;GET&quot;, action: &quot;http://server/path&quot;, parameters: {p: &quot;x y&quot;}}
   ... can be transmitted as an HTTP request that begins:
   GET /path?p=x%20y HTTP/1.0
   (This isn&apos;t a valid OAuth request, since it lacks a signature etc.)
   Note that the object &quot;x y&quot; is transmitted as x%20y.  To encode
   parameters, you can call OAuth.addToURL, OAuth.formEncode or
   OAuth.getAuthorization.

   This message object model harmonizes with the browser object model for
   input elements of an form, whose value property isn&apos;t percent encoded.
   The browser encodes each value before transmitting it. For example,
   see consumer.setInputs in example/consumer.js.
 */

/* This script needs to know what time it is. By default, it uses the local
   clock (new Date), which is apt to be inaccurate in browsers. To do
   better, you can load this script from a URL whose query string contains
   an oauth_timestamp parameter, whose value is a current Unix timestamp.
   For example, when generating the enclosing document using PHP:

   &lt;script src=&quot;oauth.js?oauth_timestamp=&lt;?=time()?&gt;&quot; ...

   Another option is to call OAuth.correctTimestamp with a Unix timestamp.
 */

var OAuth; if (OAuth == null) OAuth = {};

OAuth.setProperties = function setProperties(into, from) {
    if (into != null &amp;&amp; from != null) {
        for (var key in from) {
            into[key] = from[key];
        }
    }
    return into;
}

OAuth.setProperties(OAuth, // utility functions
{
    percentEncode: function percentEncode(s) {
        if (s == null) {
            return &quot;&quot;;
        }
        if (s instanceof Array) {
            var e = &quot;&quot;;
            for (var i = 0; i &lt; s.length; ++s) {
                if (e != &quot;&quot;) e += &apos;&amp;&apos;;
                e += OAuth.percentEncode(s[i]);
            }
            return e;
        }
        s = encodeURIComponent(s);
        // Now replace the values which encodeURIComponent doesn&apos;t do
        // encodeURIComponent ignores: - _ . ! ~ * &apos; ( )
        // OAuth dictates the only ones you can ignore are: - _ . ~
        // Source: http://developer.mozilla.org/en/docs/Core_JavaScript_1.5_Reference:Global_Functions:encodeURIComponent
        s = s.replace(/\!/g, &quot;%21&quot;);
        s = s.replace(/\*/g, &quot;%2A&quot;);
        s = s.replace(/\&apos;/g, &quot;%27&quot;);
        s = s.replace(/\(/g, &quot;%28&quot;);
        s = s.replace(/\)/g, &quot;%29&quot;);
        return s;
    }
,
    decodePercent: function decodePercent(s) {
        if (s != null) {
            // Handle application/x-www-form-urlencoded, which is defined by
            // http://www.w3.org/TR/html4/interact/forms.html#h-17.13.4.1
            s = s.replace(/\+/g, &quot; &quot;);
        }
        return decodeURIComponent(s);
    }
,
    /** Convert the given parameters to an Array of name-value pairs. */
    getParameterList: function getParameterList(parameters) {
        if (parameters == null) {
            return [];
        }
        if (typeof parameters != &quot;object&quot;) {
            return OAuth.decodeForm(parameters + &quot;&quot;);
        }
        if (parameters instanceof Array) {
            return parameters;
        }
        var list = [];
        for (var p in parameters) {
            list.push([p, parameters[p]]);
        }
        return list;
    }
,
    /** Convert the given parameters to a map from name to value. */
    getParameterMap: function getParameterMap(parameters) {
        if (parameters == null) {
            return {};
        }
        if (typeof parameters != &quot;object&quot;) {
            return OAuth.getParameterMap(OAuth.decodeForm(parameters + &quot;&quot;));
        }
        if (parameters instanceof Array) {
            var map = {};
            for (var p = 0; p &lt; parameters.length; ++p) {
                var key = parameters[p][0];
                if (map[key] === undefined) { // first value wins
                    map[key] = parameters[p][1];
                }
            }
            return map;
        }
        return parameters;
    }
,
    getParameter: function getParameter(parameters, name) {
        if (parameters instanceof Array) {
            for (var p = 0; p &lt; parameters.length; ++p) {
                if (parameters[p][0] == name) {
                    return parameters[p][1]; // first value wins
                }
            }
        } else {
            return OAuth.getParameterMap(parameters)[name];
        }
        return null;
    }
,
    formEncode: function formEncode(parameters) {
        var form = &quot;&quot;;
        var list = OAuth.getParameterList(parameters);
        for (var p = 0; p &lt; list.length; ++p) {
            var value = list[p][1];
            if (value == null) value = &quot;&quot;;
            if (form != &quot;&quot;) form += &apos;&amp;&apos;;
            form += OAuth.percentEncode(list[p][0])
              +&apos;=&apos;+ OAuth.percentEncode(value);
        }
        return form;
    }
,
    decodeForm: function decodeForm(form) {
        var list = [];
        var nvps = form.split(&apos;&amp;&apos;);
        for (var n = 0; n &lt; nvps.length; ++n) {
            var nvp = nvps[n];
            if (nvp == &quot;&quot;) {
                continue;
            }
            var equals = nvp.indexOf(&apos;=&apos;);
            var name;
            var value;
            if (equals &lt; 0) {
                name = OAuth.decodePercent(nvp);
                value = null;
            } else {
                name = OAuth.decodePercent(nvp.substring(0, equals));
                value = OAuth.decodePercent(nvp.substring(equals + 1));
            }
            list.push([name, value]);
        }
        return list;
    }
,
    setParameter: function setParameter(message, name, value) {
        var parameters = message.parameters;
        if (parameters instanceof Array) {
            for (var p = 0; p &lt; parameters.length; ++p) {
                if (parameters[p][0] == name) {
                    if (value === undefined) {
                        parameters.splice(p, 1);
                    } else {
                        parameters[p][1] = value;
                        value = undefined;
                    }
                }
            }
            if (value !== undefined) {
                parameters.push([name, value]);
            }
        } else {
            parameters = OAuth.getParameterMap(parameters);
            parameters[name] = value;
            message.parameters = parameters;
        }
    }
,
    setParameters: function setParameters(message, parameters) {
        var list = OAuth.getParameterList(parameters);
        for (var i = 0; i &lt; list.length; ++i) {
            OAuth.setParameter(message, list[i][0], list[i][1]);
        }
    }
,
    /** Fill in parameters to help construct a request message.
        This function doesn&apos;t fill in every parameter.
        The accessor object should be like:
        {consumerKey:&apos;foo&apos;, consumerSecret:&apos;bar&apos;, accessorSecret:&apos;nurn&apos;, token:&apos;krelm&apos;, tokenSecret:&apos;blah&apos;}
        The accessorSecret property is optional.
     */
    completeRequest: function completeRequest(message, accessor) {
        if (message.method == null) {
            message.method = &quot;GET&quot;;
        }
        var map = OAuth.getParameterMap(message.parameters);
        if (map.oauth_consumer_key == null) {
            OAuth.setParameter(message, &quot;oauth_consumer_key&quot;, accessor.consumerKey || &quot;&quot;);
        }
        if (map.oauth_token == null &amp;&amp; accessor.token != null) {
            OAuth.setParameter(message, &quot;oauth_token&quot;, accessor.token);
        }
        if (map.oauth_version == null) {
            OAuth.setParameter(message, &quot;oauth_version&quot;, &quot;1.0&quot;);
        }
        if (map.oauth_timestamp == null) {
            OAuth.setParameter(message, &quot;oauth_timestamp&quot;, OAuth.timestamp());
        }
        if (map.oauth_nonce == null) {
            OAuth.setParameter(message, &quot;oauth_nonce&quot;, OAuth.nonce(6));
        }
        OAuth.SignatureMethod.sign(message, accessor);
    }
,
    setTimestampAndNonce: function setTimestampAndNonce(message) {
        OAuth.setParameter(message, &quot;oauth_timestamp&quot;, OAuth.timestamp());
        OAuth.setParameter(message, &quot;oauth_nonce&quot;, OAuth.nonce(6));
    }
,
    addToURL: function addToURL(url, parameters) {
        newURL = url;
        if (parameters != null) {
            var toAdd = OAuth.formEncode(parameters);
            if (toAdd.length &gt; 0) {
                var q = url.indexOf(&apos;?&apos;);
                if (q &lt; 0) newURL += &apos;?&apos;;
                else       newURL += &apos;&amp;&apos;;
                newURL += toAdd;
            }
        }
        return newURL;
    }
,
    /** Construct the value of the Authorization header for an HTTP request. */
    getAuthorizationHeader: function getAuthorizationHeader(realm, parameters) {
        var header = &apos;OAuth realm=&quot;&apos; + OAuth.percentEncode(realm) + &apos;&quot;&apos;;
        var list = OAuth.getParameterList(parameters);
        for (var p = 0; p &lt; list.length; ++p) {
            var parameter = list[p];
            var name = parameter[0];
            if (name.indexOf(&quot;oauth_&quot;) == 0) {
                header += &apos;,&apos; + OAuth.percentEncode(name) + &apos;=&quot;&apos; + OAuth.percentEncode(parameter[1]) + &apos;&quot;&apos;;
            }
        }
        return header;
    }
,
    /** Correct the time using a parameter from the URL from which the last script was loaded. */
    correctTimestampFromSrc: function correctTimestampFromSrc(parameterName) {
        parameterName = parameterName || &quot;oauth_timestamp&quot;;
        var scripts = document.getElementsByTagName(&apos;script&apos;);
        if (scripts == null || !scripts.length) return;
        var src = scripts[scripts.length-1].src;
        if (!src) return;
        var q = src.indexOf(&quot;?&quot;);
        if (q &lt; 0) return;
        parameters = OAuth.getParameterMap(OAuth.decodeForm(src.substring(q+1)));
        var t = parameters[parameterName];
        if (t == null) return;
        OAuth.correctTimestamp(t);
    }
,
    /** Generate timestamps starting with the given value. */
    correctTimestamp: function correctTimestamp(timestamp) {
        OAuth.timeCorrectionMsec = (timestamp * 1000) - (new Date()).getTime();
    }
,
    /** The difference between the correct time and my clock. */
    timeCorrectionMsec: 0
,
    timestamp: function timestamp() {
        var t = (new Date()).getTime() + OAuth.timeCorrectionMsec;
        return Math.floor(t / 1000);
    }
,
    nonce: function nonce(length) {
        var chars = OAuth.nonce.CHARS;
        var result = &quot;&quot;;
        for (var i = 0; i &lt; length; ++i) {
            var rnum = Math.floor(Math.random() * chars.length);
            result += chars.substring(rnum, rnum+1);
        }
        return result;
    }
});

OAuth.nonce.CHARS = &quot;0123456789ABCDEFGHIJKLMNOPQRSTUVWXTZabcdefghiklmnopqrstuvwxyz&quot;;

/** Define a constructor function,
    without causing trouble to anyone who was using it as a namespace.
    That is, if parent[name] already existed and had properties,
    copy those properties into the new constructor.
 */
OAuth.declareClass = function declareClass(parent, name, newConstructor) {
    var previous = parent[name];
    parent[name] = newConstructor;
    if (newConstructor != null &amp;&amp; previous != null) {
        for (var key in previous) {
            if (key != &quot;prototype&quot;) {
                newConstructor[key] = previous[key];
            }
        }
    }
    return newConstructor;
}

/** An abstract algorithm for signing messages. */
OAuth.declareClass(OAuth, &quot;SignatureMethod&quot;, function OAuthSignatureMethod(){});

OAuth.setProperties(OAuth.SignatureMethod.prototype, // instance members
{
    /** Add a signature to the message. */
    sign: function sign(message) {
        var baseString = OAuth.SignatureMethod.getBaseString(message);
        var signature = this.getSignature(baseString);
        OAuth.setParameter(message, &quot;oauth_signature&quot;, signature);
        return signature; // just in case someone&apos;s interested
    }
,
    /** Set the key string for signing. */
    initialize: function initialize(name, accessor) {
        var consumerSecret;
        if (accessor.accessorSecret != null
            &amp;&amp; name.length &gt; 9
            &amp;&amp; name.substring(name.length-9) == &quot;-Accessor&quot;)
        {
            consumerSecret = accessor.accessorSecret;
        } else {
            consumerSecret = accessor.consumerSecret;
        }
        this.key = OAuth.percentEncode(consumerSecret)
             +&quot;&amp;&quot;+ OAuth.percentEncode(accessor.tokenSecret);
    }
});

/* SignatureMethod expects an accessor object to be like this:
   {tokenSecret: &quot;lakjsdflkj...&quot;, consumerSecret: &quot;QOUEWRI..&quot;, accessorSecret: &quot;xcmvzc...&quot;}
   The accessorSecret property is optional.
 */
// Class members:
OAuth.setProperties(OAuth.SignatureMethod, // class members
{
    sign: function sign(message, accessor) {
        var name = OAuth.getParameterMap(message.parameters).oauth_signature_method;
        if (name == null || name == &quot;&quot;) {
            name = &quot;HMAC-SHA1&quot;;
            OAuth.setParameter(message, &quot;oauth_signature_method&quot;, name);
        }
        OAuth.SignatureMethod.newMethod(name, accessor).sign(message);
    }
,
    /** Instantiate a SignatureMethod for the given method name. */
    newMethod: function newMethod(name, accessor) {
        var impl = OAuth.SignatureMethod.REGISTERED[name];
        if (impl != null) {
            var method = new impl();
            method.initialize(name, accessor);
            return method;
        }
        var err = new Error(&quot;signature_method_rejected&quot;);
        var acceptable = &quot;&quot;;
        for (var r in OAuth.SignatureMethod.REGISTERED) {
            if (acceptable != &quot;&quot;) acceptable += &apos;&amp;&apos;;
            acceptable += OAuth.percentEncode(r);
        }
        err.oauth_acceptable_signature_methods = acceptable;
        throw err;
    }
,
    /** A map from signature method name to constructor. */
    REGISTERED : {}
,
    /** Subsequently, the given constructor will be used for the named methods.
        The constructor will be called with no parameters.
        The resulting object should usually implement getSignature(baseString).
        You can easily define such a constructor by calling makeSubclass, below.
     */
    registerMethodClass: function registerMethodClass(names, classConstructor) {
        for (var n = 0; n &lt; names.length; ++n) {
            OAuth.SignatureMethod.REGISTERED[names[n]] = classConstructor;
        }
    }
,
    /** Create a subclass of OAuth.SignatureMethod, with the given getSignature function. */
    makeSubclass: function makeSubclass(getSignatureFunction) {
        var superClass = OAuth.SignatureMethod;
        var subClass = function() {
            superClass.call(this);
        };
        subClass.prototype = new superClass();
        // Delete instance variables from prototype:
        // delete subclass.prototype... There aren&apos;t any.
        subClass.prototype.getSignature = getSignatureFunction;
        subClass.prototype.constructor = subClass;
        return subClass;
    }
,
    getBaseString: function getBaseString(message) {
        var URL = message.action;
        var q = URL.indexOf(&apos;?&apos;);
        var parameters;
        if (q &lt; 0) {
            parameters = message.parameters;
        } else {
            // Combine the URL query string with the other parameters:
            parameters = OAuth.decodeForm(URL.substring(q + 1));
            var toAdd = OAuth.getParameterList(message.parameters);
            for (var a = 0; a &lt; toAdd.length; ++a) {
                parameters.push(toAdd[a]);
            }
        }
        return OAuth.percentEncode(message.method.toUpperCase())
         +&apos;&amp;&apos;+ OAuth.percentEncode(OAuth.SignatureMethod.normalizeUrl(URL))
         +&apos;&amp;&apos;+ OAuth.percentEncode(OAuth.SignatureMethod.normalizeParameters(parameters));
    }
,
    normalizeUrl: function normalizeUrl(url) {
        var uri = OAuth.SignatureMethod.parseUri(url);
        var scheme = uri.protocol.toLowerCase();
        var authority = uri.authority.toLowerCase();
        var dropPort = (scheme == &quot;http&quot; &amp;&amp; uri.port == 80)
                    || (scheme == &quot;https&quot; &amp;&amp; uri.port == 443);
        if (dropPort) {
            // find the last : in the authority
            var index = authority.lastIndexOf(&quot;:&quot;);
            if (index &gt;= 0) {
                authority = authority.substring(0, index);
            }
        }
        var path = uri.path;
        if (!path) {
            path = &quot;/&quot;; // conforms to RFC 2616 section 3.2.2
        }
        // we know that there is no query and no fragment here.
        return scheme + &quot;://&quot; + authority + path;
    }
,
    parseUri: function parseUri (str) {
        /* This function was adapted from parseUri 1.2.1
           http://stevenlevithan.com/demo/parseuri/js/assets/parseuri.js
         */
        var o = {key: [&quot;source&quot;,&quot;protocol&quot;,&quot;authority&quot;,&quot;userInfo&quot;,&quot;user&quot;,&quot;password&quot;,&quot;host&quot;,&quot;port&quot;,&quot;relative&quot;,&quot;path&quot;,&quot;directory&quot;,&quot;file&quot;,&quot;query&quot;,&quot;anchor&quot;],
                 parser: {strict: /^(?:([^:\/?#]+):)?(?:\/\/((?:(([^:@\/]*):?([^:@\/]*))?@)?([^:\/?#]*)(?::(\d*))?))?((((?:[^?#\/]*\/)*)([^?#]*))(?:\?([^#]*))?(?:#(.*))?)/ }};
        var m = o.parser.strict.exec(str);
        var uri = {};
        var i = 14;
        while (i--) uri[o.key[i]] = m[i] || &quot;&quot;;
        return uri;
    }
,
    normalizeParameters: function normalizeParameters(parameters) {
        if (parameters == null) {
            return &quot;&quot;;
        }
        var list = OAuth.getParameterList(parameters);
        var sortable = [];
        for (var p = 0; p &lt; list.length; ++p) {
            var nvp = list[p];
            if (nvp[0] != &quot;oauth_signature&quot;) {
                sortable.push([ OAuth.percentEncode(nvp[0])
                              + &quot; &quot; // because it comes before any character that can appear in a percentEncoded string.
                              + OAuth.percentEncode(nvp[1])
                              , nvp]);
            }
        }
        sortable.sort(function(a,b) {
                          if (a[0] &lt; b[0]) return  -1;
                          if (a[0] &gt; b[0]) return 1;
                          return 0;
                      });
        var sorted = [];
        for (var s = 0; s &lt; sortable.length; ++s) {
            sorted.push(sortable[s][1]);
        }
        return OAuth.formEncode(sorted);
    }
});

OAuth.SignatureMethod.registerMethodClass([&quot;PLAINTEXT&quot;, &quot;PLAINTEXT-Accessor&quot;],
    OAuth.SignatureMethod.makeSubclass(
        function getSignature(baseString) {
            return this.key;
        }
    ));

OAuth.SignatureMethod.registerMethodClass([&quot;HMAC-SHA1&quot;, &quot;HMAC-SHA1-Accessor&quot;],
    OAuth.SignatureMethod.makeSubclass(
        function getSignature(baseString) {
            b64pad = &apos;=&apos;;
            var signature = b64_hmac_sha1(this.key, baseString);
            return signature;
        }
    ));

try {
    OAuth.correctTimestampFromSrc();
} catch(e) {
}


//--------------------------------------------------

var consumerKey = &quot;${consumer_key}&quot;;
var consumerSecret = &quot;${consumer_secret}&quot;;
var params = [];
var query = [];
query.push(&apos;grant_type&apos; + &apos;=&apos; + &apos;authorization_code&apos;);
query.push(&apos;code&apos; + &apos;=&apos; + &apos;hogeeeeeeeeeeeeee&apos;);
query.push(&apos;redirect_uri&apos; + &apos;=&apos; + &apos;${protocol}%3A%2F%2F${jmeter_path}%2Ftest%2Fmisp%2Fmisp-callback&apos;);
var url =  &quot;${protocol}://${misp_url}/marvelous/token&quot;;

if (query.length) {
    url += &apos;?&apos; + query.join(&apos;&amp;&apos;);
}

var message = {
    method: &apos;post&apos;,
    parameters: params, 
    action: url
};
       
var accessor = {
    consumerKey: consumerKey,
    consumerSecret: consumerSecret,
    token: null,
    tokenSecret: null
};

OAuth.completeRequest(message, accessor);
vars.put(&apos;token_auth_header&apos;, OAuth.getAuthorizationHeader(&apos;&apos;, params).replace(&apos;OAuth realm=&quot;&quot;,&apos;, &apos; OAuth &apos;));
</stringProp>
            <stringProp name="scriptLanguage">javascript</stringProp>
          </BSFPreProcessor>
          <hashTree/>
          <HeaderManager guiclass="HeaderPanel" testclass="HeaderManager" testname="HTTP ヘッダマネージャ" enabled="true">
            <collectionProp name="HeaderManager.headers">
              <elementProp name="" elementType="Header">
                <stringProp name="Header.name">Authorization</stringProp>
                <stringProp name="Header.value">${token_auth_header}</stringProp>
              </elementProp>
              <elementProp name="" elementType="Header">
                <stringProp name="Header.name">content-type</stringProp>
                <stringProp name="Header.value">application/x-www-form-urlencoded</stringProp>
              </elementProp>
            </collectionProp>
          </HeaderManager>
          <hashTree/>
          <ResponseAssertion guiclass="AssertionGui" testclass="ResponseAssertion" testname="アサーション" enabled="true">
            <collectionProp name="Asserion.test_strings">
              <stringProp name="1854391686">{&quot;error&quot;:&quot;invalid_grant&quot;}</stringProp>
            </collectionProp>
            <stringProp name="Assertion.test_field">Assertion.response_data</stringProp>
            <boolProp name="Assertion.assume_success">false</boolProp>
            <intProp name="Assertion.test_type">2</intProp>
          </ResponseAssertion>
          <hashTree/>
          <BSFAssertion guiclass="TestBeanGUI" testclass="BSFAssertion" testname="レスポンスコード400" enabled="true">
            <stringProp name="filename"></stringProp>
            <stringProp name="parameters"></stringProp>
            <stringProp name="script">if (prev.getResponseCode() == &quot;400&quot;) {
	AssertionResult.setFailure(false);
	prev.setSuccessful(true);
} else {
	AssertionResult.setFailure(true);
}</stringProp>
            <stringProp name="scriptLanguage">javascript</stringProp>
          </BSFAssertion>
          <hashTree/>
        </hashTree>
      </hashTree>
      <ResponseAssertion guiclass="AssertionGui" testclass="ResponseAssertion" testname="アサーション" enabled="true">
        <collectionProp name="Asserion.test_strings">
          <stringProp name="-643627353">&lt;b&gt;Warning&lt;/b&gt;:</stringProp>
          <stringProp name="-1955822856">Notice</stringProp>
        </collectionProp>
        <stringProp name="Assertion.test_field">Assertion.response_data</stringProp>
        <boolProp name="Assertion.assume_success">false</boolProp>
        <intProp name="Assertion.test_type">6</intProp>
      </ResponseAssertion>
      <hashTree/>
    </hashTree>
  </hashTree>
</jmeterTestPlan>
